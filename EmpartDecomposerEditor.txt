using UnityEngine;
using UnityEditor;
using Empart.EmberPart; // Use the namespace from your script

/// <summary>
/// Custom Editor for the EmpartDecomposer.
/// This creates the "Generate" and "Remove" buttons in the inspector
/// and provides a clean layout for the component's properties.
/// </summary>
[CustomEditor(typeof(EmpartDecomposer))]
public class EmpartDecomposerEditor : Editor
{
    // SerializedProperties for robust Undo/Redo support
    SerializedProperty settingsProp;
    SerializedProperty sourceObjectProp;
    SerializedProperty regionBoxesProp;
    SerializedProperty hullObjectsProp;
    SerializedProperty metricsProp;
    SerializedProperty interactiveModeProp;
    SerializedProperty showBoundsProp;

    private void OnEnable()
    {
        // Link the SerializedProperties to the fields in EmpartDecomposer
        settingsProp = serializedObject.FindProperty("settings");
        sourceObjectProp = serializedObject.FindProperty("sourceObject");
        regionBoxesProp = serializedObject.FindProperty("regionBoxes");
        hullObjectsProp = serializedObject.FindProperty("hullObjects");
        metricsProp = serializedObject.FindProperty("metrics");
        interactiveModeProp = serializedObject.FindProperty("enableInteractiveMode");
        showBoundsProp = serializedObject.FindProperty("showRegionBounds");
    }

    public override void OnInspectorGUI()
    {
        // Get the target component instance
        EmpartDecomposer decomposer = (EmpartDecomposer)target;

        // Update the serializedObject to match the component's state
        serializedObject.Update();

        EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(settingsProp);
        if (settingsProp.objectReferenceValue == null)
        {
            EditorGUILayout.HelpBox("You must assign a ConvexDecompositionSettings ScriptableObject.", MessageType.Error);
        }
        EditorGUILayout.Space();

        EditorGUILayout.LabelField("Input", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(sourceObjectProp);
        if (sourceObjectProp.objectReferenceValue == null)
        {
            EditorGUILayout.HelpBox("No Source Object assigned. The script will default to this GameObject.", MessageType.Info);
        }
        EditorGUILayout.PropertyField(regionBoxesProp, true); // true = draw children
        EditorGUILayout.Space();

        EditorGUILayout.LabelField("Debug Gizmos", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(interactiveModeProp);
        EditorGUILayout.PropertyField(showBoundsProp);
        EditorGUILayout.Space();

        EditorGUILayout.LabelField("Controls", EditorStyles.boldLabel);

        // Check if settings are assigned before enabling the button
        bool settingsAssigned = settingsProp.objectReferenceValue != null;

        GUI.enabled = settingsAssigned; // Disable button if no settings
        if (GUILayout.Button("Generate Convex Hulls"))
        {
            // Call the public method from the target script
            decomposer.DecomposeMesh();
        }
        GUI.enabled = true; // Re-enable GUI for other controls

        if (GUILayout.Button("Run Smoke Test"))
        {
            decomposer.RunSmokeTest();
        }

        if (!settingsAssigned)
        {
            EditorGUILayout.HelpBox("Assign settings to enable generation.", MessageType.Warning);
        }

        // Only show the "Remove" button if there's something to remove
        if (decomposer.hullObjects != null && decomposer.hullObjects.Count > 0)
        {
            GUI.backgroundColor = Color.red; // Make the remove button red
            if (GUILayout.Button("Remove Generated Hulls"))
            {
                // Call our custom clear function
                ClearGeneratedHulls(decomposer);
            }
            GUI.backgroundColor = Color.white; // Reset color
        }
        EditorGUILayout.Space();

        EditorGUILayout.LabelField("Output (Read-Only)", EditorStyles.boldLabel);

        // Disable editing for the output fields
        GUI.enabled = false;
        EditorGUILayout.PropertyField(hullObjectsProp, true);
        EditorGUILayout.PropertyField(metricsProp, true);
        GUI.enabled = true;

        // Apply any changes made in the inspector
        serializedObject.ApplyModifiedProperties();
    }

    /// <summary>
    /// Re-implements the logic from the private ClearResults() method
    /// to allow clearing hulls from the editor.
    /// </summary>
    private void ClearGeneratedHulls(EmpartDecomposer decomposer)
    {
        // Find the container object named "ConvexHulls"
        var container = decomposer.transform.Find("ConvexHulls");
        if (container != null)
        {
            // Use DestroyImmediate for editor-time operations
            DestroyImmediate(container.gameObject);
        }

        // The container is gone, but the list might still have references
        // to objects that were *not* in the container.
        // This loop cleans up any stragglers.
        foreach (var hullObj in decomposer.hullObjects)
        {
            if (hullObj != null)
            {
                DestroyImmediate(hullObj);
            }
        }

        // Clear the list and metrics in the component
        decomposer.hullObjects.Clear();
        decomposer.metrics = new EmpartDecomposer.DecompositionMetrics();

        // Mark the component as "dirty" to save the changes (cleared list/metrics)
        EditorUtility.SetDirty(decomposer);
    }
}