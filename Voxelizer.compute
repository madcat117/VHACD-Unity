#pragma kernel Clear
#pragma kernel VoxelizeSurface
#pragma kernel Solidify
#pragma kernel FinalizeSDF

// Buffers
RWStructuredBuffer<float> g_Voxels;
StructuredBuffer<float3> g_Vertices;
StructuredBuffer<int3> g_Indices;

// Uniforms
int g_TriangleCount;
int3 g_VoxelDimensions;
float3 g_VoxelBoundsMin;
float3 g_VoxelBoundsSize;

[numthreads(8,8,8)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * g_VoxelDimensions.x + id.z * g_VoxelDimensions.x * g_VoxelDimensions.y;
    if (index < g_VoxelDimensions.x * g_VoxelDimensions.y * g_VoxelDimensions.z)
    {
        g_Voxels[index] = 1.0; // Initialize all voxels to "outside"
    }
}

// ==================================================================================
// Separating Axis Theorem (SAT) for Triangle-AABB Intersection
// ==================================================================================
void project(float3 axis, float3 p0, float3 p1, float3 p2, out float min_val, out float max_val)
{
    min_val = dot(axis, p0);
    max_val = min_val;

    float d = dot(axis, p1);
    min_val = min(min_val, d);
    max_val = max(max_val, d);

    d = dot(axis, p2);
    min_val = min(min_val, d);
    max_val = max(max_val, d);
}

bool test_axis(float3 axis, float3 v0, float3 v1, float3 v2, float3 box_center, float3 box_half_size)
{
    float p0 = dot(axis, v0);
    float p1 = dot(axis, v1);
    float p2 = dot(axis, v2);

    float r = box_half_size.x * abs(axis.x) + box_half_size.y * abs(axis.y) + box_half_size.z * abs(axis.z);

    float min_p = min(p0, min(p1, p2));
    float max_p = max(p0, max(p1, p2));

    float box_center_proj = dot(axis, box_center);

    return (max(box_center_proj + r, max_p) - min(box_center_proj - r, min_p)) <= (r * 2 + max_p - min_p);
}

bool TriangleAABBOverlap(float3 v0, float3 v1, float3 v2, float3 box_center, float3 box_half_size)
{
    // Translate triangle so box is at origin
    v0 -= box_center;
    v1 -= box_center;
    v2 -= box_center;

    // Triangle edges
    float3 f0 = v1 - v0;
    float3 f1 = v2 - v1;
    float3 f2 = v0 - v2;

    // 1. AABB face normals (3 axes)
    if (!test_axis(float3(1, 0, 0), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(float3(0, 1, 0), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(float3(0, 0, 1), v0, v1, v2, float3(0,0,0), box_half_size)) return false;

    // 2. Triangle normal (1 axis)
    float3 tri_normal = cross(f0, f1);
    if (!test_axis(tri_normal, v0, v1, v2, float3(0,0,0), box_half_size)) return false;

    // 3. Cross products of triangle edges and box axes (9 axes)
    if (!test_axis(cross(float3(1, 0, 0), f0), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(1, 0, 0), f1), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(1, 0, 0), f2), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 1, 0), f0), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 1, 0), f1), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 1, 0), f2), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 0, 1), f0), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 0, 1), f1), v0, v1, v2, float3(0,0,0), box_half_size)) return false;
    if (!test_axis(cross(float3(0, 0, 1), f2), v0, v1, v2, float3(0,0,0), box_half_size)) return false;

    return true; // No separating axis found, they must overlap
}
// ==================================================================================

[numthreads(64,1,1)]
void VoxelizeSurface (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= g_TriangleCount) return;

    int3 tri = g_Indices[id.x];
    float3 v0 = g_Vertices[tri.x];
    float3 v1 = g_Vertices[tri.y];
    float3 v2 = g_Vertices[tri.z];

    // Calculate triangle bounding box
    float3 minP = min(v0, min(v1, v2));
    float3 maxP = max(v0, max(v1, v2));

    float3 voxel_size = g_VoxelBoundsSize / g_VoxelDimensions;

    // Convert to voxel coordinates, clamping to grid bounds
    int3 minCoord = max(int3(0,0,0), (int3)floor((minP - g_VoxelBoundsMin) / voxel_size));
    int3 maxCoord = min(g_VoxelDimensions - 1, (int3)ceil((maxP - g_VoxelBoundsMin) / voxel_size));

    // Iterate over voxels in the triangle's AABB
    for (int z = minCoord.z; z <= maxCoord.z; z++)
    {
        for (int y = minCoord.y; y <= maxCoord.y; y++)
        {
            for (int x = minCoord.x; x <= maxCoord.x; x++)
            {
                float3 voxelCenter = g_VoxelBoundsMin + (float3(x,y,z) + 0.5) * voxel_size;
                float3 voxelHalfSize = voxel_size * 0.5;

                if (TriangleAABBOverlap(v0, v1, v2, voxelCenter, voxelHalfSize))
                {
                    uint index = x + y * g_VoxelDimensions.x + z * g_VoxelDimensions.x * g_VoxelDimensions.y;
                    g_Voxels[index] = -1.0; // Mark as "inside" / on surface
                }
            }
        }
    }
}

[numthreads(8,8,1)]
void Solidify (uint3 id : SV_DispatchThreadID)
{
    // Parallel scanline flood fill along Z-axis
    uint x = id.x;
    uint y = id.y;

    if (x >= g_VoxelDimensions.x || y >= g_VoxelDimensions.y) return;

    bool inside = false;
    for (uint z = 0; z < g_VoxelDimensions.z; z++)
    {
        uint index = x + y * g_VoxelDimensions.x + z * g_VoxelDimensions.x * g_VoxelDimensions.y;

        // Check if the current voxel is a surface voxel
        if (g_Voxels[index] < 0)
        {
            inside = !inside;
        }

        if (inside)
        {
            // Mark the voxel as inside, even if it wasn't a surface voxel
             g_Voxels[index] = -1.0;
        }
    }
}

[numthreads(8,8,8)]
void FinalizeSDF (uint3 id : SV_DispatchThreadID)
{
    // This is a placeholder for a proper GPU-based Jump Flooding Algorithm (JFA).
    // A full JFA is complex and would involve multiple passes.
    // For now, this kernel just ensures the values are either -1 (inside) or 1 (outside).
    uint index = id.x + id.y * g_VoxelDimensions.x + id.z * g_VoxelDimensions.x * g_VoxelDimensions.y;
    if (index < g_VoxelDimensions.x * g_VoxelDimensions.y * g_VoxelDimensions.z)
    {
       if(g_Voxels[index] < 0)
       {
           g_Voxels[index] = -0.5; // Represents inside, close to surface
       }
       else
       {
           g_Voxels[index] = 0.5; // Represents outside, close to surface
       }
    }
}