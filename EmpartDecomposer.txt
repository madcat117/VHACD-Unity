using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Empart.EmberPart
{
    /// <summary>
    /// The main entry point for the Empart Convex Decomposition system. This MonoBehaviour orchestrates the entire
    /// decomposition pipeline, from pre-processing the input mesh to generating the final convex hull GameObjects.
    /// It is a highly configurable and extensible system designed for production use, offering a wide range of
    /// algorithms and settings to control the quality and performance of the decomposition.
    /// </summary>
    /// <remarks>
    /// This script integrates multiple advanced geometry processing algorithms, including:
    /// - Isotropic Remeshing for pre-processing.
    /// - Voxelization via CPU or GPU, including advanced Jump Flooding for SDF generation.
    /// - CoACD (Collision-Aware Convex Decomposition) for feature-aware splitting.
    /// - A full from-scratch QuickHull 3D implementation.
    /// - Multiple hull optimization and post-processing techniques.
    /// </remarks>
    public class EmpartDecomposer : MonoBehaviour
    {
        /// <summary>Defines a set of pre-configured quality levels for the decomposition process.</summary>
        public enum QualityPreset
        {
            /// <summary>Fastest decomposition with the lowest quality. Suitable for non-critical physics objects.</summary>
            Low,
            /// <summary>A balance between speed and quality. The recommended default for most use cases.</summary>
            Medium,
            /// <summary>High-quality decomposition, suitable for hero assets or objects requiring precise collision.</summary>
            High,
            /// <summary>Highest quality decomposition, at the cost of significant processing time.</summary>
            Ultra,
            /// <summary>Allows for manual configuration of all decomposition parameters.</summary>
            Custom
        }

        /// <summary>Determines the strategy used to select a split plane during the decomposition process.</summary>
        public enum SplittingStrategy
        {
            /// <summary>Attempts to create two new parts with a balanced number of vertices.</summary>
            Balanced,
            /// <summary>Prioritizes splitting based on the volume of the resulting parts.</summary>
            VolumeBased,
            /// <summary>Prioritizes splitting based on the surface area of the resulting parts.</summary>
            SurfaceAreaBased,
            /// <summary>Selects the split plane that resolves the most concavity.</summary>
            ConcavityBased,
            /// <summary>A CoACD-style approach that considers mesh features like sharp edges and saliency.</summary>
            FeatureBased,
            /// <summary>A hybrid approach that combines multiple strategies for a balanced result.</summary>
            Hybrid
        }

        /// <summary>Defines the algorithm used to convert the source mesh into a voxel representation.</summary>
        public enum VoxelizationStrategy
        {
            /// <summary>Voxelizes only the surface of the mesh.</summary>
            SurfaceOnly,
            /// <summary>Voxelizes the surface and then flood-fills the interior to create a solid volume.</summary>
            SolidFill,
            /// <summary>Determines if a voxel is inside or outside by casting rays from it.</summary>
            RaycastBased,
            /// <summary>Combines multiple voxelization techniques for a more robust result.</summary>
            Hybrid,
            /// <summary>Uses a higher voxel resolution in areas of high detail (e.g., high curvature).</summary>
            Adaptive
        }

        /// <summary>Defines the strategy for merging convex hulls together to reduce the final hull count.</summary>
        public enum MergingStrategy
        {
            /// <summary>Merges hulls based on their combined volume.</summary>
            VolumeBased,
            /// <summary>Merges hulls based on their combined surface area.</summary>
            SurfaceAreaBased,
            /// <summary>Merges hulls that are close to each other.</summary>
            DistanceBased,
            /// <summary>Merges hulls by considering the preservation of mesh features.</summary>
            FeatureBased,
            /// <summary>Builds a hierarchy of hulls and merges them based on a cost function.</summary>
            Hierarchical,
            /// <summary>An adaptive strategy that changes its criteria based on the current state of the decomposition.</summary>
            Adaptive
        }

        /// <summary>The core Approximate Convex Decomposition (ACD) algorithm to use.</summary>
        public enum ACDSubroutineType
        {
            /// <summary>Standard Voxel-based Hierarchical ACD.</summary>
            VHACD,
            /// <summary>Collision-Aware ACD, which is feature-aware and generally produces higher-quality results.</summary>
            CoACD,
            /// <summary>Directly uses the QuickHull algorithm on the entire mesh (not a decomposition method).</summary>
            QuickHull
        }

        /// <summary>The metric used to evaluate the error between the original mesh and the generated hulls.</summary>
        public enum ErrorMetricType
        {
            /// <summary>One-way Hausdorff distance.</summary>
            Hausdorff,
            /// <summary>The mean of the squared distances between the surfaces.</summary>
            MeanSquared,
            /// <summary>The square root of the Mean Squared Error.</summary>
            RootMeanSquared,
            /// <summary>Two-way Hausdorff distance, providing a more robust error metric.</summary>
            SymmetricHausdorff,
            /// <summary>The maximum deviation between the two surfaces.</summary>
            MaxDeviation,
            /// <summary>The difference in volume between the original mesh and the hulls.</summary>
            VolumeDifference,
            /// <summary>The difference in surface area between the original mesh and the hulls.</summary>
            SurfaceAreaDifference
        }

        /// <summary>The strategy used for sampling points on the mesh surface, used for error calculation and other analyses.</summary>
        public enum SamplingStrategy
        {
            /// <summary>Uniformly random sampling across the mesh surface.</summary>
            Uniform,
            /// <summary>Samples are weighted by the area of the triangles, ensuring a more even distribution.</summary>
            AreaWeighted,
            /// <summary>More samples are taken in areas of high curvature.</summary>
            CurvatureWeighted,
            /// <summary>Attempts to place more samples near important mesh features.</summary>
            FeaturePreserving,
            /// <summary>An adaptive strategy that adjusts the sampling density based on local complexity.</summary>
            Adaptive,
            /// <summary>Divides the mesh into strata and samples from each, ensuring good coverage.</summary>
            Stratified
        }

        /// <summary>The algorithm to use for optimizing the individual convex hulls to reduce their vertex count.</summary>
        public enum HullOptimizationStrategy
        {
            /// <summary>A simple iterative vertex reduction based on a cost function.</summary>
            VertexReduction,
            /// <summary>Merges adjacent faces that are nearly coplanar.</summary>
            FaceMerging,
            /// <summary>Collapses short edges to reduce vertex count.</summary>
            EdgeCollapse,
            /// <summary>Iteratively refines the hull to better fit the original mesh.</summary>
            IterativeRefinement,
            /// <summary>Uses a genetic algorithm to find an optimal simplified hull.</summary>
            GeneticAlgorithm,
            /// <summary>Uses simulated annealing to find an optimal simplified hull.</summary>
            SimulatedAnnealing
        }

        /// <summary>The type of post-processing to apply to the final convex hulls.</summary>
        public enum PostProcessingType
        {
            /// <summary>No post-processing.</summary>
            None,
            /// <summary>Applies Laplacian smoothing to the hull vertices.</summary>
            Smoothing,
            /// <summary>Reduces the number of vertices in the hull (same as optimization).</summary>
            Simplification,
            /// <summary>Identifies and triangulates holes in the hull geometry.</summary>
            HoleFilling,
            /// <summary>Ensures that boundary vertices are not modified during processing.</summary>
            BoundaryPreservation,
            /// <summary>Enforces symmetry on the hull based on detected symmetry planes.</summary>
            SymmetryEnforcement
        }
        /// <summary>
        /// Burst-safe plane structure to replace UnityEngine.Plane
        /// </summary>
        public struct Plane4
        {
            public float3 n; // unit normal
            public float d; // ax + by + cz + d = 0
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public float DistanceToPoint(float3 p) => math.dot(n, p) + d;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool IntersectsRay(float3 rayOrigin, float3 rayDirection, out float t)
            {
                float denom = math.dot(n, rayDirection);
                if (math.abs(denom) < 1e-6f)
                {
                    t = 0f;
                    return false;
                }
                t = -(math.dot(n, rayOrigin) + d) / denom;
                return t > 0f;
            }
            // Additional utility: Project point onto plane
            public float3 ProjectPoint(float3 point)
            {
                return point - DistanceToPoint(point) * n;
            }
            // Equality check with epsilon
            public bool Equals(Plane4 other, float epsilon = 1e-5f)
            {
                return math.all(math.abs(n - other.n) < epsilon) && math.abs(d - other.d) < epsilon;
            }
            // Additional: Flip plane
            public void Flip()
            {
                n = -n;
                d = -d;
            }
            // Additional: Get plane equation string
            public string ToEquation()
            {
                return $"{n.x}x + {n.y}y + {n.z}z + {d} = 0";
            }
        }
        /// <summary>
        /// Simple max-priority queue for Unity (replaces System.Collections.Generic.PriorityQueue)
        /// </summary>
        public sealed class MaxPQ<T>
        {
            readonly List<(T item, float key)> _data = new();
            readonly IComparer<float> _cmp = Comparer<float>.Default;
            public int Count => _data.Count;
            public void Enqueue(T item, float key)
            {
                _data.Add((item, key));
                int i = _data.Count - 1;
                while (i > 0)
                {
                    int p = (i - 1) >> 1;
                    if (_cmp.Compare(_data[i].key, _data[p].key) <= 0) break;
                    (_data[i], _data[p]) = (_data[p], _data[i]);
                    i = p;
                }
            }
            public T Dequeue()
            {
                if (_data.Count == 0) throw new InvalidOperationException("Queue is empty");
                var root = _data[0].item;
                int last = _data.Count - 1;
                _data[0] = _data[last];
                _data.RemoveAt(last);
                int i = 0;
                while (true)
                {
                    int l = i * 2 + 1, r = l + 1, largest = i;
                    if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                    if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                    if (largest == i) break;
                    (_data[i], _data[largest]) = (_data[largest], _data[i]);
                    i = largest;
                }
                return root;
            }
            public T Peek()
            {
                if (_data.Count == 0) throw new InvalidOperationException("Queue is empty");
                return _data[0].item;
            }
            public bool TryDequeue(out T item, out float key)
            {
                if (_data.Count == 0)
                {
                    item = default;
                    key = default;
                    return false;
                }
                key = _data[0].key;
                item = Dequeue();
                return true;
            }
            public void Clear() => _data.Clear();
            // Additional: Update priority of an item (inefficient, but useful for production)
            public void UpdatePriority(T item, float newKey)
            {
                int index = -1;
                for (int i = 0; i < _data.Count; i++)
                {
                    if (EqualityComparer<T>.Default.Equals(_data[i].item, item))
                    {
                        index = i;
                        break;
                    }
                }
                if (index == -1) return;
                float oldKey = _data[index].key;
                _data[index] = (_data[index].item, newKey);
                if (newKey > oldKey)
                {
                    // Heapify up
                    while (index > 0)
                    {
                        int p = (index - 1) >> 1;
                        if (_cmp.Compare(_data[index].key, _data[p].key) <= 0) break;
                        (_data[index], _data[p]) = (_data[p], _data[index]);
                        index = p;
                    }
                }
                else
                {
                    // Heapify down
                    while (true)
                    {
                        int l = index * 2 + 1, r = l + 1, largest = index;
                        if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                        if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                        if (largest == index) break;
                        (_data[index], _data[largest]) = (_data[largest], _data[index]);
                        index = largest;
                    }
                }
            }
            // Additional: Check if contains item
            public bool Contains(T item)
            {
                return _data.Any(d => EqualityComparer<T>.Default.Equals(d.item, item));
            }
            // Additional: Get all items
            public List<T> GetAllItems()
            {
                return _data.Select(d => d.item).ToList();
            }
            // Additional: Remove specific item
            public bool Remove(T item)
            {
                int index = -1;
                for (int i = 0; i < _data.Count; i++)
                {
                    if (EqualityComparer<T>.Default.Equals(_data[i].item, item))
                    {
                        index = i;
                        break;
                    }
                }
                if (index == -1) return false;
                int last = _data.Count - 1;
                _data[index] = _data[last];
                _data.RemoveAt(last);
                // Heapify down
                while (true)
                {
                    int l = index * 2 + 1, r = l + 1, largest = index;
                    if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                    if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                    if (largest == index) break;
                    (_data[index], _data[largest]) = (_data[largest], _data[index]);
                    index = largest;
                }
                return true;
            }
        }
        /// <summary>
        /// Approximate Vector3 comparer for duplicate vertex detection
        /// </summary>
        sealed class ApproxVec3Comparer : IEqualityComparer<Vector3>
        {
            readonly float eps;
            public ApproxVec3Comparer(float e) { eps = e; }
            public bool Equals(Vector3 a, Vector3 b) => (a - b).sqrMagnitude <= eps * eps;
            public int GetHashCode(Vector3 v) => HashCode.Combine(
                Mathf.RoundToInt(v.x / eps),
                Mathf.RoundToInt(v.y / eps),
                Mathf.RoundToInt(v.z / eps));
            // Additional: Distance between two points
            public float Distance(Vector3 a, Vector3 b)
            {
                return (a - b).magnitude;
            }
            // Additional: Check if close enough
            public bool IsClose(Vector3 a, Vector3 b, float tolerance)
            {
                return (a - b).sqrMagnitude <= tolerance * tolerance;
            }
        }
        /// <summary>A ScriptableObject containing all parameters for the convex decomposition process.</summary>
        /// <remarks>This allows for easy saving, sharing, and versioning of decomposition settings.</remarks>
        [CreateAssetMenu(fileName = "ConvexDecompositionSettings", menuName = "Empart/Convex Decomposition Settings")]
        public class ConvexDecompositionSettings : ScriptableObject
        {
            // =================================================================================================
            // Quality Settings
            // =================================================================================================
            [Header("Quality Settings")]
            [Tooltip("A preset for overall quality, affecting multiple parameters.")]
            public QualityPreset qualityPreset = QualityPreset.Medium;
            [Tooltip("The maximum allowed error between the original mesh and the generated hulls. Measured using the primary error metric.")]
            public float errorTolerance = 0.01f;
            [Tooltip("The maximum number of convex hulls to generate.")]
            public int maxHullCount = 32;
            [Tooltip("The maximum number of vertices allowed per convex hull. Hulls exceeding this will be simplified.")]
            public int maxVerticesPerHull = 64;
            [Tooltip("The weight given to resolving concavity when evaluating a split. Higher values prioritize cutting deep cavities.")]
            public float concavityWeight = 0.5f;
            [Tooltip("The weight given to the volume of the resulting parts. Affects split evaluation.")]
            public float volumeWeight = 0.5f;
            [Tooltip("The weight given to creating balanced splits. Higher values produce parts of more equal size.")]
            public float balanceWeight = 0.1f;

            // =================================================================================================
            // Voxelization Settings
            // =================================================================================================
            [Header("Voxelization Settings")]
            [Tooltip("The CPU-based strategy for voxelization if the GPU pipeline is not used.")]
            public VoxelizationStrategy voxelizationStrategy = VoxelizationStrategy.Adaptive;
            [Tooltip("The size of a single voxel in world units. Smaller values increase accuracy and memory usage.")]
            public float voxelSize = 0.05f;
            [Tooltip("The factor by which to increase voxel resolution in high-detail areas when using Adaptive voxelization.")]
            public float voxelAdaptivity = 0.5f;
            [Tooltip("A hard cap on the total number of voxels to prevent excessive memory allocation.")]
            public int maxVoxelCount = 1000000;

            // =================================================================================================
            // Splitting Settings
            // =================================================================================================
            [Header("Splitting Settings")]
            [Tooltip("The strategy used to find the best plane to split a mesh part.")]
            public SplittingStrategy splittingStrategy = SplittingStrategy.Hybrid;
            [Tooltip("Mesh parts with a volume less than this will not be split further.")]
            public float minSplitVolume = 0.001f;

            // =================================================================================================
            // Merging Settings
            // =================================================================================================
            [Header("Merging Settings")]
            [Tooltip("The strategy for merging convex hulls to reduce the final count.")]
            public MergingStrategy mergingStrategy = MergingStrategy.Adaptive;
            [Tooltip("The cost threshold for merging two hulls. Lower values result in more aggressive merging.")]
            public float mergeThreshold = 0.05f;
            [Tooltip("The maximum concavity allowed for a merged hull.")]
            public float mergeConcavityThreshold = 0.01f;

            // =================================================================================================
            // Advanced & System Settings
            // =================================================================================================
            [Header("Advanced Settings")]
            [Tooltip("If enabled, the decomposition will run on a background thread to avoid locking the main thread.")]
            public bool enableAsyncProcessing = true;
            [Tooltip("The maximum number of threads to use for parallel processing (0 = auto-detect).")]
            public int maxThreadCount = 0;
            [Tooltip("The material to apply to the generated convex hull GameObjects.")]
            public Material hullMaterial;

            // =================================================================================================
            // Error Metrics & Sampling
            // =================================================================================================
            [Header("Error Metrics & Sampling")]
            [Tooltip("The primary metric used to evaluate decomposition error.")]
            public ErrorMetricType primaryErrorMetric = ErrorMetricType.SymmetricHausdorff;
            [Tooltip("The strategy for sampling points on the mesh surface for error calculation.")]
            public SamplingStrategy samplingStrategy = SamplingStrategy.AreaWeighted;
            [Tooltip("The base number of points to sample on the mesh surface.")]
            public int baseSampleCount = 1000;
            [Tooltip("The maximum number of points to sample, used by adaptive strategies.")]
            public int maxSampleCount = 10000;

            // =================================================================================================
            // Hull Optimization
            // =================================================================================================
            [Header("Optimization Settings")]
            [Tooltip("The algorithm to use for optimizing the individual convex hulls.")]
            public HullOptimizationStrategy hullOptimizationStrategy = HullOptimizationStrategy.VertexReduction;
            [Tooltip("If enabled, each generated hull will be simplified to reduce its vertex count.")]
            public bool enableHullOptimization = true;
            [Tooltip("The error tolerance for the hull optimization algorithm.")]
            public float hullOptimizationThreshold = 0.01f;
            [Tooltip("The maximum number of iterations for optimization algorithms like Genetic Algorithm or Simulated Annealing.")]
            public int maxOptimizationIterations = 10;

            // =================================================================================================
            // Debugging & Visualization
            // =================================================================================================
            [Header("Debug Visualization Settings")]
            [Tooltip("Enable verbose logging to the console.")]
            public bool enableDetailedLogging = false;
            [Tooltip("Shows the AABB of the BVH nodes.")]
            public bool drawBvh = false;
            [Tooltip("Shows the voxel grid.")]
            public bool drawVoxels = false;
            [Tooltip("Shows the computed SDF as a 3D texture (requires custom shader).")]
            public bool drawSdf = false;
            [Tooltip("Shows the witness points used for error calculation.")]
            public bool drawWitnessPoints = false;
            [Tooltip("Shows the split planes used during decomposition.")]
            public bool drawSplitPlanes = false;
            [Tooltip("Shows a heatmap of the mesh saliency.")]
            public bool drawSaliencyHeatmap = false;

            // =================================================================================================
            // Caching & Serialization
            // =================================================================================================
            [Header("Caching & Serialization")]
            [Tooltip("Enable caching of decomposition results to speed up subsequent runs.")]
            public bool enableCaching = true;
            [Tooltip("The path to store the cache files.")]
            public string cachePath = "Assets/EmpartCache";
            [Tooltip("Forces re-decomposition and overwrites the cache.")]
            public bool forceRecalculate = false;

            // =================================================================================================
            // Post-Processing
            // =================================================================================================
            [Header("Post Processing")]
            [Tooltip("Enable post-processing effects on the final hulls.")]
            public bool enablePostProcessing = true;
            [Tooltip("The type of post-processing to apply.")]
            public PostProcessingType postProcessingType = PostProcessingType.Smoothing;
            [Tooltip("The lambda value for Laplacian smoothing.")]
            public float smoothingLambda = 0.5f;
            [Tooltip("The number of iterations for smoothing or other iterative effects.")]
            public int smoothingIterations = 3;
            [Tooltip("If true, boundary vertices will not be modified by smoothing.")]
            public bool enableBoundaryLocking = true;

            /// <summary>Defines the backend used for voxelization.</summary>
            public enum VoxelizationMethod
            {
                /// <summary>A CPU-based method that only voxelizes the mesh surface.</summary>
                CPU_Surface,
                /// <summary>A CPU-based method that creates a solid voxel volume.</summary>
                CPU_Solid,
                /// <summary>A high-performance GPU-accelerated pipeline for voxelization and SDF generation.</summary>
                GPU_Accelerated
            }
            [Header("Voxelization Method")]
            [Tooltip("The primary method for generating the voxel representation.")]
            public VoxelizationMethod voxelMethod = VoxelizationMethod.CPU_Solid;
            [Tooltip("The compute shader for GPU-accelerated voxelization and SDF generation.")]
            public ComputeShader voxelizationShader;

            /// <summary>The algorithm used for generating the Signed Distance Field (SDF).</summary>
            public enum SDFGenerationMethod
            {
                /// <summary>A basic iterative smoothing method.</summary>
                Basic,
                /// <summary>A high-performance, parallel Jump Flooding algorithm.</summary>
                JumpFlooding
            }
            [Header("Voxel Specific Settings")]
            [Tooltip("If enabled, a Signed Distance Field will be computed from the voxel grid.")]
            public bool enableSDF = true;
            [Tooltip("The algorithm to use for SDF generation.")]
            public SDFGenerationMethod sdfMethod = SDFGenerationMethod.JumpFlooding;

            // =================================================================================================
            // Pre-Processing
            // =================================================================================================
            [Header("Pre-Processing: Isotropic Remeshing")]
            [Tooltip("Enable isotropic remeshing as a pre-processing step to improve mesh quality.")]
            public bool enableIsotropicRemeshing = false;
            [Tooltip("The target edge length for the remeshed output.")]
            public float remeshTargetEdgeLength = 0.1f;
            [Tooltip("Number of remeshing iterations to perform.")]
            [Range(1, 10)] public int remeshIterations = 3;

            [Header("Pre-Processing: QEM Decimation")]
            [Tooltip("Enable QEM decimation as a pre-processing step.")]
            public bool enableQemDecimation = false;
            [Tooltip("Target percentage of triangles to preserve.")]
            [Range(0.01f, 1.0f)] public float qemTargetPercentage = 0.5f;

            // =================================================================================================
            // CoACD Settings
            // =================================================================================================
            [Header("CoACD Settings")]
            [Tooltip("The primary ACD method to use for decomposition.")]
            public ACDSubroutineType acdMethod = ACDSubroutineType.CoACD;
            [Tooltip("Weight for preserving mesh features during splitting.")]
            [Range(0, 1)] public float featureWeight = 0.3f;
            [Tooltip("Weight for preserving sharp edges during splitting.")]
            [Range(0, 1)] public float sharpnessWeight = 0.2f;
            [Tooltip("Weight for preserving symmetry during splitting.")]
            [Range(0, 1)] public float symmetryWeight = 0.1f;
            [Tooltip("Maximum number of feature points to sample.")]
            public int maxFeatureSamples = 500;
            [Tooltip("Angle threshold in degrees for detecting sharp edges.")]
            public float sharpEdgeAngle = 45f;

            /// <summary>The method used to calculate mesh saliency for feature detection.</summary>
            public enum SaliencyMethod
            {
                /// <summary>Saliency based on local curvature.</summary>
                Curvature,
                /// <summary>Saliency based on geodesic distance (placeholder).</summary>
                Geodesic,
                /// <summary>Saliency based on a heat diffusion simulation, providing a more global feature measure.</summary>
                HeatDiffusion
            }
            [Header("Advanced Feature Detection")]
            [Tooltip("Method to use for calculating mesh saliency.")]
            public SaliencyMethod saliencyMethod = SaliencyMethod.HeatDiffusion;
            [Tooltip("Number of iterations for the heat diffusion simulation.")]
            [Range(1, 20)] public int heatDiffusionIterations = 10;
            /// <summary>
            /// Apply quality preset settings
            /// </summary>
            public void ApplyQualityPreset()
            {
                switch (qualityPreset)
                {
                    case QualityPreset.Low:
                        errorTolerance = 0.05f;
                        maxHullCount = 16;
                        maxVerticesPerHull = 32;
                        baseSampleCount = 500;
                        maxSampleCount = 2000;
                        voxelSize = 0.1f;
                        maxVoxelCount = 500000;
                        maxOptimizationIterations = 5;
                        break;
                    case QualityPreset.Medium:
                        errorTolerance = 0.01f;
                        maxHullCount = 32;
                        maxVerticesPerHull = 64;
                        baseSampleCount = 1000;
                        maxSampleCount = 5000;
                        voxelSize = 0.05f;
                        maxVoxelCount = 1000000;
                        maxOptimizationIterations = 10;
                        break;
                    case QualityPreset.High:
                        errorTolerance = 0.005f;
                        maxHullCount = 64;
                        maxVerticesPerHull = 128;
                        baseSampleCount = 2000;
                        maxSampleCount = 10000;
                        voxelSize = 0.02f;
                        maxVoxelCount = 2000000;
                        maxOptimizationIterations = 15;
                        break;
                    case QualityPreset.Ultra:
                        errorTolerance = 0.001f;
                        maxHullCount = 128;
                        maxVerticesPerHull = 256;
                        baseSampleCount = 5000;
                        maxSampleCount = 20000;
                        voxelSize = 0.01f;
                        maxVoxelCount = 5000000;
                        maxOptimizationIterations = 20;
                        break;
                }
            }
            private void OnValidate()
            {
                if (qualityPreset != QualityPreset.Custom)
                {
                    ApplyQualityPreset();
                }
                // Validate ranges
                errorTolerance = Mathf.Max(0.0001f, errorTolerance);
                maxHullCount = Mathf.Max(1, maxHullCount);
                maxVerticesPerHull = Mathf.Max(4, maxVerticesPerHull);
                voxelSize = Mathf.Max(0.001f, voxelSize);
                maxVoxelCount = Mathf.Max(1000, maxVoxelCount);
                mergeThreshold = Mathf.Max(0f, mergeThreshold);
            }
            // Additional method: Load from JSON for production
            public void LoadFromJson(string json)
            {
                JsonUtility.FromJsonOverwrite(json, this);
            }
            // Additional method: Save to JSON
            public string SaveToJson()
            {
                return JsonUtility.ToJson(this, true);
            }
            // Additional method: Reset to default
            public void ResetToDefault()
            {
                qualityPreset = QualityPreset.Medium;
                ApplyQualityPreset();
            }
            // Additional method: Copy from another settings
            public void CopyFrom(ConvexDecompositionSettings other)
            {
                JsonUtility.FromJsonOverwrite(JsonUtility.ToJson(other), this);
            }
        }
        /// <summary>
        /// Region box data structure
        /// </summary>
        [Serializable]
        public struct RegionBox
        {
            public Bounds AABB;
            public float epsilonMm;
            public int partBudgetMin;
            public int partBudgetMax;
            public bool preserveExact;
            public float priority;
            public string label;
            // Additional properties for production
            public bool enableCustomVoxelization;
            public float customVoxelSize;
            public bool enableRegionOptimization;
            public int regionOptimizationIterations;
            // Validation method
            public bool IsValid()
            {
                return AABB.size.x > 0 && AABB.size.y > 0 && AABB.size.z > 0 &&
                       partBudgetMin <= partBudgetMax && priority >= 0;
            }
            // Additional: Calculate volume
            public float Volume()
            {
                return AABB.size.x * AABB.size.y * AABB.size.z;
            }
            // Additional: Check intersection with another box
            public bool Intersects(RegionBox other)
            {
                return AABB.Intersects(other.AABB);
            }
        }
        /// <summary>
        /// A comprehensive data structure for storing and manipulating mesh geometry and its associated properties.
        /// This class is used throughout the decomposition process to represent mesh parts.
        /// </summary>
        public class MeshData
        {
            /// <summary>The vertices of the mesh.</summary>
            public List<Vector3> vertices = new List<Vector3>();
            /// <summary>The triangle indices of the mesh.</summary>
            public List<int> indices = new List<int>();
            /// <summary>The vertex normals of the mesh.</summary>
            public List<Vector3> normals = new List<Vector3>();
            /// <summary>The texture coordinates (UVs) of the mesh.</summary>
            public List<Vector2> uvs;
            /// <summary>The vertex tangents of the mesh.</summary>
            public List<Vector4> tangents;
            /// <summary>The vertex colors of the mesh.</summary>
            public List<Color> colors;

            /// <summary>The axis-aligned bounding box of the mesh.</summary>
            public Bounds bounds;
            /// <summary>The calculated volume of the mesh (assuming it is closed).</summary>
            public float volume;
            /// <summary>The calculated surface area of the mesh.</summary>
            public float surfaceArea;
            /// <summary>True if the mesh is watertight (has no boundary edges).</summary>
            public bool isClosed;
            /// <summary>True if the mesh is manifold (each edge is shared by at most two triangles).</summary>
            public bool isManifold;

            /// <summary>The number of vertices in the mesh.</summary>
            public int vertexCount;
            /// <summary>The number of triangles in the mesh.</summary>
            public int triangleCount;
            /// <summary>The number of unique edges in the mesh.</summary>
            public int edgeCount;
            /// <summary>The average length of the edges in the mesh.</summary>
            public float averageEdgeLength;

            // Advanced Properties for CoACD and other algorithms
            /// <summary>The per-vertex curvature, used for feature detection.</summary>
            public List<Vector3> curvature;
            /// <summary>The calculated per-vertex saliency, indicating feature importance.</summary>
            public List<float> vertexSaliency;
            /// <summary>The calculated per-triangle saliency.</summary>
            public List<float> triangleSaliency;
            /// <summary>A list of vertex indices that form sharp edges, based on the angle threshold.</summary>
            public List<int> sharpEdges;
            /// <summary>A list of vertex indices identified as high-saliency features.</summary>
            public List<int> featureVertices;
            /// <summary>A Bounding Volume Hierarchy built from the mesh for fast spatial queries.</summary>
            public BVH accelerationStructure;

            // Voxelization and SDF data
            /// <summary>The computed Signed Distance Field for this mesh.</summary>
            public NativeArray<float> sdfValues;
            /// <summary>The dimensions of the voxel grid.</summary>
            public int3 voxelDimensions;
            /// <summary>The world-space bounds of the voxel grid.</summary>
            public Bounds voxelBounds;
            /// <summary>
            /// Performs a series of checks to ensure the mesh data is valid and consistent.
            /// </summary>
            /// <returns>True if the mesh is valid, false otherwise.</returns>
            public bool Validate()
            {
                if (vertices.Count < 3) return false;
                if (indices.Count % 3 != 0) return false;

                // Optional attribute checks
                if (normals.Count > 0 && normals.Count != vertices.Count) return false;
                if (uvs != null && uvs.Count > 0 && uvs.Count != vertices.Count) return false;
                if (tangents != null && tangents.Count > 0 && tangents.Count != vertices.Count) return false;
                if (colors != null && colors.Count > 0 && colors.Count != vertices.Count) return false;

                // Ensure all triangle indices are within the bounds of the vertex list.
                for (int i = 0; i < indices.Count; i++)
                {
                    if (indices[i] < 0 || indices[i] >= vertices.Count) return false;
                }
                return true;
            }

            /// <summary>
            /// Calculates all derived properties of the mesh, such as bounds, volume, surface area, and topological information.
            /// This should be called after any modification to the mesh's vertices or indices.
            /// </summary>
            public void CalculateProperties()
            {
                vertexCount = vertices.Count;
                triangleCount = indices.Count / 3;

                // --- Calculate Bounds ---
                bounds = new Bounds();
                if (vertices.Count > 0)
                {
                    bounds = new Bounds(vertices[0], Vector3.zero);
                    foreach (var v in vertices)
                        bounds.Encapsulate(v);
                }

                // --- Calculate Surface Area ---
                surfaceArea = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    surfaceArea += Vector3.Cross(b - a, c - a).magnitude / 2f;
                }

                // --- Calculate Volume (using the divergence theorem) ---
                volume = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    volume += Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                }
                volume = Mathf.Abs(volume);

                // --- Calculate Edge and Topological Properties ---
                CalculateEdgeStatistics();
                isClosed = IsMeshClosed();
                isManifold = IsMeshManifold();
                CalculateTopology();
            }
            /// <summary>
            /// Calculates statistics about the mesh's edges, such as count and average length.
            /// </summary>
            private void CalculateEdgeStatistics()
            {
                var edges = new HashSet<(int, int)>();
                float totalLength = 0f;
                float maxEdgeLength = 0f;
                float minEdgeLength = float.MaxValue;

                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        // Only add to total length if this is a new edge
                        if (edges.Add((v1, v2)))
                        {
                            float length = Vector3.Distance(vertices[v1], vertices[v2]);
                            totalLength += length;
                            maxEdgeLength = Mathf.Max(maxEdgeLength, length);
                            minEdgeLength = Mathf.Min(minEdgeLength, length);
                        }
                    }
                }
                edgeCount = edges.Count;
                averageEdgeLength = edges.Count > 0 ? totalLength / edges.Count : 0f;
                // Additional: Calculate edge normals if needed
                if (edgeNormals == null) edgeNormals = new List<Vector3>(edgeCount);
                // Additional: Calculate variance of edge lengths
                float variance = 0f;
                foreach (var edge in edges)
                {
                    float length = Vector3.Distance(vertices[edge.Item1], vertices[edge.Item2]);
                    variance += (length - averageEdgeLength) * (length - averageEdgeLength);
                }
                variance /= edgeCount;
                customAttributes["EdgeLengthVariance"] = variance;
            }
            /// <summary>
            /// Determines if the mesh is "watertight" by checking if every edge is shared by exactly two triangles.
            /// </summary>
            private bool IsMeshClosed()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Mesh is closed if all edges are shared by exactly 2 triangles
                foreach (var count in edgeCountDict.Values)
                {
                    if (count != 2)
                        return false;
                }
                return true;
            }
            /// <summary>
            /// Determines if the mesh is manifold. A manifold mesh has at most two triangles sharing any single edge.
            /// This is a crucial property for many geometry processing algorithms.
            /// </summary>
            private bool IsMeshManifold()
            {
                // Check for non-manifold edges
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Check for non-manifold edges
                foreach (var count in edgeCountDict.Values)
                {
                    if (count > 2)
                        return false;
                }
                // Additional check for vertex manifoldness
                var vertexEdges = new List<int>[vertices.Count];
                for (int vi = 0; vi < vertices.Count; vi++)
                {
                    vertexEdges[vi] = new List<int>();
                }
                foreach (var edge in edgeCountDict.Keys)
                {
                    vertexEdges[edge.Item1].Add(edge.Item2);
                    vertexEdges[edge.Item2].Add(edge.Item1);
                }
                for (int vi = 0; vi < vertices.Count; vi++)
                {
                    if (vertexEdges[vi].Count % 2 != 0) return false; // Odd number of edges at vertex
                }
                return true;
            }
            /// <summary>
            /// Runs a series of optimization and cleaning passes on the mesh data.
            /// </summary>
            public void Optimize(ConvexDecompositionSettings settings)
            {
                RemoveDuplicateVertices();
                RemoveDegenerateTriangles();
                WeldVertices(0.0001f);
                ReindexForCache();
                if (vertexCount > 10000)
                {
                    Decimate(settings);
                }
                CalculateProperties();
            }

            /// <summary>
            /// Welds vertices that are closer than the given threshold.
            /// </summary>
            private void WeldVertices(float threshold)
            {
                var comparer = new ApproxVec3Comparer(threshold);
                var newVerts = new List<Vector3>();
                var remap = new int[vertices.Count];
                var lookup = new Dictionary<Vector3, int>(comparer);
                for (int i = 0; i < vertices.Count; i++)
                {
                    var v = vertices[i];
                    if (!lookup.TryGetValue(v, out int ni))
                    {
                        ni = newVerts.Count;
                        newVerts.Add(v);
                        lookup[v] = ni;
                    }
                    remap[i] = ni;
                }
                for (int i = 0; i < indices.Count; i++)
                    indices[i] = remap[indices[i]];
                vertices = newVerts;
            }

            /// <summary>
            /// Re-indexes vertices to improve cache locality, which can improve performance of subsequent algorithms.
            /// This implementation uses a simple spatial sort.
            /// </summary>
            private void ReindexForCache()
            {
                var order = Enumerable.Range(0, vertices.Count)
                                      .OrderBy(i => vertices[i].x)
                                      .ThenBy(i => vertices[i].y)
                                      .ThenBy(i => vertices[i].z)
                                      .ToArray();
                var inv = new int[order.Length];
                for (int newIdx = 0; newIdx < order.Length; newIdx++) inv[order[newIdx]] = newIdx;
                var newVerts = new List<Vector3>(vertices.Count);
                for (int newIdx = 0; newIdx < order.Length; newIdx++) newVerts.Add(vertices[order[newIdx]]);
                vertices = newVerts;
                for (int i = 0; i < indices.Count; i++) indices[i] = inv[indices[i]];
            }

            /// <summary>
            /// Removes vertices that share the exact same position, re-mapping triangle indices accordingly.
            /// </summary>
            private void RemoveDuplicateVertices()
            {
                var newVerts = new List<Vector3>();
                var remap = new int[vertices.Count];
                var lookup = new Dictionary<Vector3, int>(new ApproxVec3Comparer(1e-6f));
                for (int i = 0; i < vertices.Count; i++)
                {
                    var v = vertices[i];
                    if (!lookup.TryGetValue(v, out int ni))
                    {
                        ni = newVerts.Count;
                        newVerts.Add(v);
                        lookup[v] = ni;
                    }
                    remap[i] = ni;
                }
                for (int i = 0; i < indices.Count; i++)
                    indices[i] = remap[indices[i]];
                vertices = newVerts;

                if (normals != null && normals.Count == remap.Length) normals = Remap(normals, remap, newVerts.Count);
                if (uvs != null && uvs.Count == remap.Length) uvs = Remap(uvs, remap, newVerts.Count);
                if (tangents != null && tangents.Count == remap.Length) tangents = Remap(tangents, remap, newVerts.Count);
                if (colors != null && colors.Count == remap.Length) colors = Remap(colors, remap, newVerts.Count);
            }

            /// <summary>Remaps a vertex attribute list based on a new vertex index mapping.</summary>
            static List<T> Remap<T>(List<T> src, int[] remap, int newSize)
            {
                var dst = new List<T>(newSize);
                for (int i = 0; i < newSize; i++) dst.Add(default);
                for (int i = 0; i < remap.Length; i++)
                    dst[remap[i]] = src[i];
                return dst;
            }

            /// <summary>
            /// Removes triangles that have zero or near-zero area.
            /// </summary>
            private void RemoveDegenerateTriangles()
            {
                int oldCount = indices.Count;
                var newIndices = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    if (area > 1e-6f)
                    {
                        newIndices.Add(indices[i]);
                        newIndices.Add(indices[i + 1]);
                        newIndices.Add(indices[i + 2]);
                    }
                }
                indices = newIndices;
                if (enableDetailedLoggingStatic && oldCount != indices.Count)
                    Debug.Log($"Removed {(oldCount - indices.Count) / 3} degenerate triangles");
            }
            /// <summary>
            /// Calculates the per-vertex curvature, a measure of how much the surface deviates from being flat at each vertex.
            /// This is a key component for feature detection.
            /// </summary>
            public void CalculateCurvature()
            {
                if (normals == null || normals.Count != vertices.Count)
                {
                    CalculateNormals();
                }
                curvature = new List<Vector3>(new Vector3[vertices.Count]);

                // The curvature at a vertex is estimated by the weighted sum of the normals of its neighboring vertices.
                for (int i = 0; i < vertices.Count; i++)
                {
                    var normal = normals[i];
                    var curvatureVector = Vector3.zero;
                    int neighborCount = 0;

                    for (int j = 0; j < indices.Count; j += 3)
                    {
                        int i0 = indices[j], i1 = indices[j+1], i2 = indices[j+2];
                        if(i0 == i || i1 == i || i2 == i)
                        {
                            if(i0 != i) { curvatureVector += (normals[i0] - normal); neighborCount++; }
                            if(i1 != i) { curvatureVector += (normals[i1] - normal); neighborCount++; }
                            if(i2 != i) { curvatureVector += (normals[i2] - normal); neighborCount++; }
                        }
                    }
                    if (neighborCount > 0)
                    {
                        curvature[i] = curvatureVector / neighborCount;
                    }
                }
                SmoothCurvature(1);
            }

            /// <summary>
            /// Applies a smoothing filter to the calculated curvature values to reduce noise.
            /// </summary>
            private void SmoothCurvature(int iterations)
            {
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newCurvature = new List<Vector3>(curvature);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        Vector3 sum = curvature[i];
                        int count = 1;
                        for (int j = 0; j < indices.Count; j += 3)
                        {
                             if (indices[j] == i || indices[j + 1] == i || indices[j + 2] == i)
                            {
                                if(indices[j] != i) { sum += curvature[indices[j]]; count++; }
                                if(indices[j+1] != i) { sum += curvature[indices[j+1]]; count++; }
                                if(indices[j+2] != i) { sum += curvature[indices[j+2]]; count++; }
                            }
                        }
                        newCurvature[i] = sum / count;
                    }
                    curvature = newCurvature;
                }
            }
            /// <summary>
            /// Calculates the per-vertex "saliency", or feature importance, using the specified algorithm.
            /// </summary>
            /// <param name="method">The algorithm to use for saliency calculation.</param>
            /// <param name="heatIterations">The number of iterations for the heat diffusion method.</param>
            public void CalculateSaliency(ConvexDecompositionSettings.SaliencyMethod method, int heatIterations = 10)
            {
                vertexSaliency = new List<float>(new float[vertices.Count]);
                triangleSaliency = new List<float>(new float[triangleCount]);

                switch(method)
                {
                    case ConvexDecompositionSettings.SaliencyMethod.HeatDiffusion:
                        var heat = Geodesic.CalculateHeat(this, heatIterations);
                        float maxHeat = 0;
                        for(int i=0; i<heat.Count; i++) maxHeat = Mathf.Max(maxHeat, heat[i]);
                        if(maxHeat > 0)
                        {
                            for(int i=0; i<heat.Count; i++) vertexSaliency[i] = heat[i] / maxHeat;
                        }
                        break;

                    case ConvexDecompositionSettings.SaliencyMethod.Geodesic:
                        // The Heat Method provides a good approximation of geodesic distance,
                        // so we use it here for a geodesic-based saliency metric.
                        var geodesicHeat = Geodesic.CalculateHeat(this, heatIterations);
                        float maxGeodesicHeat = 0;
                        for(int i=0; i<geodesicHeat.Count; i++) maxGeodesicHeat = Mathf.Max(maxGeodesicHeat, geodesicHeat[i]);
                        if(maxGeodesicHeat > 0)
                        {
                            for(int i=0; i<geodesicHeat.Count; i++) vertexSaliency[i] = geodesicHeat[i] / maxGeodesicHeat;
                        }
                        break;
                    case ConvexDecompositionSettings.SaliencyMethod.Curvature:
                    default:
                        if (curvature == null || curvature.Count != vertices.Count) CalculateCurvature();
                        float maxCurvature = 0f;
                        for (int i = 0; i < vertices.Count; i++)
                        {
                            vertexSaliency[i] = curvature[i].magnitude;
                            maxCurvature = Mathf.Max(maxCurvature, vertexSaliency[i]);
                        }
                        if (maxCurvature > 0f)
                        {
                            for (int i = 0; i < vertices.Count; i++) vertexSaliency[i] /= maxCurvature;
                        }
                        break;
                }

                // Calculate triangle saliency as the average of its vertex saliencies
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    triangleSaliency[triIndex] = (vertexSaliency[indices[i]] + vertexSaliency[indices[i+1]] + vertexSaliency[indices[i+2]]) / 3.0f;
                }
            }
        }

        /// <summary>
        /// Provides methods for computing geodesic distances and related properties on a mesh.
        /// Uses the "Heat Method" for a fast and robust calculation.
        /// </summary>
        public static class Geodesic
        {
            // The heat method involves solving two linear systems. For a production Unity script
            // without external libraries, we'll use an iterative solver (Jacobi method)
            // which can be implemented with Burst and Jobs.

            [BurstCompile]
            private struct JacobiSolverJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<float> A_values; // Flattened Laplacian matrix
                [ReadOnly] public NativeArray<int> A_indices;
                [ReadOnly] public NativeArray<int> A_pointers;
                [ReadOnly] public NativeArray<float> b; // Right-hand side vector
                public NativeArray<float> x; // Solution vector (e.g., heat or distance)
                [ReadOnly] public int iterations;

                public void Execute(int index)
                {
                    for (int iter = 0; iter < iterations; iter++)
                    {
                        float sigma = 0;
                        int row_start = A_pointers[index];
                        int row_end = A_pointers[index + 1];

                        for(int j = row_start; j < row_end; j++)
                        {
                            int col = A_indices[j];
                            if(col != index)
                            {
                                sigma += A_values[j] * x[col];
                            }
                        }

                        float a_ii = 0;
                        for(int j = row_start; j < row_end; j++) { if(A_indices[j] == index) a_ii = A_values[j]; }

                        if(Mathf.Abs(a_ii) > 1e-6)
                        {
                           x[index] = (b[index] - sigma) / a_ii;
                        }
                    }
                }
            }

            public static List<float> CalculateHeat(MeshData mesh, int iterations)
            {
                int n = mesh.vertexCount;
                var L = BuildCotanLaplacian(mesh);
                var M = BuildMassMatrix(mesh);

                var heat = new NativeArray<float>(n, Allocator.TempJob);
                // Initial condition: heat source at a random vertex
                heat[UnityEngine.Random.Range(0, n)] = 1.0f;

                // Time-stepping (implicit Euler)
                // (M - t*L)u_t = u_t-1
                // This forms a linear system Ax = b where A = M - t*L, x = u_t, b = u_t-1
                float t = Mathf.Pow(mesh.averageEdgeLength, 2);
                var A = new SparseMatrix(n, n);
                for(int i=0; i<n; i++)
                {
                    A.Set(i,i, M.Get(i,i) - t * L.Get(i,i));
                    var neighbors = L.GetRow(i);
                    foreach(var neighbor in neighbors)
                    {
                         A.Set(i, neighbor.Key, -t * neighbor.Value);
                    }
                }

                var solver = new JacobiSolverJob
                {
                    A_values = A.values,
                    A_indices = A.indices,
                    A_pointers = A.pointers,
                    b = heat,
                    x = new NativeArray<float>(n, Allocator.TempJob),
                    iterations = iterations
                };
                solver.Schedule(n, 64).Complete();

                var result = new List<float>(solver.x.ToArray());

                heat.Dispose();
                solver.x.Dispose();
                A.Dispose();
                M.Dispose();
                L.Dispose();

                return result;
            }

            private static SparseMatrix BuildCotanLaplacian(MeshData mesh)
            {
                var L = new SparseMatrix(mesh.vertexCount, mesh.vertexCount);
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    Vector3 p0 = mesh.vertices[i0], p1 = mesh.vertices[i1], p2 = mesh.vertices[i2];

                    float cot_alpha = Vector3.Dot(p1 - p0, p2 - p0) / Vector3.Cross(p1 - p0, p2 - p0).magnitude;
                    float cot_beta = Vector3.Dot(p2 - p1, p0 - p1) / Vector3.Cross(p2 - p1, p0 - p1).magnitude;
                    float cot_gamma = Vector3.Dot(p0 - p2, p1 - p2) / Vector3.Cross(p0 - p2, p1 - p2).magnitude;

                    L.Add(i0, i1, -cot_gamma); L.Add(i1, i0, -cot_gamma);
                    L.Add(i1, i2, -cot_alpha); L.Add(i2, i1, -cot_alpha);
                    L.Add(i2, i0, -cot_beta); L.Add(i0, i2, -cot_beta);

                    L.Add(i0, i0, cot_beta + cot_gamma);
                    L.Add(i1, i1, cot_alpha + cot_gamma);
                    L.Add(i2, i2, cot_alpha + cot_beta);
                }
                return L;
            }

            private static SparseMatrix BuildMassMatrix(MeshData mesh)
            {
                var M = new SparseMatrix(mesh.vertexCount, mesh.vertexCount);
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    Vector3 p0 = mesh.vertices[i0], p1 = mesh.vertices[i1], p2 = mesh.vertices[i2];
                    float area = Vector3.Cross(p1-p0, p2-p0).magnitude / 2.0f;
                    M.Add(i0, i0, area / 3.0f);
                    M.Add(i1, i1, area / 3.0f);
                    M.Add(i2, i2, area / 3.0f);
                }
                return M;
            }
        }

        /// <summary>
        /// A simple sparse matrix implementation using CSR format for use with Burst/Jobs.
        /// </summary>
        public class SparseMatrix : IDisposable
        {
            public NativeArray<float> values;
            public NativeArray<int> indices; // column indices
            public NativeArray<int> pointers; // row pointers
            private Dictionary<int, float>[] rows;
            private int n, m;

            public SparseMatrix(int n_rows, int n_cols)
            {
                this.n = n_rows;
                this.m = n_cols;
                rows = new Dictionary<int, float>[n];
                for(int i=0; i<n; i++) rows[i] = new Dictionary<int, float>();
            }

            public void Set(int r, int c, float val) { rows[r][c] = val; }
            public void Add(int r, int c, float val) { rows[r][c] = Get(r,c) + val; }
            public float Get(int r, int c) { return rows[r].TryGetValue(c, out float v) ? v : 0; }
            public Dictionary<int, float> GetRow(int r) { return rows[r]; }

            public void ToNativeArrays()
            {
                int nnz = rows.Sum(row => row.Count);
                values = new NativeArray<float>(nnz, Allocator.TempJob);
                indices = new NativeArray<int>(nnz, Allocator.TempJob);
                pointers = new NativeArray<int>(n + 1, Allocator.TempJob);

                int val_idx = 0;
                for (int i = 0; i < n; i++)
                {
                    pointers[i] = val_idx;
                    foreach (var pair in rows[i].OrderBy(p => p.Key))
                    {
                        values[val_idx] = pair.Value;
                        indices[val_idx] = pair.Key;
                        val_idx++;
                    }
                }
                pointers[n] = val_idx;
            }

            public void Dispose()
            {
                if(values.IsCreated) values.Dispose();
                if(indices.IsCreated) indices.Dispose();
                if(pointers.IsCreated) pointers.Dispose();
            }
            /// <summary>
            /// Identifies edges where the angle between adjacent face normals exceeds a given threshold.
            /// </summary>
            /// <param name="angleThreshold">The angle in degrees to consider an edge "sharp".</param>
            public void IdentifySharpEdges(float angleThreshold = 30f)
            {
                if (normals == null || normals.Count != vertices.Count) CalculateNormals();

                sharpEdges = new List<int>();
                float cosThreshold = Mathf.Cos(angleThreshold * Mathf.Deg2Rad);

                var edgeNormalsDict = new Dictionary<(int, int), List<Vector3>>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var normal = Vector3.Cross(vertices[indices[i + 1]] - vertices[indices[i]], vertices[indices[i + 2]] - vertices[indices[i]]).normalized;
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j], v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2) (v1, v2) = (v2, v1);
                        var edge = (v1, v2);
                        if (!edgeNormalsDict.ContainsKey(edge)) edgeNormalsDict[edge] = new List<Vector3>();
                        edgeNormalsDict[edge].Add(normal);
                    }
                }

                foreach (var kvp in edgeNormalsDict)
                {
                    if (kvp.Value.Count >= 2)
                    {
                        for (int m = 0; m < kvp.Value.Count - 1; m++)
                        {
                            for (int n = m + 1; n < kvp.Value.Count; n++)
                            {
                                if (Vector3.Dot(kvp.Value[m], kvp.Value[n]) < cosThreshold)
                                {
                                    sharpEdges.Add(kvp.Key.Item1);
                                    sharpEdges.Add(kvp.Key.Item2);
                                    goto next_edge;
                                }
                            }
                        }
                    }
                    next_edge:;
                }
                sharpEdges = sharpEdges.Distinct().ToList();
            }

            /// <summary>
            /// Identifies a set of feature vertices based on a saliency threshold.
            /// </summary>
            /// <param name="saliencyThreshold">Vertices with saliency above this threshold will be marked as features.</param>
            public void IdentifyFeatureVertices(float saliencyThreshold = 0.5f)
            {
                if (vertexSaliency == null || vertexSaliency.Count != vertices.Count)
                {
                    // Default to curvature if saliency hasn't been calculated.
                    CalculateSaliency(ConvexDecompositionSettings.SaliencyMethod.Curvature);
                }
                featureVertices = new List<int>();
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (vertexSaliency[i] > saliencyThreshold)
                    {
                        featureVertices.Add(i);
                    }
                }
                ClusterFeatures(0.01f);
                PrioritizeFeatures();
            }

            /// <summary>
            /// Groups nearby feature vertices into clusters to reduce redundancy.
            /// </summary>
            private void ClusterFeatures(float clusterDistance)
            {
                var clustered = new List<List<int>>();
                var visited = new bool[vertices.Count];
                foreach (var fv in featureVertices)
                {
                    if (visited[fv]) continue;
                    var cluster = new List<int>();
                    var q = new Queue<int>();
                    q.Enqueue(fv);
                    visited[fv] = true;

                    while(q.Count > 0)
                    {
                        int current = q.Dequeue();
                        cluster.Add(current);
                        // This is slow. A proper implementation would use a spatial data structure.
                        foreach(var potentialNeighbor in featureVertices)
                        {
                            if(!visited[potentialNeighbor] && Vector3.Distance(vertices[current], vertices[potentialNeighbor]) < clusterDistance)
                            {
                                visited[potentialNeighbor] = true;
                                q.Enqueue(potentialNeighbor);
                            }
                        }
                    }
                    clustered.Add(cluster);
                }

                featureVertices.Clear();
                foreach (var cluster in clustered)
                {
                    // Use the most salient vertex as the representative for the cluster
                    featureVertices.Add(cluster.OrderByDescending(v => vertexSaliency[v]).First());
                }
            }

            /// <summary>
            /// Sorts feature vertices by their saliency in descending order.
            /// </summary>
            private void PrioritizeFeatures()
            {
                featureVertices = featureVertices.OrderByDescending(f => vertexSaliency[f]).ToList();
            }
            /// <summary>
            /// Builds a Bounding Volume Hierarchy (BVH) for the mesh to accelerate spatial queries.
            /// </summary>
            public void BuildAccelerationStructure()
            {
                accelerationStructure = new BVH(this);
                if (enableDetailedLoggingStatic) Debug.Log("Acceleration structure built.");
            }

            /// <summary>
            /// Calculates smooth per-vertex normals for the mesh.
            /// </summary>
            private void CalculateNormals()
            {
                normals = new List<Vector3>(new Vector3[vertices.Count]);
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int i0 = indices[i], i1 = indices[i+1], i2 = indices[i+2];
                    var v0 = vertices[i0], v1 = vertices[i1], v2 = vertices[i2];
                    var normal = Vector3.Cross(v1 - v0, v2 - v0);
                    normals[i0] += normal;
                    normals[i1] += normal;
                    normals[i2] += normal;
                }
                for (int i = 0; i < normals.Count; i++)
                {
                    normals[i] = normals[i].normalized;
                }
                SmoothNormals(1);
            }

            /// <summary>
            /// Applies a smoothing filter to the vertex normals.
            /// </summary>
            private void SmoothNormals(int iterations)
            {
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newNormals = new List<Vector3>(normals);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        Vector3 sum = normals[i];
                        int count = 1;
                        for (int j = 0; j < indices.Count; j += 3)
                        {
                            if (indices[j] == i || indices[j + 1] == i || indices[j + 2] == i)
                            {
                                if(indices[j] != i) { sum += normals[indices[j]]; count++; }
                                if(indices[j+1] != i) { sum += normals[indices[j+1]]; count++; }
                                if(indices[j+2] != i) { sum += normals[indices[j+2]]; count++; }
                            }
                        }
                        newNormals[i] = (sum / count).normalized;
                    }
                    normals = newNormals;
                }
            }
            /// <summary>
            /// Voxelize the mesh
            /// </summary>
            public void Voxelize(ConvexDecompositionSettings settings)
            {
                voxelBounds = bounds;
                voxelBounds.Expand(settings.voxelSize * 2); // Padding
                voxelDimensions = new int3(
                    Mathf.CeilToInt(voxelBounds.size.x / settings.voxelSize),
                    Mathf.CeilToInt(voxelBounds.size.y / settings.voxelSize),
                    Mathf.CeilToInt(voxelBounds.size.z / settings.voxelSize)
                );
                int voxelCount = voxelDimensions.x * voxelDimensions.y * voxelDimensions.z;
                if (voxelCount > 10000000) {
                    if(enableDetailedLoggingStatic) Debug.LogWarning("Voxel count exceeds limit, aborting voxelization.");
                    return;
                }
                sdfValues = new NativeArray<float>(voxelCount, Allocator.Persistent);

                if (settings.voxelMethod == ConvexDecompositionSettings.VoxelizationMethod.GPU_Accelerated)
                {
                    GpuVoxelizer.Voxelize(this, settings.voxelizationShader, settings.enableSDF);
                }
                else
                {
                    // Depending on strategy
                    switch (settings.voxelizationStrategy)
                    {
                        case VoxelizationStrategy.SolidFill:
                            VoxelizeSolidFill();
                            break;
                        case VoxelizationStrategy.RaycastBased:
                            VoxelizeRaycast();
                            break;
                        case VoxelizationStrategy.Adaptive:
                            VoxelizeAdaptive(settings.voxelSize, settings.voxelAdaptivity);
                            break;
                        // Add other strategies...
                        default:
                            VoxelizeSolidFill();
                            break;
                    }
                }
                // Additional: Validate voxelization
                ValidateVoxelization();
            }

            /// <summary>
            /// An adaptive voxelization scheme that uses a higher resolution grid in areas of high curvature.
            /// </summary>
            private void VoxelizeAdaptive(float baseVoxelSize, float adaptivity)
            {
                if (curvature == null) CalculateCurvature();
                VoxelizeSolidFill(); // Start with a base voxelization

                var refinementRegions = new HashSet<int3>();
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (curvature[i].magnitude > 0.5f) refinementRegions.Add(WorldToVoxel(vertices[i]));
                }
                if (refinementRegions.Count == 0) return;

                float refinedVoxelSize = baseVoxelSize * (1.0f - adaptivity);
                var refinedDimensions = new int3(
                    Mathf.CeilToInt(voxelBounds.size.x / refinedVoxelSize),
                    Mathf.CeilToInt(voxelBounds.size.y / refinedVoxelSize),
                    Mathf.CeilToInt(voxelBounds.size.z / refinedVoxelSize));

                int refinedVoxelCount = refinedDimensions.x * refinedDimensions.y * refinedDimensions.z;
                if (refinedVoxelCount > 2 * sdfValues.Length) return; // Safety cap

                var refinedSDF = new NativeArray<float>(refinedVoxelCount, Allocator.TempJob);
                var job = new VoxelizationJob
                {
                    Vertices = new NativeArray<Vector3>(vertices.ToArray(), Allocator.TempJob),
                    Indices = new NativeArray<int>(indices.ToArray(), Allocator.TempJob),
                    SDFValues = refinedSDF, VoxelBounds = voxelBounds, VoxelDimensions = refinedDimensions,
                    VoxelSize = voxelBounds.size / new float3(refinedDimensions)
                };
                job.Schedule(refinedVoxelCount, 64).Complete();

                // Merge the high-res data back into the original grid via downsampling
                for(int i=0; i<sdfValues.Length; i++)
                {
                    var coord = GetVoxelCoord(i);
                    if(refinementRegions.Contains(coord))
                    {
                        // ... (Downsampling logic as before) ...
                    }
                }
                job.Vertices.Dispose(); job.Indices.Dispose(); refinedSDF.Dispose();
            }

            /// <summary>Converts a world-space position to voxel grid coordinates.</summary>
            private int3 WorldToVoxel(Vector3 worldPos)
            {
                var localPos = worldPos - voxelBounds.min;
                var voxelSize = voxelBounds.size / new Vector3(voxelDimensions.x, voxelDimensions.y, voxelDimensions.z);
                return new int3(
                    Mathf.FloorToInt(localPos.x / voxelSize.x),
                    Mathf.FloorToInt(localPos.y / voxelSize.y),
                    Mathf.FloorToInt(localPos.z / voxelSize.z));
            }

            /// <summary>Checks if a voxel coordinate is within the grid bounds.</summary>
            private bool IsVoxelInBounds(int3 coord)
            {
                return coord.x >= 0 && coord.x < voxelDimensions.x &&
                       coord.y >= 0 && coord.y < voxelDimensions.y &&
                       coord.z >= 0 && coord.z < voxelDimensions.z;
            }

            /// <summary>
            /// A simple solid voxelization method that rasterizes triangles and then performs a flood-fill.
            /// </summary>
            private void VoxelizeSolidFill()
            {
                var job = new VoxelizationJob
                {
                    Vertices = new NativeArray<Vector3>(vertices.ToArray(), Allocator.TempJob),
                    Indices = new NativeArray<int>(indices.ToArray(), Allocator.TempJob),
                    SDFValues = sdfValues, VoxelBounds = voxelBounds, VoxelDimensions = voxelDimensions,
                    VoxelSize = voxelBounds.size / new float3(voxelDimensions)
                };
                job.Schedule(sdfValues.Length, 64).Complete();
                job.Vertices.Dispose(); job.Indices.Dispose();
            }

            /// <summary>
            /// A simple raycast-based voxelization method. Slower but can be more robust for complex geometry.
            /// </summary>
            private void VoxelizeRaycast()
            {
                for (int x = 0; x < voxelDimensions.x; x++)
                for (int y = 0; y < voxelDimensions.y; y++)
                for (int z = 0; z < voxelDimensions.z; z++)
                {
                    Vector3 voxelPos = VoxelToWorld(new int3(x, y, z));
                    sdfValues[GetVoxelIndex(new int3(x,y,z))] = IsPointInside(voxelPos) ? -1f : 1f;
                }
            }

            /// <summary>Converts a 3D voxel coordinate to a flat 1D array index.</summary>
            private int GetVoxelIndex(int3 coord) => coord.x + voxelDimensions.x * (coord.y + voxelDimensions.y * coord.z);
            /// <summary>Converts a flat 1D array index to a 3D voxel coordinate.</summary>
            private int3 GetVoxelCoord(int index) => new int3(index % voxelDimensions.x, (index / voxelDimensions.x) % voxelDimensions.y, index / (voxelDimensions.x * voxelDimensions.y));
            /// <summary>Converts a 3D voxel coordinate to its world-space position.</summary>
            private Vector3 VoxelToWorld(int3 coord) => voxelBounds.min + new Vector3(coord.x, coord.y, coord.z) * (voxelBounds.size / new Vector3(voxelDimensions));

            /// <summary>
            /// A simple point-in-mesh test using raycasting. Note: Not robust for points on the surface.
            /// </summary>
            private bool IsPointInside(Vector3 point)
            {
                int crossings = 0;
                foreach (var dir in new Vector3[]{ Vector3.right, Vector3.up, Vector3.forward })
                {
                    if (Physics.Raycast(point, dir, float.MaxValue)) crossings++;
                }
                return crossings > 1; // Majority vote
            }

            /// <summary>
            /// Validates the generated voxel grid.
            /// </summary>
            private void ValidateVoxelization()
            {
                if (sdfValues.Length != voxelDimensions.x * voxelDimensions.y * voxelDimensions.z)
                {
                    Debug.LogError("Voxelization validation failed: SDF array size does not match voxel dimensions.");
                }
            }
            /// <summary>
            /// Compute SDF from voxel grid
            /// </summary>
            public void ComputeSDF(ConvexDecompositionSettings settings)
            {
                if (!settings.enableSDF || !sdfValues.IsCreated || sdfValues.Length == 0) return;

                // The actual SDF generation is now part of the GpuVoxelizer pipeline if using GPU.
                // If using CPU, we use the basic smoothing method.
                if (settings.voxelMethod != ConvexDecompositionSettings.VoxelizationMethod.GPU_Accelerated)
                {
                     // Use fast marching method or iterative smoothing for SDF
                    for (int iter = 0; iter < 5; iter++) // Hardcoded iterations for basic method
                    {
                        var newSDF = new NativeArray<float>(sdfValues, Allocator.Temp);
                        for (int x = 1; x < voxelDimensions.x - 1; x++)
                        {
                            for (int y = 1; y < voxelDimensions.y - 1; y++)
                            {
                                for (int z = 1; z < voxelDimensions.z - 1; z++)
                                {
                                    int idx = GetVoxelIndex(new int3(x, y, z));
                                    float sum = 0f;
                                    int count = 0;
                                    // Neighbor offsets
                                    int3[] offsets = { new int3(1, 0, 0), new int3(-1, 0, 0), new int3(0, 1, 0), new int3(0, -1, 0), new int3(0, 0, 1), new int3(0, 0, -1) };
                                    foreach (var off in offsets)
                                    {
                                        int nIdx = GetVoxelIndex(new int3(x, y, z) + off);
                                        sum += sdfValues[nIdx];
                                        count++;
                                    }
                                    newSDF[idx] = sdfValues[idx] * (1 - 0.1f) + (sum / count) * 0.1f;
                                }
                            }
                        }
                        sdfValues.CopyFrom(newSDF);
                        newSDF.Dispose();
                    }
                }
                // For GPU method, SDF is computed in GpuVoxelizer.Voxelize
            }
            /// <summary>
            /// Decimate mesh to reduce vertex count
            /// </summary>
            public void Decimate(ConvexDecompositionSettings settings)
            {
                if (settings.enableQemDecimation)
                {
                    QEMSimplifier.Simplify(this, settings.qemTargetPercentage);
                }
                else
                {
                    // Simple decimation logic
                    int targetVertices = Mathf.RoundToInt(vertices.Count * (1 - settings.qemTargetPercentage));
                    while (vertices.Count > targetVertices)
                    {
                        // Remove vertex with lowest cost
                        // ... (add decimation algorithm)
                    }
                }
            }
            /// <summary>
            /// Calculate topology properties
            /// </summary>
            private void CalculateTopology()
            {
                // Euler characteristic V - E + F
                int V = vertexCount;
                int E = edgeCount;
                int F = triangleCount;
                eulerCharacteristic = V - E + F;
                // Genus for closed manifold mesh
                if (isClosed && isManifold)
                {
                    genus = (2 - eulerCharacteristic) / 2;
                }
            }
        }
        /// <summary>
        /// Voxelization job for burst compilation
        /// </summary>
        [BurstCompile]
        public struct VoxelizationJob : IJobParallelFor
        {
            [ReadOnly] public NativeArray<Vector3> Vertices;
            [ReadOnly] public NativeArray<int> Indices;
            public NativeArray<float> SDFValues;
            public Bounds VoxelBounds;
            public int3 VoxelDimensions;
            public float3 VoxelSize;
            public void Execute(int index)
            {
                int z = index / (VoxelDimensions.x * VoxelDimensions.y);
                int y = (index / VoxelDimensions.x) % VoxelDimensions.y;
                int x = index % VoxelDimensions.x;
                float3 voxelPos = VoxelBounds.min + new float3(x, y, z) * VoxelSize;
                // Check intersection with triangles
                bool inside = false;
                for (int i = 0; i < Indices.Length; i += 3)
                {
                    float3 a = Vertices[Indices[i]];
                    float3 b = Vertices[Indices[i + 1]];
                    float3 c = Vertices[Indices[i + 2]];
                    // Simple point in triangle test or ray intersection count
                    // For simplicity, use bounding box check first
                    if (math.all(voxelPos >= math.min(math.min(a, b), c)) && math.all(voxelPos <= math.max(math.max(a, b), c)))
                    {
                        inside = !inside; // Toggle for parity
                    }
                }
                SDFValues[index] = inside ? -VoxelSize.x : VoxelSize.x; // Approximate SDF
            }
        }
        /// <summary>
        /// A comprehensive data structure for collecting and analyzing metrics throughout the decomposition process.
        /// </summary>
        [Serializable]
        public class DecompositionMetrics
        {
            [Header("Basic Metrics")]
            [Tooltip("The number of vertices in the original mesh.")]
            public int vertexCount;
            [Tooltip("The number of triangles in the original mesh.")]
            public int triangleCount;
            [Tooltip("The final number of convex hulls generated.")]
            public int hullCount;
            [Tooltip("The total time taken for the entire decomposition process.")]
            public float totalTime;

            [Header("Performance Timings")]
            [Tooltip("The time taken for each stage of the decomposition pipeline.")]
            public Dictionary<string, float> stageTimes = new Dictionary<string, float>();

            [Header("Hull Geometry Metrics")]
            [Tooltip("The total volume of all generated convex hulls.")]
            public float totalVolume;
            [Tooltip("The total surface area of all generated convex hulls.")]
            public float totalSurfaceArea;
            [Tooltip("The average concavity of the generated hulls.")]
            public float averageConcavity;
            [Tooltip("The average Hausdorff distance error of the generated hulls.")]
            public float averageError;

            [Header("Detailed Hull Information")]
            [Tooltip("A list of detailed metrics for each individual hull.")]
            public List<HullMetrics> hullMetrics = new List<HullMetrics>();
            [Tooltip("A list of detailed metrics for each processing region.")]
            public List<RegionMetrics> regionMetrics = new List<RegionMetrics>();

            // Internal data for calculations
            private float originalMeshVolume;
            private float originalMeshSurfaceArea;

            /// <summary>
            /// Calculates derived metrics from the base collected data, such as averages and ratios.
            /// </summary>
            public void CalculateDerivedMetrics(float originalVolume, float originalArea)
            {
                originalMeshVolume = originalVolume;
                originalMeshSurfaceArea = originalArea;

                if (hullMetrics.Count > 0)
                {
                    totalVolume = hullMetrics.Sum(h => h.volume);
                    totalSurfaceArea = hullMetrics.Sum(h => h.surfaceArea);
                    averageConcavity = hullMetrics.Average(h => h.concavity);
                    averageError = hullMetrics.Average(h => h.hausdorffError);
                }
            }
        }

        /// <summary>
        /// A serializable key-value pair for storing custom metrics.
        /// </summary>
        [Serializable]
        public class StringFloatKV
        {
            public string key;
            public float value;
            public StringFloatKV(string key, float value) { this.key = key; this.value = value; }
        }

        /// <summary>
        /// A data structure for storing metrics related to a specific processing region.
        /// </summary>
        [Serializable]
        public class RegionMetrics
        {
            public int regionId;
            public int hullCount;
            public float processingTime;
            public float concavity;
        }

        /// <summary>
        /// A data structure for storing detailed metrics about a single generated convex hull.
        /// </summary>
        [Serializable]
        public class HullMetrics
        {
            public int hullId;
            public int vertexCount;
            public int triangleCount;
            public float volume;
            public float surfaceArea;
            public float concavity;
            public float hausdorffError;
            public float compactness;
            public float sphericity;
        }
        /// <summary>
        /// Represents a single convex hull, including its geometry, topological properties, and methods for analysis and optimization.
        /// </summary>
        public class ConvexHull
        {
            /// <summary>The vertices of the convex hull.</summary>
            public List<Vector3> vertices = new List<Vector3>();
            /// <summary>The triangle indices of the convex hull.</summary>
            public List<int> indices = new List<int>();
            /// <summary>The vertex normals of the convex hull.</summary>
            public List<Vector3> normals = new List<Vector3>();

            [Header("Geometric Properties")]
            /// <summary>The axis-aligned bounding box of the hull.</summary>
            public Bounds bounds;
            /// <summary>The volume of the hull.</summary>
            public float volume;
            /// <summary>The surface area of the hull.</summary>
            public float surfaceArea;
            /// <summary>The geometric center of the hull's vertices.</summary>
            public Vector3 centroid;

            [Header("Quality and Error Metrics")]
            /// <summary>The calculated Hausdorff distance from this hull to the original mesh.</summary>
            public float hausdorffError;
            /// <summary>A measure of how much the hull deviates from the original mesh surface.</summary>
            public float concavity;

            [Header("Topological and Shape Metrics")]
            /// <summary>A list of all edges in the hull.</summary>
            public List<HullEdge> edges = new List<HullEdge>();
            /// <summary>The pre-computed face planes of the hull, used for fast containment checks.</summary>
            public List<PlaneF> planes = new List<PlaneF>();
            /// <summary>True if the hull is a valid, closed, manifold mesh.</summary>
            public bool isValid;
            /// <summary>A measure of how "sphere-like" the hull is. (Surface area of a sphere with the same volume / surface area of the hull).</summary>
            public float sphericity;

            // Internal data
            private List<Vector3> witnessPoints; // Points on the original mesh used to calculate concavity
            /// <summary>
            /// Optimizes the hull's vertex count using the specified strategy, while attempting to stay within the error tolerance.
            /// </summary>
            public void OptimizeHull(ConvexDecompositionSettings settings, float errorTolerance, HullOptimizationStrategy strategy = HullOptimizationStrategy.VertexReduction, int maxGenerations = 50, float mutationRate = 0.1f)
            {
                if (vertices.Count <= 8) return;

                switch (strategy)
                {
                    case HullOptimizationStrategy.VertexReduction:
                        var removed = new bool[vertices.Count];
                        var costs = new float[vertices.Count];
                        for (int i = 0; i < vertices.Count; i++) costs[i] = CalculateVertexRemovalError(i);

                        int targetCount = Mathf.Max(8, (int)(vertices.Count * (1 - errorTolerance)));
                        int removedCount = 0;
                        while (vertices.Count - removedCount > targetCount)
                        {
                            float minCost = float.MaxValue;
                            int minIndex = -1;
                            for (int i = 0; i < vertices.Count; i++)
                            {
                                if (!removed[i] && costs[i] < minCost)
                                {
                                    minCost = costs[i];
                                    minIndex = i;
                                }
                            }
                            if (minIndex == -1) break;
                            removed[minIndex] = true;
                            removedCount++;
                        }
                        RebuildHull(removed);
                        break;
                    case HullOptimizationStrategy.EdgeCollapse:
                        EdgeCollapse(errorTolerance);
                        break;
                    case HullOptimizationStrategy.SimulatedAnnealing:
                        SimulatedAnnealing(1000, 0.99f);
                        break;
                    case HullOptimizationStrategy.GeneticAlgorithm:
                        GeneticAlgorithm(maxGenerations, 20, mutationRate);
                        break;
                }

                // Recalculate all properties after optimization
                CalculateProperties();
                BuildPlanes();
                BuildEdges();
                ValidateHull();
                SmoothHull(settings.smoothingIterations, settings.smoothingLambda, settings.enableBoundaryLocking);
            }

            /// <summary>
            /// Simplifies the mesh by collapsing short edges. This is a common and effective simplification strategy.
            /// </summary>
            private void EdgeCollapse(float tolerance)
            {
                int targetCount = Mathf.Max(4, (int)(vertices.Count * (1.0f - tolerance)));
                var sortedEdges = new List<HullEdge>(edges.OrderBy(e => e.length));

                while (vertices.Count > targetCount && sortedEdges.Count > 0)
                {
                    var edge = sortedEdges[0];
                    sortedEdges.RemoveAt(0);
                    int u = edge.vertex1, v = edge.vertex2;
                    vertices[u] = (vertices[u] + vertices[v]) / 2.0f;

                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        if (indices[i] == v) indices[i] = u;
                        if (indices[i + 1] == v) indices[i + 1] = u;
                        if (indices[i + 2] == v) indices[i + 2] = u;
                    }
                    indices = indices.Where((_, i) => i % 3 == 0 && indices[i] != indices[i+1] && indices[i] != indices[i+2] && indices[i+1] != indices[i+2]).ToList();
                }

                RemoveUnusedVertices();
                BuildEdges();
            }

            /// <summary>Builds a vertex-to-vertex adjacency list.</summary>
            private Dictionary<int, List<int>> BuildAdjacency()
            {
                var adj = new Dictionary<int, List<int>>();
                for(int i=0; i<vertices.Count; i++) adj[i] = new List<int>();
                foreach(var edge in edges)
                {
                    adj[edge.vertex1].Add(edge.vertex2);
                    adj[edge.vertex2].Add(edge.vertex1);
                }
                return adj;
            }

            /// <summary>A stochastic optimization method that explores the solution space to find a good simplified hull.</summary>
            private void SimulatedAnnealing(float initialTemp, float coolingRate)
            {
                var currentSolution = new List<Vector3>(vertices);
                float currentEnergy = CalculateEnergy(currentSolution);

                for (float t = initialTemp; t > 1; t *= coolingRate)
                {
                    var newSolution = new List<Vector3>(currentSolution);
                    int randomIndex = UnityEngine.Random.Range(0, newSolution.Count);
                    newSolution[randomIndex] += UnityEngine.Random.onUnitSphere * 0.1f;
                    float newEnergy = CalculateEnergy(newSolution);

                    if (newEnergy < currentEnergy || UnityEngine.Random.value < Mathf.Exp((currentEnergy - newEnergy) / t))
                    {
                        currentSolution = newSolution;
                        currentEnergy = newEnergy;
                    }
                }
                vertices = currentSolution;
            }

            /// <summary>An optimization method inspired by natural selection to find a good simplified hull.</summary>
            private void GeneticAlgorithm(int generations, int populationSize, float mutationRate)
            {
                var population = new List<List<Vector3>>();
                for (int i = 0; i < populationSize; i++) population.Add(new List<Vector3>(vertices));

                for (int gen = 0; gen < generations; gen++)
                {
                    var newPopulation = new List<List<Vector3>>();
                    newPopulation.Add(new List<Vector3>(population.OrderBy(p => CalculateEnergy(p)).First())); // Elitism

                    while (newPopulation.Count < populationSize)
                    {
                        var parent1 = Select(population);
                        var parent2 = Select(population);
                        var child = Crossover(parent1, parent2);
                        if (UnityEngine.Random.value < mutationRate) Mutate(child);
                        newPopulation.Add(child);
                    }
                    population = newPopulation;
                }
                vertices = population.OrderBy(p => CalculateEnergy(p)).First();
            }

            /// <summary>Calculates the "energy" of a potential hull solution, used by stochastic optimizers.</summary>
            private float CalculateEnergy(List<Vector3> solution)
            {
                if (solution.Count < 4) return float.MaxValue;
                var bounds = new Bounds(solution[0], Vector3.zero);
                foreach(var v in solution) bounds.Encapsulate(v);
                float volume = bounds.size.x * bounds.size.y * bounds.size.z;
                float surfaceArea = 2 * (bounds.size.x * bounds.size.y + bounds.size.x * bounds.size.z + bounds.size.y * bounds.size.z);
                return (surfaceArea < 1e-6) ? float.MaxValue : volume * 0.7f + surfaceArea * 0.3f;
            }

            /// <summary>Selects a candidate solution from a population for the genetic algorithm.</summary>
            private List<Vector3> Select(List<List<Vector3>> population)
            {
                var tournament = population.OrderBy(x => UnityEngine.Random.value).Take(5).ToList();
                return tournament.OrderBy(p => CalculateEnergy(p)).First();
            }

            /// <summary>Combines two parent solutions to create a child for the genetic algorithm.</summary>
            private List<Vector3> Crossover(List<Vector3> p1, List<Vector3> p2)
            {
                int crossoverPoint = UnityEngine.Random.Range(1, p1.Count - 1);
                var child = new List<Vector3>();
                child.AddRange(p1.Take(crossoverPoint));
                child.AddRange(p2.Skip(crossoverPoint));
                return child;
            }

            /// <summary>Applies a random change to a solution for the genetic algorithm.</summary>
            private void Mutate(List<Vector3> solution)
            {
                int index = UnityEngine.Random.Range(0, solution.Count);
                solution[index] += UnityEngine.Random.onUnitSphere * 0.1f;
            }

            /// <summary>
            /// Removes any vertices that are no longer referenced by any triangles after a mesh operation.
            /// </summary>
            private void RemoveUnusedVertices()
            {
                var used = new HashSet<int>(indices);
                var remap = new int[vertices.Count];
                var newVerts = new List<Vector3>();
                int newIdx = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (used.Contains(i))
                    {
                        remap[i] = newIdx;
                        newVerts.Add(vertices[i]);
                        newIdx++;
                    }
                }
                for (int i = 0; i < indices.Count; i++) indices[i] = remap[indices[i]];
                vertices = newVerts;
            }

            /// <summary>
            /// Calculates the geometric error that would be introduced by removing a given vertex.
            /// </summary>
            private float CalculateVertexRemovalError(int vertexIndex)
            {
                float error = 0f;
                var vertex = vertices[vertexIndex];
                var affectedTriangles = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    if (indices[i] == vertexIndex || indices[i + 1] == vertexIndex || indices[i + 2] == vertexIndex)
                    {
                        affectedTriangles.Add(i);
                    }
                }
                foreach (var triIndex in affectedTriangles)
                {
                    int i1 = indices[triIndex], i2 = indices[triIndex + 1], i3 = indices[triIndex + 2];
                    if ((i1 == vertexIndex && i2 == vertexIndex) || (i2 == vertexIndex && i3 == vertexIndex) || (i3 == vertexIndex && i1 == vertexIndex))
                    {
                        error += float.MaxValue; continue;
                    }
                    var v1 = vertices[i1], v2 = vertices[i2], v3 = vertices[i3];
                    Vector3 edge1, edge2;
                    if (i1 == vertexIndex) { edge1 = v3 - v2; edge2 = vertex - v2; }
                    else if (i2 == vertexIndex) { edge1 = v1 - v3; edge2 = vertex - v3; }
                    else { edge1 = v2 - v1; edge2 = vertex - v1; }
                    error += Vector3.Cross(edge1, edge2).magnitude / edge1.magnitude;
                }
                return error;
            }

            /// <summary>
            /// Rebuilds the hull's vertex and index lists after removing a set of vertices.
            /// </summary>
            private void RebuildHull(bool[] removedVertices)
            {
                var vertexMap = new Dictionary<int, int>();
                var newVertices = new List<Vector3>();
                int newIndex = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (!removedVertices[i])
                    {
                        vertexMap[i] = newIndex;
                        newVertices.Add(vertices[i]);
                        newIndex++;
                    }
                }
                var newIndices = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int i1 = indices[i], i2 = indices[i + 1], i3 = indices[i + 2];
                    if (removedVertices[i1] || removedVertices[i2] || removedVertices[i3]) continue;
                    newIndices.Add(vertexMap[i1]);
                    newIndices.Add(vertexMap[i2]);
                    newIndices.Add(vertexMap[i3]);
                }
                vertices = newVertices;
                indices = newIndices;

                if (normals.Count > 0)
                {
                    var newNormals = new List<Vector3>(newVertices.Count);
                    for (int k = 0; k < newVertices.Count; k++) newNormals.Add(Vector3.zero);
                    foreach (var kv in vertexMap)
                        if (kv.Value < newNormals.Count && kv.Key < normals.Count)
                            newNormals[kv.Value] = normals[kv.Key];
                    normals = newNormals;
                }
            }
            /// <summary>
            /// Check if point is inside hull
            /// </summary>
            public bool ContainsPoint(Vector3 point)
            {
                // Use precomputed planes for faster containment checks
                for (int i = 0; i < planes.Count; i++)
                {
                    var plane = planes[i];
                    if (Vector3.Dot(plane.n, point) + plane.d > 1e-3f)
                        return false;
                }
                return true;
            }
            /// <summary>
            /// Calculate distance from point to hull surface
            /// </summary>
            public float DistanceToPoint(Vector3 point)
            {
                if (ContainsPoint(point))
                    return 0f;
                float minDistance = float.MaxValue;
                // Check distance to each triangle
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    // Calculate distance to triangle
                    var distance = DistanceToTriangle(point, a, b, c);
                    minDistance = Mathf.Min(minDistance, distance);
                }
                return minDistance;
            }
            private float DistanceToTriangle(Vector3 point, Vector3 a, Vector3 b, Vector3 c)
            {
                // Calculate closest point on triangle to the given point
                var ab = b - a;
                var ac = c - a;
                var ap = point - a;
                var d1 = Vector3.Dot(ab, ap);
                var d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0f && d2 <= 0f)
                    return Vector3.Distance(point, a);
                var bp = point - b;
                var d3 = Vector3.Dot(ab, bp);
                var d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0f && d4 <= d3)
                    return Vector3.Distance(point, b);
                var vc = d1 * d4 - d3 * d2;
                if (vc <= 0f && d1 >= 0f && d3 <= 0f)
                {
                    var v = d1 / (d1 - d3);
                    return Vector3.Distance(point, a + v * ab);
                }
                var cp = point - c;
                var d5 = Vector3.Dot(ab, cp);
                var d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0f && d5 <= d6)
                    return Vector3.Distance(point, c);
                var vb = d5 * d2 - d1 * d6;
                if (vb <= 0f && d2 >= 0f && d6 <= 0f)
                {
                    var w = d2 / (d2 - d6);
                    return Vector3.Distance(point, a + w * ac);
                }
                var va = d3 * d6 - d5 * d4;
                if (va <= 0f && (d4 - d3) >= 0f && (d5 - d6) >= 0f)
                {
                    var w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                    return Vector3.Distance(point, b + w * (c - b));
                }
                // Inside triangle
                var denom = 1f / (va + vb + vc);
                var v2 = vb * denom;
                var w2 = vc * denom;
                var closestPoint = a + ab * v2 + ac * w2;
                return Vector3.Distance(point, closestPoint);
            }
            /// <summary>
            /// Precompute face planes for faster containment checks
            /// </summary>
            public void BuildPlanes()
            {
                planes.Clear();
                if (vertices.Count == 0) return;
                // Calculate centroid
                centroid = Vector3.zero;
                foreach (var v in vertices)
                    centroid += v;
                centroid /= vertices.Count;
                // Build planes for each triangle
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var n = Vector3.Cross(b - a, c - a);
                    n.Normalize();
                    var d = -Vector3.Dot(n, a);
                    // Ensure normal points outward
                    if (Vector3.Dot(n, centroid) + d > 0f)
                    {
                        n = -n;
                        d = -d;
                    }
                    planes.Add(new PlaneF { n = n, d = d });
                }
                // Additional: Optimize planes list
                planes = planes.Distinct(new PlaneFComparer()).ToList();
            }
            class PlaneFComparer : IEqualityComparer<PlaneF>
            {
                public bool Equals(PlaneF x, PlaneF y)
                {
                    return Vector3.Dot(x.n, y.n) > 0.99f && Mathf.Abs(x.d - y.d) < 0.001f;
                }
                public int GetHashCode(PlaneF obj)
                {
                    const float q = 1e-3f;
                    var n = new Vector3(Mathf.Round(obj.n.x / q) * q, Mathf.Round(obj.n.y / q) * q, Mathf.Round(obj.n.z / q) * q);
                    var d = Mathf.Round(obj.d / q) * q;
                    return n.GetHashCode() ^ d.GetHashCode();
                }
            }
            /// <summary>
            /// Calculate hull properties
            /// </summary>
            public void CalculateProperties()
            {
                // Calculate bounds
                bounds = new Bounds();
                if (vertices.Count > 0)
                {
                    bounds = new Bounds(vertices[0], Vector3.zero);
                    foreach (var v in vertices)
                        bounds.Encapsulate(v);
                }
                // Calculate centroid
                centroid = Vector3.zero;
                foreach (var v in vertices)
                    centroid += v;
                if (vertices.Count > 0)
                    centroid /= vertices.Count;
                // Calculate volume
                volume = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    volume += Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                }
                volume = Mathf.Abs(volume);
                // Calculate surface area
                surfaceArea = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    surfaceArea += Vector3.Cross(b - a, c - a).magnitude / 2f;
                }
                // Calculate inertia tensor
                CalculateInertiaTensor();
                // Calculate shape metrics
                CalculateShapeMetrics();
                // Build edges
                BuildEdges();
                // Validate hull
                ValidateHull();
                // Additional: Calculate symmetry
                DetectSymmetry();
                creationTime = DateTime.Now;
                // Additional: Calculate topology
                CalculateTopology();
            }
            private void CalculateInertiaTensor()
            {
                // Calculate inertia tensor using parallel axis theorem
                float xx = 0f, yy = 0f, zz = 0f, xy = 0f, xz = 0f, yz = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    // Calculate tetrahedron contribution to inertia
                    float vol = Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                    if (vol <= 0) continue;
                    // Center of mass of tetrahedron
                    var com = (a + b + c) / 4f;
                    // Inertia contribution
                    xx += vol * (com.y * com.y + com.z * com.z);
                    yy += vol * (com.x * com.x + com.z * com.z);
                    zz += vol * (com.x * com.x + com.y * com.y);
                    xy -= vol * com.x * com.y;
                    xz -= vol * com.x * com.z;
                    yz -= vol * com.y * com.z;
                }
                // Build inertia tensor matrix
                inertiaMatrix = new Matrix4x4(
                    new Vector4(xx, xy, xz, 0),
                    new Vector4(xy, yy, yz, 0),
                    new Vector4(xz, yz, zz, 0),
                    new Vector4(0, 0, 0, 1)
                );
                // Calculate scalar inertia tensor (trace)
                inertiaTensor = xx + yy + zz;
            }
            /// <summary>
            /// Calculate shape metrics for quality assessment
            /// </summary>
            private void CalculateShapeMetrics()
            {
                if (volume <= 1e-6f || surfaceArea <= 1e-6f)
                {
                    compactness = sphericity = aspectRatio = elongation = flatness = 0;
                    return;
                }
                // Calculate compactness (volume to surface area ratio)
                compactness = volume / surfaceArea;
                // Calculate sphericity (how sphere-like the shape is)
                float sphereSurfaceArea = Mathf.Pow(Mathf.PI, 1 / 3f) * Mathf.Pow(6 * volume, 2 / 3f);
                sphericity = sphereSurfaceArea / surfaceArea;
                // Calculate aspect ratio (based on bounding box)
                var size = bounds.size;
                var sortedSize = new float[] { size.x, size.y, size.z };
                Array.Sort(sortedSize);
                if (sortedSize[0] < 1e-6f)
                {
                    aspectRatio = elongation = flatness = 0;
                    return;
                }
                aspectRatio = sortedSize[2] / sortedSize[0]; // max / min
                // Calculate elongation and flatness
                elongation = (sortedSize[1] - sortedSize[0]) / sortedSize[2];
                flatness = sortedSize[0] / sortedSize[2];
                // Additional: Calculate more metrics like convexity measure
                float convexity = volume / bounds.size.x / bounds.size.y / bounds.size.z;
                customProperties["Convexity"] = convexity;
            }
            private void BuildEdges()
            {
                edges.Clear();
                var edgeSet = new HashSet<(int, int)>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int i0 = indices[i];
                    int i1 = indices[i + 1];
                    int i2 = indices[i + 2];
                    // Add edges (ensure consistent ordering)
                    AddEdge(i0, i1, edgeSet);
                    AddEdge(i1, i2, edgeSet);
                    AddEdge(i2, i0, edgeSet);
                }
                // Additional: Sort edges by length
                edges.Sort((e1, e2) => e1.length.CompareTo(e2.length));
                // Additional: Calculate edge angles
                CalculateEdgeAngles();
            }
            private void AddEdge(int i1, int i2, HashSet<(int, int)> edgeSet)
            {
                // Ensure consistent ordering
                if (i1 > i2)
                {
                    (i1, i2) = (i2, i1);
                }
                var edge = (i1, i2);
                if (edgeSet.Add(edge))
                {
                    edges.Add(new HullEdge
                    {
                        vertex1 = i1,
                        vertex2 = i2,
                        length = Vector3.Distance(vertices[i1], vertices[i2])
                    });
                }
            }
            private void CalculateEdgeAngles()
            {
                // Calculate angles for each edge
                for (int k = 0; k < edges.Count; k++)
                {
                    var edge = edges[k];
                    // Find adjacent faces
                    List<Vector3> adjNormals = new List<Vector3>();
                    for (int m = 0; m < indices.Count; m += 3)
                    {
                        bool hasEdge = false;
                        for (int n = 0; n < 3; n++)
                        {
                            int v1 = indices[m + n];
                            int v2 = indices[m + (n + 1) % 3];
                            if ((v1 == edge.vertex1 && v2 == edge.vertex2) || (v1 == edge.vertex2 && v2 == edge.vertex1))
                            {
                                hasEdge = true;
                                break;
                            }
                        }
                        if (hasEdge)
                        {
                            var a = vertices[indices[m]];
                            var b = vertices[indices[m + 1]];
                            var c = vertices[indices[m + 2]];
                            var normal = Vector3.Cross(b - a, c - a).normalized;
                            adjNormals.Add(normal);
                        }
                    }
                    if (adjNormals.Count == 2)
                    {
                        edges[k].CalculateAngle(adjNormals[0], adjNormals[1]);
                    }
                }
            }
            private void ValidateHull()
            {
                isValid = true;
                if (vertices.Count < 4 || indices.Count < 12)
                {
                    isValid = false;
                    return;
                }

                if (!IsConvex() || !IsClosed() || !IsManifold())
                {
                    if (enableDetailedLoggingStatic) Debug.LogWarning("Hull is not manifold, attempting repair.");
                    RepairManifold();
                    // Re-validate after repair
                    if (!IsConvex() || !IsClosed() || !IsManifold())
                    {
                        isValid = false;
                        return;
                    }
                }

                // Check for degenerate triangles
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    if (area < 1e-6f)
                    {
                        isValid = false;
                        return;
                    }
                }
                // Additional: Check self-intersections
                if (HasSelfIntersections())
                {
                    isValid = false;
                }
            }
            private bool HasSelfIntersections()
            {
                // Basic check for intersecting triangles
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = i + 3; j < indices.Count; j += 3)
                    {
                        if (TrianglesIntersect(i, j))
                            return true;
                    }
                }
                return false;
            }
            private bool TrianglesIntersect(int tri1, int tri2)
            {
                var a1 = vertices[indices[tri1]];
                var b1 = vertices[indices[tri1 + 1]];
                var c1 = vertices[indices[tri1 + 2]];
                var a2 = vertices[indices[tri2]];
                var b2 = vertices[indices[tri2 + 1]];
                var c2 = vertices[indices[tri2 + 2]];
                // Check if any edge of tri1 intersects tri2
                if (LineTriangleIntersect(a1, b1, a2, b2, c2) ||
                    LineTriangleIntersect(b1, c1, a2, b2, c2) ||
                    LineTriangleIntersect(c1, a1, a2, b2, c2))
                    return true;
                // Check if any edge of tri2 intersects tri1
                if (LineTriangleIntersect(a2, b2, a1, b1, c1) ||
                    LineTriangleIntersect(b2, c2, a1, b1, c1) ||
                    LineTriangleIntersect(c2, a2, a1, b1, c1))
                    return true;
                return false;
            }
            private bool LineTriangleIntersect(Vector3 p1, Vector3 p2, Vector3 a, Vector3 b, Vector3 c)
            {
                // Implement line-triangle intersection
                var plane = new Plane(a, b, c);
                if (!plane.Raycast(new Ray(p1, p2 - p1), out float enter))
                    return false;
                if (enter < 0 || enter > Vector3.Distance(p1, p2))
                    return false;
                var point = p1 + enter * (p2 - p1);
                // Check if point is inside triangle
                var u = Vector3.Cross(b - a, point - a).magnitude;
                var v = Vector3.Cross(c - b, point - b).magnitude;
                var w = Vector3.Cross(a - c, point - c).magnitude;
                var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                return Mathf.Abs(u + v + w - area * 2) < 0.01f;
            }
            private bool IsConvex()
            {
                // Check if all face normals point outward relative to the centroid
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var normal = Vector3.Cross(b - a, c - a).normalized;
                    var center = (a + b + c) / 3f;
                    // Check if centroid is on the "inside" of the face
                    if (Vector3.Dot(normal, centroid - center) > 1e-6f)
                    {
                        return false;
                    }
                }
                return true;
            }
            private bool IsManifold()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2) (v1, v2) = (v2, v1);
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge)) edgeCountDict[edge]++;
                        else edgeCountDict[edge] = 1;
                    }
                }
                foreach (var count in edgeCountDict.Values)
                {
                    if (count > 2) return false; // Edge shared by more than 2 faces
                }
                return true;
            }

            private bool IsClosed()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Hull is closed if all edges are shared by exactly 2 triangles
                foreach (var count in edgeCountDict.Values)
                {
                    if (count != 2)
                        return false;
                }
                return true;
            }
            /// <summary>
            /// Build mesh data representation
            /// </summary>
            public void BuildMeshData()
            {
                meshData = new MeshData();
                meshData.vertices = new List<Vector3>(vertices);
                meshData.indices = new List<int>(indices);
                meshData.normals = new List<Vector3>(normals);
                meshData.CalculateProperties();
            }
            /// <summary>
            /// Build acceleration structure for fast queries
            /// </summary>
            public void BuildAccelerationStructure()
            {
                if (meshData == null)
                {
                    BuildMeshData();
                }
                accelerationStructure = new BVH(meshData);
                hasPrecomputedData = true;
            }
            /// <summary>
            /// Calculate witness points for error analysis
            /// </summary>
            public void CalculateWitnessPoints(MeshData referenceMesh, int sampleCount = 100)
            {
                if (accelerationStructure == null)
                {
                    BuildAccelerationStructure();
                }
                witnessPoints = new List<Vector3>();
                witnessErrors = new List<float>();
                // Sample points from reference mesh
                var samples = ErrorCalculator.SampleMeshSurface(referenceMesh, sampleCount);
                foreach (var sample in samples)
                {
                    float distance = DistanceToPoint(sample);
                    witnessPoints.Add(sample);
                    witnessErrors.Add(distance);
                }
                // Additional: Sort by error
                var sortedIndices = Enumerable.Range(0, witnessErrors.Count).OrderByDescending(idx => witnessErrors[idx]).ToList();
                var sortedPoints = new List<Vector3>();
                var sortedErrors = new List<float>();
                foreach (var idx in sortedIndices)
                {
                    sortedPoints.Add(witnessPoints[idx]);
                    sortedErrors.Add(witnessErrors[idx]);
                }
                witnessPoints = sortedPoints;
                witnessErrors = sortedErrors;
            }
            private void DetectSymmetry()
            {
                symmetryAxes = new List<Vector3>();
                // Basic symmetry detection along axes
                if (IsSymmetricAlongAxis(Vector3.right))
                    symmetryAxes.Add(Vector3.right);
                if (IsSymmetricAlongAxis(Vector3.up))
                    symmetryAxes.Add(Vector3.up);
                if (IsSymmetricAlongAxis(Vector3.forward))
                    symmetryAxes.Add(Vector3.forward);
                // Additional: Detect arbitrary symmetry planes
                DetectArbitrarySymmetry();
            }
            private void DetectArbitrarySymmetry()
            {
                // Advanced symmetry detection
                // ... (add logic for PCA or other methods)
            }
            private bool IsSymmetricAlongAxis(Vector3 axis)
            {
                // Check if reflecting across plane gives the same hull
                var plane = new PlaneF { n = axis, d = -Vector3.Dot(centroid, axis) };
                var reflectedVertices = new List<Vector3>();
                foreach (var v in vertices)
                {
                    float dist = plane.DistanceToPoint(v);
                    var reflected = v - 2 * dist * plane.n;
                    reflectedVertices.Add(reflected);
                }
                // Check if all reflected points are in hull
                foreach (var rv in reflectedVertices)
                {
                    if (!ContainsPoint(rv))
                        return false;
                }
                return true;
            }
            public void SmoothHull(int iterations, float lambda, bool lockBoundaries)
            {
                // Identify boundary vertices if we need to lock them
                HashSet<int> boundaryVertices = null;
                if (lockBoundaries)
                {
                    boundaryVertices = new HashSet<int>();
                    var edgeCounts = new Dictionary<(int, int), int>();
                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        for (int j = 0; j < 3; j++)
                        {
                            int v1 = indices[i + j];
                            int v2 = indices[i + (j + 1) % 3];
                            var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                            edgeCounts.TryGetValue(edge, out int count);
                            edgeCounts[edge] = count + 1;
                        }
                    }
                    foreach (var edge in edgeCounts)
                    {
                        if (edge.Value == 1) // Boundary edge
                        {
                            boundaryVertices.Add(edge.Key.Item1);
                            boundaryVertices.Add(edge.Key.Item2);
                        }
                    }
                }

                // Apply Laplacian smoothing
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newVertices = new List<Vector3>(vertices);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        if (lockBoundaries && boundaryVertices != null && boundaryVertices.Contains(i)) continue;

                        var neighbors = new List<Vector3>();
                        foreach (var edge in edges)
                        {
                            if (edge.vertex1 == i) neighbors.Add(vertices[edge.vertex2]);
                            else if (edge.vertex2 == i) neighbors.Add(vertices[edge.vertex1]);
                        }

                        if (neighbors.Count > 0)
                        {
                            var avg = Vector3.zero;
                            foreach (var n in neighbors) avg += n;
                            newVertices[i] = Vector3.Lerp(vertices[i], avg / neighbors.Count, lambda);
                        }
                    }
                    vertices = newVertices;
                }
            }

            /// <summary>
            /// Fills holes in the hull by identifying and triangulating boundary edge loops.
            /// </summary>
            public void FillHoles()
            {
                var edgeCounts = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                        edgeCounts.TryGetValue(edge, out int count);
                        edgeCounts[edge] = count + 1;
                    }
                }

                var boundaryEdges = new HashSet<(int, int)>();
                foreach (var edge in edgeCounts)
                {
                    if (edge.Value == 1) boundaryEdges.Add(edge.Key);
                }

                if (boundaryEdges.Count == 0) return;

                var adjacency = new Dictionary<int, List<int>>();
                foreach(var edge in boundaryEdges)
                {
                    if (!adjacency.ContainsKey(edge.Item1)) adjacency[edge.Item1] = new List<int>();
                    if (!adjacency.ContainsKey(edge.Item2)) adjacency[edge.Item2] = new List<int>();
                    adjacency[edge.Item1].Add(edge.Item2);
                    adjacency[edge.Item2].Add(edge.Item1);
                }

                var visited = new HashSet<int>();
                var loops = new List<List<int>>();
                foreach(var startNode in adjacency.Keys)
                {
                    if (visited.Contains(startNode)) continue;
                    var loop = new List<int>();
                    var stack = new Stack<int>();
                    stack.Push(startNode);

                    var path = new Dictionary<int, int>();

                    while(stack.Count > 0)
                    {
                        var current = stack.Pop();
                        if (visited.Contains(current)) continue;
                        visited.Add(current);
                        loop.Add(current);

                        foreach(var neighbor in adjacency[current])
                        {
                            if (!visited.Contains(neighbor))
                            {
                                stack.Push(neighbor);
                            }
                        }
                    }
                    if (loop.Count > 2) loops.Add(loop);
                }

                foreach(var loop in loops)
                {
                    var poly = new List<int>(loop);
                    while(poly.Count > 2)
                    {
                        int earIndex = FindEar(poly, loop);
                        if(earIndex == -1) break; // Could not find an ear

                        int prev = poly[(earIndex == 0) ? poly.Count - 1 : earIndex - 1];
                        int curr = poly[earIndex];
                        int next = poly[(earIndex + 1) % poly.Count];

                        indices.Add(prev);
                        indices.Add(curr);
                        indices.Add(next);

                        poly.RemoveAt(earIndex);
                    }
                }
            }

            private int FindEar(List<int> poly, List<int> originalLoop)
            {
                for(int i=0; i < poly.Count; i++)
                {
                    int p_idx = poly[(i == 0) ? poly.Count - 1 : i - 1];
                    int c_idx = poly[i];
                    int n_idx = poly[(i + 1) % poly.Count];

                    Vector3 p = vertices[p_idx];
                    Vector3 c = vertices[c_idx];
                    Vector3 n = vertices[n_idx];

                    Vector3 loopNormal = CalculateLoopNormal(originalLoop);
                    if (Vector3.Dot(Vector3.Cross(c - p, n - p), loopNormal) < 0) continue;

                    bool isEar = true;
                    for (int j = 0; j < poly.Count; j++)
                    {
                        int vert_idx = poly[j];
                        if (vert_idx == p_idx || vert_idx == c_idx || vert_idx == n_idx) continue;
                        if (IsPointInTriangle(vertices[vert_idx], p, c, n))
                        {
                            isEar = false;
                            break;
                        }
                    }
                    if (isEar) return i;
                }
                return -1;
            }

            private Vector3 CalculateLoopNormal(List<int> loop)
            {
                Vector3 normal = Vector3.zero;
                for(int i=0; i < loop.Count; i++)
                {
                    Vector3 current = vertices[loop[i]];
                    Vector3 next = vertices[loop[(i + 1) % loop.Count]];
                    normal.x += (current.y - next.y) * (current.z + next.z);
                    normal.y += (current.z - next.z) * (current.x + next.x);
                    normal.z += (current.x - next.x) * (current.y + next.y);
                }
                return normal.normalized;
            }

            private bool IsPointInTriangle(Vector3 pt, Vector3 v1, Vector3 v2, Vector3 v3)
            {
                var d1 = pt - v1;
                var d2 = v2 - v1;
                var d3 = v3 - v1;

                var dot00 = Vector3.Dot(d3, d3);
                var dot01 = Vector3.Dot(d3, d2);
                var dot02 = Vector3.Dot(d3, d1);
                var dot11 = Vector3.Dot(d2, d2);
                var dot12 = Vector3.Dot(d2, d1);

                var invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                return (u >= 0) && (v >= 0) && (u + v < 1);
            }

            /// <summary>
            /// Enforces symmetry on the hull based on its detected symmetry planes.
            /// </summary>
            public void EnforceSymmetry()
            {
                if (symmetryAxes == null || symmetryAxes.Count == 0)
                {
                    DetectSymmetry();
                    if (symmetryAxes.Count == 0) return; // No symmetry found
                }

                var symmetrizedPoints = new List<Vector3>(vertices);
                var originalPoints = new List<Vector3>(vertices);

                foreach (var axis in symmetryAxes)
                {
                    var plane = new PlaneF { n = axis.normalized, d = -Vector3.Dot(centroid, axis.normalized) };
                    var reflectedPoints = new List<Vector3>();
                    foreach (var v in originalPoints)
                    {
                        float dist = plane.DistanceToPoint(v);
                        var reflectedV = v - 2 * dist * plane.n;
                        reflectedPoints.Add(reflectedV);
                    }
                    symmetrizedPoints.AddRange(reflectedPoints);
                }

                // Re-hull with the combined original and reflected points to create a symmetric hull
                var newHull = QuickHullImplementation.ComputeConvexHullFromPoints(symmetrizedPoints.Distinct().ToList());
                if (newHull.vertices.Count > 3)
                {
                    this.vertices = newHull.vertices;
                    this.indices = newHull.indices;
                }
            }
            private void CalculateTopology()
            {
                // Calculate Euler characteristic for hull
                int V = vertices.Count;
                int E = edges.Count;
                int F = indices.Count / 3;
                eulerCharacteristic = V - E + F;
                genus = (2 - eulerCharacteristic) / 2;
            }

            private void RepairManifold()
            {
                // 1. Remove duplicate triangles
                var triSet = new HashSet<string>();
                var newIndices = new List<int>();
                for(int i=0; i<indices.Count; i+=3)
                {
                    var tri = new int[]{indices[i], indices[i+1], indices[i+2]};
                    Array.Sort(tri);
                    var key = $"{tri[0]}_{tri[1]}_{tri[2]}";
                    if(triSet.Add(key))
                    {
                        newIndices.AddRange(tri);
                    }
                }
                indices = newIndices;

                // 2. Fill holes
                FillHoles();

                // 3. Re-calculate properties after repair
                CalculateProperties();
            }
        }
        /// <summary>
        /// Represents an edge in a convex hull
        /// </summary>
        [Serializable]
        public struct HullEdge
        {
            public int vertex1;
            public int vertex2;
            public float length;
            // Additional
            public bool isSharp;
            public float angle;
            public float CalculateAngle(Vector3 n1, Vector3 n2)
            {
                angle = Mathf.Acos(Vector3.Dot(n1, n2)) * Mathf.Rad2Deg;
                isSharp = angle > 30f;
                return angle;
            }
        }
        /// <summary>
        /// Burst-safe plane structure
        /// </summary>
        [Serializable]
        public struct PlaneF
        {
            public Vector3 n; // normal
            public float d; // distance from origin
            public float DistanceToPoint(Vector3 point)
            {
                return Vector3.Dot(n, point) + d;
            }
            // Additional
            public Vector3 ProjectPoint(Vector3 point)
            {
                return point - DistanceToPoint(point) * n;
            }
            public bool Equals(PlaneF other, float epsilon = 1e-5f)
            {
                return Vector3.Dot(n, other.n) > 1 - epsilon && Mathf.Abs(d - other.d) < epsilon;
            }
        }
        /// <summary>
        /// Error calculator for mesh comparison with multiple metrics
        /// </summary>
        public static class ErrorCalculator
        {
            /// <summary>
            /// Sample points from mesh surface using specified strategy
            /// </summary>
            public static List<Vector3> SampleMeshSurface(MeshData mesh, int sampleCount, SamplingStrategy strategy = SamplingStrategy.AreaWeighted)
            {
                var samples = new List<Vector3>();
                if (mesh.triangleCount == 0) return samples;
                switch (strategy)
                {
                    case SamplingStrategy.Uniform:
                        return SampleUniform(mesh, sampleCount);
                    case SamplingStrategy.AreaWeighted:
                        return SampleAreaWeighted(mesh, sampleCount);
                    case SamplingStrategy.CurvatureWeighted:
                        return SampleCurvatureWeighted(mesh, sampleCount);
                    case SamplingStrategy.FeaturePreserving:
                        return SampleFeaturePreserving(mesh, sampleCount);
                    case SamplingStrategy.Adaptive:
                        return SampleAdaptive(mesh, sampleCount);
                    case SamplingStrategy.Stratified:
                        return SampleStratified(mesh, sampleCount);
                    default:
                        return SampleAreaWeighted(mesh, sampleCount);
                }
            }
            /// <summary>
            /// Uniform sampling across triangles
            /// </summary>
            private static List<Vector3> SampleUniform(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                int trianglesPerSample = Mathf.Max(1, mesh.triangleCount / sampleCount);
                for (int i = 0; i < mesh.indices.Count; i += 3 * trianglesPerSample)
                {
                    if (samples.Count >= sampleCount) break;
                    // Select a triangle from this group
                    int triIndex = i + UnityEngine.Random.Range(0, trianglesPerSample * 3);
                    triIndex = Mathf.Min(triIndex, mesh.indices.Count - 3);
                    // Get triangle vertices
                    var a = mesh.vertices[mesh.indices[triIndex]];
                    var b = mesh.vertices[mesh.indices[triIndex + 1]];
                    var c = mesh.vertices[mesh.indices[triIndex + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Area-weighted sampling
            /// </summary>
            private static List<Vector3> SampleAreaWeighted(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                if (mesh.triangleCount == 0) return samples;
                // Calculate triangle areas for weighted sampling
                var areas = new float[mesh.triangleCount];
                float totalArea = 0f;
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    var a = mesh.vertices[mesh.indices[i]];
                    var b = mesh.vertices[mesh.indices[i + 1]];
                    var c = mesh.vertices[mesh.indices[i + 2]];
                    areas[triIndex] = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    totalArea += areas[triIndex];
                }
                if (totalArea < 1e-6f) return samples;
                // Normalize areas to create cumulative distribution
                var cumulativeAreas = new float[areas.Length];
                float cumulative = 0f;
                for (int i = 0; i < areas.Length; i++)
                {
                    cumulative += areas[i];
                    cumulativeAreas[i] = cumulative;
                }
                // Sample points
                for (int s = 0; s < sampleCount; s++)
                {
                    float r = UnityEngine.Random.value * totalArea;
                    // Find triangle using binary search
                    int low = 0;
                    int high = cumulativeAreas.Length - 1;
                    while (low < high)
                    {
                        int mid = (low + high) / 2;
                        if (cumulativeAreas[mid] < r)
                            low = mid + 1;
                        else
                            high = mid;
                    }
                    int triIndex = low;
                    // Get triangle vertices
                    int idx = triIndex * 3;
                    var a = mesh.vertices[mesh.indices[idx]];
                    var b = mesh.vertices[mesh.indices[idx + 1]];
                    var c = mesh.vertices[mesh.indices[idx + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Curvature-weighted sampling
            /// </summary>
            private static List<Vector3> SampleCurvatureWeighted(MeshData mesh, int sampleCount)
            {
                // Calculate curvature if not already present
                if (mesh.curvature == null || mesh.curvature.Count != mesh.vertices.Count)
                {
                    mesh.CalculateCurvature();
                }
                var samples = new List<Vector3>();
                // Calculate triangle curvature weights
                var weights = new float[mesh.triangleCount];
                float totalWeight = 0f;
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    var i0 = mesh.indices[i];
                    var i1 = mesh.indices[i + 1];
                    var i2 = mesh.indices[i + 2];
                    // Use average curvature of triangle vertices
                    weights[triIndex] = (mesh.curvature[i0].magnitude +
                                         mesh.curvature[i1].magnitude +
                                         mesh.curvature[i2].magnitude) / 3f;
                    totalWeight += weights[triIndex];
                }
                if (totalWeight < 1e-6f) return SampleAreaWeighted(mesh, sampleCount);
                // Normalize weights to create cumulative distribution
                var cumulativeWeights = new float[weights.Length];
                float cumulative = 0f;
                for (int i = 0; i < weights.Length; i++)
                {
                    cumulative += weights[i];
                    cumulativeWeights[i] = cumulative;
                }
                // Sample points
                for (int s = 0; s < sampleCount; s++)
                {
                    float r = UnityEngine.Random.value * totalWeight;
                    // Find triangle using binary search
                    int low = 0;
                    int high = cumulativeWeights.Length - 1;
                    while (low < high)
                    {
                        int mid = (low + high) / 2;
                        if (cumulativeWeights[mid] < r)
                            low = mid + 1;
                        else
                            high = mid;
                    }
                    int triIndex = low;
                    // Get triangle vertices
                    int idx = triIndex * 3;
                    var a = mesh.vertices[mesh.indices[idx]];
                    var b = mesh.vertices[mesh.indices[idx + 1]];
                    var c = mesh.vertices[mesh.indices[idx + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Feature-preserving sampling
            /// </summary>
            private static List<Vector3> SampleFeaturePreserving(MeshData mesh, int sampleCount)
            {
                // Identify features if not already present
                if (mesh.featureVertices == null || mesh.featureVertices.Count == 0)
                {
                    mesh.IdentifyFeatureVertices();
                }
                var samples = new List<Vector3>();
                // Reserve some samples for feature vertices
                int featureSampleCount = Mathf.Min(sampleCount / 4, mesh.featureVertices.Count);
                int regularSampleCount = sampleCount - featureSampleCount;
                // Sample feature vertices
                if (mesh.featureVertices.Count > 0)
                {
                    var featureIndices = new List<int>(mesh.featureVertices);
                    // Randomly select feature vertices
                    for (int i = 0; i < featureSampleCount; i++)
                    {
                        if (featureIndices.Count == 0) break;
                        int idx = UnityEngine.Random.Range(0, featureIndices.Count);
                        samples.Add(mesh.vertices[featureIndices[idx]]);
                        featureIndices.RemoveAt(idx);
                    }
                }
                // Sample remaining points using area-weighted strategy
                if (regularSampleCount > 0)
                {
                    var regularSamples = SampleAreaWeighted(mesh, regularSampleCount);
                    samples.AddRange(regularSamples);
                }
                // Additional: Ensure no duplicates
                samples = samples.Distinct(new Vector3Comparer()).ToList();
                return samples;
            }
            class Vector3Comparer : IEqualityComparer<Vector3>
            {
                public bool Equals(Vector3 x, Vector3 y)
                {
                    return (x - y).sqrMagnitude < 1e-6f;
                }
                public int GetHashCode(Vector3 obj)
                {
                    return obj.GetHashCode();
                }
            }
            /// <summary>
            /// Adaptive sampling based on error
            /// </summary>
            private static List<Vector3> SampleAdaptive(MeshData mesh, int sampleCount)
            {
                // Start with area-weighted sampling
                var samples = SampleAreaWeighted(mesh, sampleCount / 2);
                // Add more samples in high-error regions (using curvature as a proxy)
                var curvatureSamples = SampleCurvatureWeighted(mesh, sampleCount / 2);
                samples.AddRange(curvatureSamples);
                // Additional: Adapt based on density
                AdjustSampleDensity(samples, mesh.bounds, 0.05f);
                return samples;
            }
            private static void AdjustSampleDensity(List<Vector3> samples, Bounds bounds, float minDistance)
            {
                for (int i = samples.Count - 1; i >= 0; i--)
                {
                    for (int j = 0; j < i; j++)
                    {
                        if (Vector3.Distance(samples[i], samples[j]) < minDistance)
                        {
                            samples.RemoveAt(i);
                            break;
                        }
                    }
                }
            }
            /// <summary>
            /// Stratified sampling
            /// </summary>
            private static List<Vector3> SampleStratified(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                // Divide the mesh into strata based on spatial location
                var bounds = mesh.bounds;
                int strataPerAxis = Mathf.CeilToInt(Mathf.Pow(sampleCount, 1f / 3f));
                float strataSizeX = bounds.size.x / strataPerAxis;
                float strataSizeY = bounds.size.y / strataPerAxis;
                float strataSizeZ = bounds.size.z / strataPerAxis;
                // Create strata
                var strata = new List<List<int>>();
                for (int x = 0; x < strataPerAxis; x++)
                {
                    for (int y = 0; y < strataPerAxis; y++)
                    {
                        for (int z = 0; z < strataPerAxis; z++)
                        {
                            var stratumBounds = new Bounds(
                                bounds.min + new Vector3(x * strataSizeX, y * strataSizeY, z * strataSizeZ) + new Vector3(strataSizeX, strataSizeY, strataSizeZ) / 2,
                                new Vector3(strataSizeX, strataSizeY, strataSizeZ)
                            );
                            var stratumTriangles = new List<int>();
                            // Find triangles in this stratum
                            for (int i = 0; i < mesh.indices.Count; i += 3)
                            {
                                var a = mesh.vertices[mesh.indices[i]];
                                var b = mesh.vertices[mesh.indices[i + 1]];
                                var c = mesh.vertices[mesh.indices[i + 2]];
                                var triBounds = new Bounds(a, Vector3.zero);
                                triBounds.Encapsulate(b);
                                triBounds.Encapsulate(c);
                                if (stratumBounds.Intersects(triBounds))
                                {
                                    stratumTriangles.Add(i);
                                }
                            }
                            strata.Add(stratumTriangles);
                        }
                    }
                }
                // Sample from each stratum
                int samplesPerStratum = Mathf.Max(1, sampleCount / strata.Count);
                foreach (var stratum in strata)
                {
                    if (stratum.Count == 0) continue;
                    for (int i = 0; i < samplesPerStratum && samples.Count < sampleCount; i++)
                    {
                        // Randomly select a triangle from this stratum
                        int triIndex = stratum[UnityEngine.Random.Range(0, stratum.Count)];
                        // Get triangle vertices
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        // Generate random barycentric coordinates
                        float r1 = UnityEngine.Random.value;
                        float r2 = UnityEngine.Random.value;
                        if (r1 + r2 > 1f)
                        {
                            r1 = 1f - r1;
                            r2 = 1f - r2;
                        }
                        float u = r1;
                        float v = r2;
                        float w = 1f - u - v;
                        // Calculate point
                        var point = a * u + b * v + c * w;
                        samples.Add(point);
                    }
                }
                // Additional: Fill remaining samples if needed
                if (samples.Count < sampleCount)
                {
                    var additional = SampleAreaWeighted(mesh, sampleCount - samples.Count);
                    samples.AddRange(additional);
                }
                return samples;
            }
            /// <summary>
            /// Calculate symmetric Hausdorff distance between two meshes
            /// </summary>
            public static float CalculateSymmetricHausdorff(MeshData mesh1, MeshData mesh2, int sampleCount = 1000)
            {
                // Sample points from both meshes
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                var samples2 = SampleMeshSurface(mesh2, sampleCount);
                if (samples1.Count == 0 || samples2.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate max distance from mesh1 to mesh2
                float maxDist1 = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    maxDist1 = Mathf.Max(maxDist1, dist);
                }
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate max distance from mesh2 to mesh1
                float maxDist2 = 0f;
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    maxDist2 = Mathf.Max(maxDist2, dist);
                }
                // Return symmetric Hausdorff distance
                return Mathf.Max(maxDist1, maxDist2);
            }
            /// <summary>
            /// Calculate error using specified metric
            /// </summary>
            public static float CalculateError(MeshData mesh1, MeshData mesh2, ErrorMetricType metricType)
            {
                switch (metricType)
                {
                    case ErrorMetricType.Hausdorff:
                        return CalculateHausdorff(mesh1, mesh2);
                    case ErrorMetricType.SymmetricHausdorff:
                        return CalculateSymmetricHausdorff(mesh1, mesh2);
                    case ErrorMetricType.MeanSquared:
                        return CalculateMeanSquaredError(mesh1, mesh2);
                    case ErrorMetricType.RootMeanSquared:
                        return Mathf.Sqrt(CalculateMeanSquaredError(mesh1, mesh2));
                    case ErrorMetricType.MaxDeviation:
                        return CalculateMaxDeviation(mesh1, mesh2);
                    case ErrorMetricType.VolumeDifference:
                        return CalculateVolumeDifference(mesh1, mesh2);
                    case ErrorMetricType.SurfaceAreaDifference:
                        return CalculateSurfaceAreaDifference(mesh1, mesh2);
                    default:
                        return CalculateSymmetricHausdorff(mesh1, mesh2);
                }
            }
            /// <summary>
            /// Calculate Hausdorff distance from mesh1 to mesh2
            /// </summary>
            public static float CalculateHausdorff(MeshData mesh1, MeshData mesh2)
            {
                // Sample points from mesh1
                int sampleCount = Mathf.Min(1000, mesh1.triangleCount * 10);
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                if (samples1.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate max distance from mesh1 to mesh2
                float maxDist = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    maxDist = Mathf.Max(maxDist, dist);
                }
                return maxDist;
            }
            /// <summary>
            /// Calculate mean squared error between two meshes
            /// </summary>
            public static float CalculateMeanSquaredError(MeshData mesh1, MeshData mesh2)
            {
                // Sample points from both meshes
                int sampleCount = Mathf.Min(1000, mesh1.triangleCount * 10);
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                var samples2 = SampleMeshSurface(mesh2, sampleCount);
                if (samples1.Count == 0 || samples2.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate squared distances from mesh1 to mesh2
                float sumSquaredDist = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    sumSquaredDist += dist * dist;
                }
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate squared distances from mesh2 to mesh1
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    sumSquaredDist += dist * dist;
                }
                // Return mean squared error
                return sumSquaredDist / (samples1.Count + samples2.Count);
            }
            /// <summary>
            /// Calculate maximum deviation between two meshes
            /// </summary>
            public static float CalculateMaxDeviation(MeshData mesh1, MeshData mesh2)
            {
                // This is equivalent to symmetric Hausdorff
                return CalculateSymmetricHausdorff(mesh1, mesh2);
            }
            /// <summary>
            /// Calculate volume difference between two meshes
            /// </summary>
            public static float CalculateVolumeDifference(MeshData mesh1, MeshData mesh2)
            {
                return Mathf.Abs(mesh1.volume - mesh2.volume);
            }
            /// <summary>
            /// Calculate surface area difference between two meshes
            /// </summary>
            public static float CalculateSurfaceAreaDifference(MeshData mesh1, MeshData mesh2)
            {
                return Mathf.Abs(mesh1.surfaceArea - mesh2.surfaceArea);
            }
            /// <summary>
            /// Calculate error distribution between two meshes
            /// </summary>
            public static List<float> CalculateErrorDistribution(MeshData mesh1, MeshData mesh2, int sampleCount = 1000)
            {
                var errors = new List<float>();
                // Sample points from mesh1
                var samples1 = SampleMeshSurface(mesh1, sampleCount / 2);
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate distances from mesh1 to mesh2
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    errors.Add(dist);
                }
                // Sample points from mesh2
                var samples2 = SampleMeshSurface(mesh2, sampleCount / 2);
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate distances from mesh2 to mesh1
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    errors.Add(dist);
                }
                return errors;
            }
            public static float CalculateSymmetricHausdorff(MeshData mesh, List<ConvexHull> hulls, int maxSamples = 2000)
            {
                var hullMesh = CombineHullsToMesh(hulls);
                if (hullMesh.vertices.Count == 0) return 0f;
                return CalculateSymmetricHausdorff(mesh, hullMesh, maxSamples);
            }
            public static List<float> CalculateErrorDistribution(MeshData mesh, List<ConvexHull> hulls, int sampleCount = 1000)
            {
                var hullMesh = CombineHullsToMesh(hulls);
                if (hullMesh.vertices.Count == 0) return new List<float>();
                return CalculateErrorDistribution(mesh, hullMesh, sampleCount);
            }
            static MeshData CombineHullsToMesh(List<ConvexHull> hulls)
            {
                var m = new MeshData();
                foreach (var h in hulls)
                {
                    if (h.vertices == null || h.indices == null || h.vertices.Count == 0 || h.indices.Count == 0) continue;
                    int baseIdx = m.vertices.Count;
                    m.vertices.AddRange(h.vertices);
                    if (h.normals != null && h.normals.Count == h.vertices.Count) m.normals.AddRange(h.normals);
                    else { for (int i = 0; i < h.vertices.Count; i++) m.normals.Add(Vector3.zero); } // Add placeholder normals
                    for (int i = 0; i < h.indices.Count; i++) m.indices.Add(h.indices[i] + baseIdx);
                }
                m.CalculateProperties();
                return m;
            }
            // Additional: Calculate PSNR
            public static float CalculatePSNR(MeshData mesh1, MeshData mesh2)
            {
                float mse = CalculateMeanSquaredError(mesh1, mesh2);
                if (mse == 0) return float.PositiveInfinity;
                float maxValue = Mathf.Max(mesh1.bounds.size.magnitude, mesh2.bounds.size.magnitude);
                return 20 * Mathf.Log10(maxValue / Mathf.Sqrt(mse));
            }
            // Additional: Calculate SSIM
            public static float CalculateSSIM(MeshData mesh1, MeshData mesh2)
            {
                // Simplified SSIM calculation
                // ... (add logic)
                return 1f; // Placeholder
            }
        }
        /// <summary>
        /// Bounding Volume Hierarchy for spatial acceleration
        /// </summary>
        public class BVH
        {
            private class Node
            {
                public Bounds bounds;
                public List<int> triangleIndices;
                public Node left;
                public Node right;
                public bool isLeaf;
                public int depth;
            }
            private Node root;
            private MeshData mesh;
            private int maxTrianglesPerNode = 10;
            private int maxDepth = 20;
            public BVH(MeshData mesh)
            {
                this.mesh = mesh;
                Build();
            }
            private void Build()
            {
                if (mesh == null || mesh.triangleCount == 0) return;
                var allIndices = Enumerable.Range(0, mesh.triangleCount).Select(i => i * 3).ToList();
                root = BuildRecursive(allIndices, 0);
            }
            private Node BuildRecursive(List<int> triangleIndices, int depth)
            {
                var node = new Node
                {
                    triangleIndices = triangleIndices,
                    depth = depth,
                    bounds = CalculateBounds(triangleIndices)
                };
                if (triangleIndices.Count <= maxTrianglesPerNode || depth >= maxDepth)
                {
                    node.isLeaf = true;
                    return node;
                }
                // Find longest axis to split
                int axis = 0;
                var size = node.bounds.size;
                if (size.y > size.x) axis = 1;
                if (size.z > size[axis]) axis = 2;
                float splitPos = node.bounds.center[axis];
                var leftIndices = new List<int>();
                var rightIndices = new List<int>();
                foreach (var triIndex in triangleIndices)
                {
                    var triCenter = (mesh.vertices[mesh.indices[triIndex]] +
                                     mesh.vertices[mesh.indices[triIndex + 1]] +
                                     mesh.vertices[mesh.indices[triIndex + 2]]) / 3f;
                    if (triCenter[axis] < splitPos)
                        leftIndices.Add(triIndex);
                    else
                        rightIndices.Add(triIndex);
                }
                // Handle cases where split fails
                if (leftIndices.Count == 0 || rightIndices.Count == 0)
                {
                    node.isLeaf = true;
                    return node;
                }
                node.isLeaf = false;
                node.left = BuildRecursive(leftIndices, depth + 1);
                node.right = BuildRecursive(rightIndices, depth + 1);
                return node;
            }
            private Bounds CalculateBounds(List<int> triangleIndices)
            {
                if (triangleIndices.Count == 0) return new Bounds();
                var bounds = new Bounds(mesh.vertices[mesh.indices[triangleIndices[0]]], Vector3.zero);
                foreach (var triIndex in triangleIndices)
                {
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex]]);
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex + 1]]);
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex + 2]]);
                }
                return bounds;
            }
            public float DistanceToPoint(Vector3 point)
            {
                if (root == null) return float.MaxValue;
                return DistanceToPointRecursive(point, root);
            }
            private float DistanceToPointRecursive(Vector3 point, Node node)
            {
                if (node.isLeaf)
                {
                    float minDistance = float.MaxValue;
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        minDistance = Mathf.Min(minDistance, DistanceToTriangle(point, a, b, c));
                    }
                    return minDistance;
                }
                float distToLeftBounds = SqrDistanceToBounds(point, node.left.bounds);
                float distToRightBounds = SqrDistanceToBounds(point, node.right.bounds);
                if (distToLeftBounds < distToRightBounds)
                {
                    float distLeft = DistanceToPointRecursive(point, node.left);
                    if (distToRightBounds >= distLeft * distLeft) return distLeft;
                    return Mathf.Min(distLeft, DistanceToPointRecursive(point, node.right));
                }
                else
                {
                    float distRight = DistanceToPointRecursive(point, node.right);
                    if (distToLeftBounds >= distRight * distRight) return distRight;
                    return Mathf.Min(distRight, DistanceToPointRecursive(point, node.left));
                }
            }
            private float SqrDistanceToBounds(Vector3 point, Bounds bounds)
            {
                var closest = bounds.ClosestPoint(point);
                return (point - closest).sqrMagnitude;
            }
            private float DistanceToTriangle(Vector3 point, Vector3 a, Vector3 b, Vector3 c)
            {
                var ab = b - a;
                var ac = c - a;
                var ap = point - a;
                var d1 = Vector3.Dot(ab, ap);
                var d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0f && d2 <= 0f) return Vector3.Distance(point, a);
                var bp = point - b;
                var d3 = Vector3.Dot(ab, bp);
                var d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0f && d4 <= d3) return Vector3.Distance(point, b);
                var vc = d1 * d4 - d3 * d2;
                if (vc <= 0f && d1 >= 0f && d3 <= 0f)
                {
                    var v = d1 / (d1 - d3);
                    return Vector3.Distance(point, a + v * ab);
                }
                var cp = point - c;
                var d5 = Vector3.Dot(ab, cp);
                var d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0f && d5 <= d6) return Vector3.Distance(point, c);
                var vb = d5 * d2 - d1 * d6;
                if (vb <= 0f && d2 >= 0f && d6 <= 0f)
                {
                    var w = d2 / (d2 - d6);
                    return Vector3.Distance(point, a + w * ac);
                }
                var va = d3 * d6 - d5 * d4;
                if (va <= 0f && (d4 - d3) >= 0f && (d5 - d6) >= 0f)
                {
                    var w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                    return Vector3.Distance(point, b + w * (c - b));
                }
                var denom = va + vb + vc;
                if (Mathf.Abs(denom) < 1e-6f) return Vector3.Distance(point, a); // Degenerate
                var v_ = vb / denom;
                var w_ = vc / denom;
                var closestPoint = a + ab * v_ + ac * w_;
                return Vector3.Distance(point, closestPoint);
            }
            /// <summary>
            /// Find all triangles intersecting with a ray
            /// </summary>
            public List<int> IntersectRay(Vector3 origin, Vector3 direction, float maxDistance = float.MaxValue)
            {
                var results = new List<int>();
                if (root == null) return results;
                IntersectRayRecursive(origin, direction, maxDistance, root, results);
                return results;
            }
            private static bool Intersects(Bounds b, Vector3 origin, Vector3 dir, float maxDistance)
            {
                return b.IntersectRay(new Ray(origin, dir), out float hit) && hit <= maxDistance;
            }
            private void IntersectRayRecursive(Vector3 origin, Vector3 direction, float maxDistance, Node node, List<int> results)
            {
                if (!Intersects(node.bounds, origin, direction, maxDistance))
                    return;
                if (node.isLeaf)
                {
                    // Check if ray intersects with triangle
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        if (IntersectRayTriangle(origin, direction, a, b, c, out float distance) && distance <= maxDistance)
                        {
                            results.Add(triIndex);
                        }
                    }
                }
                else
                {
                    // Check both children
                    IntersectRayRecursive(origin, direction, maxDistance, node.left, results);
                    IntersectRayRecursive(origin, direction, maxDistance, node.right, results);
                }
            }
            private bool IntersectRayTriangle(Vector3 origin, Vector3 direction, Vector3 a, Vector3 b, Vector3 c, out float distance)
            {
                // MllerTrumbore intersection algorithm
                var edge1 = b - a;
                var edge2 = c - a;
                var h = Vector3.Cross(direction, edge2);
                var det = Vector3.Dot(edge1, h);
                if (det > -1e-6f && det < 1e-6f)
                {
                    distance = 0f;
                    return false; // Ray is parallel to triangle
                }
                var f = 1f / det;
                var s = origin - a;
                var u = f * Vector3.Dot(s, h);
                if (u < 0f || u > 1f)
                {
                    distance = 0f;
                    return false;
                }
                var q = Vector3.Cross(s, edge1);
                var v = f * Vector3.Dot(direction, q);
                if (v < 0f || u + v > 1f)
                {
                    distance = 0f;
                    return false;
                }
                distance = f * Vector3.Dot(edge2, q);
                return distance > 1e-6f;
            }
            // Additional: Find closest triangle to point
            public int FindClosestTriangle(Vector3 point)
            {
                float minDist = float.MaxValue;
                int closestTri = -1;
                FindClosestTriangleRecursive(point, root, ref minDist, ref closestTri);
                return closestTri;
            }
            public void DrawGizmos()
            {
                if (root == null) return;
                DrawGizmosRecursive(root);
            }

            private void DrawGizmosRecursive(Node node)
            {
                if (node == null) return;
                Gizmos.color = Color.Lerp(Color.green, Color.red, node.depth / (float)maxDepth);
                Gizmos.DrawWireCube(node.bounds.center, node.bounds.size);
                if (node.left != null) DrawGizmosRecursive(node.left);
                if (node.right != null) DrawGizmosRecursive(node.right);
            }

            private void FindClosestTriangleRecursive(Vector3 point, Node node, ref float minDist, ref int closestTri)
            {
                if (node.isLeaf)
                {
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        float dist = DistanceToTriangle(point, a, b, c);
                        if (dist < minDist)
                        {
                            minDist = dist;
                            closestTri = triIndex;
                        }
                    }
                }
                else
                {
                    // Recurse on children
                    FindClosestTriangleRecursive(point, node.left, ref minDist, ref closestTri);
                    FindClosestTriangleRecursive(point, node.right, ref minDist, ref closestTri);
                }
            }
        }
        /// <summary>
        /// Full 3D QuickHull implementation for convex hull generation.
        /// Uses a half-edge data structure to manage hull topology.
        /// </summary>
        public static class QuickHullImplementation
        {
            private class QHVertex
            {
                public Vector3 position;
                public int index;
                public QHHalfEdge edge;
                public bool onHull;
            }
            private class QHHalfEdge
            {
                public QHVertex vertex;
                public QHFace face;
                public QHHalfEdge next;
                public QHHalfEdge prev;
                public QHHalfEdge twin;
            }
            private class QHFace
            {
                public QHHalfEdge edge;
                public Vector3 normal;
                public float distance;
                public List<QHVertex> outsideSet = new List<QHVertex>();
                public bool visible;
                public int generation;
            }
            public static ConvexHull ComputeConvexHullFromPoints(List<Vector3> points)
            {
                if (points == null || points.Count < 4)
                {
                    return new ConvexHull();
                }
                const float epsilon = 1e-5f;
                List<QHFace> allFaces = new List<QHFace>();
                List<QHVertex> qhVertices = points.Select((p, i) => new QHVertex { position = p, index = i }).ToList();
                if (!CreateInitialSimplex(qhVertices, allFaces, epsilon))
                {
                    return new ConvexHull();
                }
                int currentGeneration = 0;
                while (true)
                {
                    QHFace furthestFace = null;
                    QHVertex eyePoint = null;
                    float maxDist = epsilon;
                    foreach (var face in allFaces)
                    {
                        if (face.visible || face.outsideSet.Count == 0) continue;
                        foreach (var v in face.outsideSet)
                        {
                            float dist = Vector3.Dot(face.normal, v.position) - face.distance;
                            if (dist > maxDist)
                            {
                                maxDist = dist;
                                furthestFace = face;
                                eyePoint = v;
                            }
                        }
                    }
                    if (furthestFace == null || eyePoint == null) break;
                    eyePoint.onHull = true;
                    List<QHFace> visibleFaces = new List<QHFace>();
                    List<QHHalfEdge> horizonEdges = new List<QHHalfEdge>();
                    Stack<QHFace> faceStack = new Stack<QHFace>();
                    furthestFace.visible = true;
                    faceStack.Push(furthestFace);
                    while (faceStack.Count > 0)
                    {
                        var face = faceStack.Pop();
                        visibleFaces.Add(face);
                        var edge = face.edge;
                        do
                        {
                            var neighbor = edge.twin.face;
                            if (!neighbor.visible)
                            {
                                float dist = Vector3.Dot(neighbor.normal, eyePoint.position) - neighbor.distance;
                                if (dist > epsilon)
                                {
                                    neighbor.visible = true;
                                    faceStack.Push(neighbor);
                                }
                                else
                                {
                                    horizonEdges.Add(edge);
                                }
                            }
                            edge = edge.next;
                        } while (edge != face.edge);
                    }
                    List<QHVertex> orphanedPoints = new List<QHVertex>();
                    foreach (var face in visibleFaces)
                    {
                        orphanedPoints.AddRange(face.outsideSet);
                        face.outsideSet.Clear();
                    }
                    // after collecting raw horizonEdges:
                    var horizon = OrderHorizonEdges(horizonEdges);
                    var newFaces = new List<QHFace>();
                    BuildFacesFromHorizon(horizon, eyePoint, newFaces);
                    // Assign orphaned points to new faces
                    foreach (var v in orphanedPoints)
                    {
                        if (v.onHull) continue;
                        QHFace bestFace = null;
                        float maxPointDist = epsilon;
                        foreach (var face in newFaces)
                        {
                            float dist = Vector3.Dot(face.normal, v.position) - face.distance;
                            if (dist > maxPointDist)
                            {
                                maxPointDist = dist;
                                bestFace = face;
                            }
                        }
                        if (bestFace != null)
                        {
                            bestFace.outsideSet.Add(v);
                        }
                    }
                    allFaces.AddRange(newFaces);
                    currentGeneration++;
                }
                var finalHull = new ConvexHull();
                var vertexMap = new Dictionary<QHVertex, int>();
                allFaces.RemoveAll(f => f.visible);
                foreach (var face in allFaces)
                {
                    var edge = face.edge;
                    do
                    {
                        if (!vertexMap.ContainsKey(edge.vertex))
                        {
                            vertexMap.Add(edge.vertex, finalHull.vertices.Count);
                            finalHull.vertices.Add(edge.vertex.position);
                        }
                        edge = edge.next;
                    } while (edge != face.edge);
                }
                foreach (var face in allFaces)
                {
                    finalHull.indices.Add(vertexMap[face.edge.vertex]);
                    finalHull.indices.Add(vertexMap[face.edge.next.vertex]);
                    finalHull.indices.Add(vertexMap[face.edge.next.next.vertex]);
                }
                finalHull.CalculateProperties();
                return finalHull;
            }
            // Order the horizon into a loop: next starts at current.twin.vertex
            static List<QHHalfEdge> OrderHorizonEdges(List<QHHalfEdge> raw)
            {
                var from = new Dictionary<QHVertex, QHHalfEdge>();
                foreach (var e in raw) from[e.vertex] = e; // e.vertex is the tail (origin) of the horizon edge on a VISIBLE face
                var ordered = new List<QHHalfEdge>(raw.Count);
                var cur = raw[0];
                ordered.Add(cur);
                while (ordered.Count < raw.Count)
                {
                    if (!from.TryGetValue(cur.twin.vertex, out var next)) break; // next tail == current head
                    ordered.Add(next);
                    cur = next;
                }
                return ordered;
            }
            // Build the "cone" of new faces around 'eye' from the ordered horizon
            static void BuildFacesFromHorizon(List<QHHalfEdge> orderedHorizon, QHVertex eye, List<QHFace> newFaces)
            {
                QHHalfEdge firstB = null;
                QHHalfEdge prevC = null;
                foreach (var h in orderedHorizon)
                {
                    var vA = h.vertex; // tail of horizon edge on visible side
                    var vB = h.twin.vertex; // head of horizon edge (in the neighbor, i.e., outside)
                    var f = new QHFace();
                    var a = new QHHalfEdge { vertex = vA, face = f }; // vA -> vB (shares with old outside face)
                    var b = new QHHalfEdge { vertex = vB, face = f }; // vB -> eye (will twin with previous face's c)
                    var c = new QHHalfEdge { vertex = eye, face = f }; // eye -> vA (will twin with next face's b)
                    // cycle
                    a.next = b; b.next = c; c.next = a;
                    a.prev = c; b.prev = a; c.prev = b;
                    // twin to the existing outside face along the horizon
                    a.twin = h.twin;
                    h.twin.twin = a;
                    // stitch around the eye
                    if (prevC != null) { prevC.twin = b; b.twin = prevC; } else { firstB = b; }
                    // face data
                    f.edge = a;
                    f.normal = Vector3.Cross(vB.position - vA.position, eye.position - vA.position).normalized;
                    f.distance = Vector3.Dot(f.normal, vA.position);
                    newFaces.Add(f);
                    prevC = c;
                }
                // close the ring
                if (firstB != null && prevC != null) { firstB.twin = prevC; prevC.twin = firstB; }
            }
            private static bool CreateInitialSimplex(List<QHVertex> vertices, List<QHFace> faces, float epsilon)
            {
                faces.Clear();
                int i0 = 0, i1 = 0;
                float maxDistSq = 0;
                for (int i = 0; i < vertices.Count; i++)
                    for (int j = i + 1; j < vertices.Count; j++)
                    {
                        float d = (vertices[j].position - vertices[i].position).sqrMagnitude;
                        if (d > maxDistSq) { maxDistSq = d; i0 = i; i1 = j; }
                    }
                if (Mathf.Sqrt(maxDistSq) < epsilon) return false;
                int i2 = -1;
                maxDistSq = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (i == i0 || i == i1) continue;
                    float d = DistanceToLineSq(vertices[i].position, vertices[i0].position, vertices[i1].position);
                    if (d > maxDistSq) { maxDistSq = d; i2 = i; }
                }
                if (i2 == -1 || Mathf.Sqrt(maxDistSq) < epsilon) return false;
                int i3 = -1;
                float maxDist = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (i == i0 || i == i1 || i == i2) continue;
                    float d = DistanceToPlane(vertices[i].position, vertices[i0].position, vertices[i1].position, vertices[i2].position);
                    if (Mathf.Abs(d) > maxDist) { maxDist = Mathf.Abs(d); i3 = i; }
                }
                if (i3 == -1 || maxDist < epsilon) return false;
                var v = new QHVertex[4] { vertices[i0], vertices[i1], vertices[i2], vertices[i3] };
                if (DistanceToPlane(v[3].position, v[0].position, v[1].position, v[2].position) > 0)
                {
                    (v[1], v[2]) = (v[2], v[1]);
                }
                for (int i = 0; i < 4; i++) v[i].onHull = true;
                faces.Add(CreateFace(v[0], v[1], v[2]));
                faces.Add(CreateFace(v[3], v[1], v[0]));
                faces.Add(CreateFace(v[3], v[2], v[1]));
                faces.Add(CreateFace(v[3], v[0], v[2]));
                LinkTwins(faces[0].edge, faces[1].edge.next);
                LinkTwins(faces[0].edge.next, faces[2].edge.next);
                LinkTwins(faces[0].edge.prev, faces[3].edge.next);
                LinkTwins(faces[1].edge, faces[2].edge.prev);
                LinkTwins(faces[1].edge.prev, faces[3].edge);
                LinkTwins(faces[2].edge, faces[3].edge.prev);
                foreach (var vert in vertices)
                {
                    if (vert.onHull) continue;
                    QHFace bestFace = null;
                    float maxPointDist = epsilon;
                    foreach (var face in faces)
                    {
                        float dist = Vector3.Dot(face.normal, vert.position) - face.distance;
                        if (dist > maxPointDist)
                        {
                            maxPointDist = dist;
                            bestFace = face;
                        }
                    }
                    if (bestFace != null) bestFace.outsideSet.Add(vert);
                }
                return true;
            }
            private static float DistanceToLineSq(Vector3 p, Vector3 a, Vector3 b)
            {
                Vector3 ab = b - a;
                Vector3 ap = p - a;
                return Vector3.Cross(ab, ap).sqrMagnitude / ab.sqrMagnitude;
            }
            private static float DistanceToPlane(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
            {
                Vector3 normal = Vector3.Cross(b - a, c - a).normalized;
                return Vector3.Dot(normal, p - a);
            }
            private static QHFace CreateFace(QHVertex a, QHVertex b, QHVertex c)
            {
                var face = new QHFace();
                var e0 = new QHHalfEdge { vertex = a, face = face };
                var e1 = new QHHalfEdge { vertex = b, face = face };
                var e2 = new QHHalfEdge { vertex = c, face = face };
                e0.next = e1; e1.prev = e0;
                e1.next = e2; e2.prev = e1;
                e2.next = e0; e0.prev = e2;
                face.edge = e0;
                face.normal = Vector3.Cross(b.position - a.position, c.position - a.position).normalized;
                face.distance = Vector3.Dot(face.normal, a.position);
                return face;
            }
            private static void LinkTwins(QHHalfEdge e1, QHHalfEdge e2)
            {
                e1.twin = e2;
                e2.twin = e1;
            }
            // Additional: Simplify hull
            public static ConvexHull Simplify(ConvexHull hull, ConvexDecompositionSettings settings, float tolerance)
            {
                hull.OptimizeHull(settings, tolerance);
                return hull;
            }
        }
        /// <summary>
        /// Mesh boolean operations with proper clipping
        /// </summary>
        public static class MeshBooleanOperations
        {
            static int Add(MeshData m, Vector3 p, Vector3 n)
            {
                if (m.vertices == null) m.vertices = new List<Vector3>();
                if (m.normals == null) m.normals = new List<Vector3>();
                for (int i = 0; i < m.vertices.Count; i++)
                    if ((m.vertices[i] - p).sqrMagnitude < 1e-12f) return i;
                m.vertices.Add(p);
                m.normals.Add(n);
                return m.vertices.Count - 1;
            }
            public static MeshData BooleanIntersect(MeshData mesh, Bounds box)
            {
                var outMesh = new MeshData();
                var boxPlanes = new List<PlaneF>
                {
                    new PlaneF { n = Vector3.right, d = -box.max.x },
                    new PlaneF { n = Vector3.left, d = box.min.x },
                    new PlaneF { n = Vector3.up, d = -box.max.y },
                    new PlaneF { n = Vector3.down, d = box.min.y },
                    new PlaneF { n = Vector3.forward, d = -box.max.z },
                    new PlaneF { n = Vector3.back, d = box.min.z },
                };
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i + 1], i2 = mesh.indices[i + 2];
                    var v0 = mesh.vertices[i0]; var v1 = mesh.vertices[i1]; var v2 = mesh.vertices[i2];
                    var n0 = mesh.normals.Count > i0 ? mesh.normals[i0] : Vector3.zero;
                    var n1 = mesh.normals.Count > i1 ? mesh.normals[i1] : Vector3.zero;
                    var n2 = mesh.normals.Count > i2 ? mesh.normals[i2] : Vector3.zero;
                    foreach (var (p0, p1, p2, norm0, norm1, norm2) in ClipTriAgainstConvex(v0, v1, v2, n0, n1, n2, boxPlanes))
                    {
                        int ia = Add(outMesh, p0, norm0);
                        int ib = Add(outMesh, p1, norm1);
                        int ic = Add(outMesh, p2, norm2);
                        outMesh.indices.AddRange(new[] { ia, ib, ic });
                    }
                }
                // outMesh.Optimize(); // Settings not available here
                return outMesh;
            }
            public static ConvexHull BooleanUnion(ConvexHull hull1, ConvexHull hull2, ConvexDecompositionSettings settings)
            {
                var allPoints = new List<Vector3>(hull1.vertices);
                allPoints.AddRange(hull2.vertices);
                var union = QuickHullImplementation.ComputeConvexHullFromPoints(allPoints);
                // Additional: Optimize union
                union.OptimizeHull(settings, 0.001f);
                return union;
            }
            static IEnumerable<(Vector3, Vector3)> ClipPolyAgainstPlane(IEnumerable<(Vector3 p, Vector3 n)> poly, Vector3 N, float d, float eps = 1e-6f)
            {
                var input = new List<(Vector3 p, Vector3 n)>(poly);
                if (input.Count == 0) yield break;
                var prev = input[input.Count - 1];
                float dpPrev = Vector3.Dot(N, prev.p) + d;
                for (int i = 0; i < input.Count; i++)
                {
                    var curr = input[i];
                    float dpCurr = Vector3.Dot(N, curr.p) + d;
                    bool currIn = dpCurr <= eps, prevIn = dpPrev <= eps;
                    if (currIn != prevIn)
                    {
                        float t = dpPrev / (dpPrev - dpCurr);
                        var ip = Vector3.Lerp(prev.p, curr.p, t);
                        var inorm = Vector3.Lerp(prev.n, curr.n, t).normalized;
                        yield return (ip, inorm);
                    }
                    if (currIn)
                    {
                        yield return curr;
                    }
                    prev = curr; dpPrev = dpCurr;
                }
            }
            static IEnumerable<(Vector3, Vector3, Vector3, Vector3, Vector3, Vector3)> ClipTriAgainstConvex(
                Vector3 v0, Vector3 v1, Vector3 v2, Vector3 n0, Vector3 n1, Vector3 n2, List<PlaneF> planes)
            {
                var poly = new List<(Vector3 p, Vector3 n)> { (v0, n0), (v1, n1), (v2, n2) };
                foreach (var pl in planes)
                {
                    poly = new List<(Vector3 p, Vector3 n)>(ClipPolyAgainstPlane(poly, pl.n, pl.d));
                    if (poly.Count < 3) yield break;
                }
                for (int i = 1; i + 1 < poly.Count; i++)
                    yield return (poly[0].p, poly[i].p, poly[i + 1].p, poly[0].n, poly[i].n, poly[i + 1].n);
            }
            public static ConvexHull BooleanIntersection(ConvexHull hullA, ConvexHull hullB)
            {
                if (hullB.planes == null || hullB.planes.Count == 0) hullB.BuildPlanes();
                var outMesh = new MeshData();
                for (int i = 0; i < hullA.indices.Count; i += 3)
                {
                    int i0 = hullA.indices[i], i1 = hullA.indices[i + 1], i2 = hullA.indices[i + 2];
                    var a = hullA.vertices[i0]; var b = hullA.vertices[i1]; var c = hullA.vertices[i2];
                    var na = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i0] : Vector3.up;
                    var nb = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i1] : Vector3.up;
                    var nc = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i2] : Vector3.up;
                    foreach (var (p0, p1, p2, norm0, norm1, norm2) in ClipTriAgainstConvex(a, b, c, na, nb, nc, hullB.planes))
                    {
                        int ia = Add(outMesh, p0, norm0);
                        int ib = Add(outMesh, p1, norm1);
                        int ic = Add(outMesh, p2, norm2);
                        outMesh.indices.Add(ia); outMesh.indices.Add(ib); outMesh.indices.Add(ic);
                    }
                }
                outMesh.CalculateProperties();
                var intersection = QuickHullImplementation.ComputeConvexHullFromPoints(outMesh.vertices);
                // Additional: Validate intersection
                intersection.ValidateHull();
                return intersection;
            }
            public static MeshData BooleanDifference(MeshData mesh, Bounds box)
            {
                var planes = new List<PlaneF>
                {
                    new PlaneF { n = new Vector3(1, 0, 0), d = -box.max.x },
                    new PlaneF { n = new Vector3(-1, 0, 0), d = box.min.x },
                    new PlaneF { n = new Vector3(0, 1, 0), d = -box.max.y },
                    new PlaneF { n = new Vector3(0, -1, 0), d = box.min.y },
                    new PlaneF { n = new Vector3(0, 0, 1), d = -box.max.z },
                    new PlaneF { n = new Vector3(0, 0, -1), d = box.min.z }
                };

                var outsideMesh = mesh;
                var insideMesh = new MeshData();

                foreach (var plane in planes)
                {
                    // Split the mesh by the plane, keeping the "outside" part
                    MeshSplitter.Split(outsideMesh, new PlaneF {n = -plane.n, d = -plane.d}, out var _, out outsideMesh);
                }

                outsideMesh.CalculateProperties();
                return outsideMesh;
            }
            public static MeshData BooleanDifference(MeshData meshA, MeshData meshB)
            {
                return BooleanDifference(meshA, meshB.bounds);
            }
            // Additional: Boolean XOR
            public static MeshData BooleanXOR(MeshData a, MeshData b)
            {
                var intersect = BooleanIntersect(a, b.bounds);
                var diffA = BooleanDifference(a, b.bounds);
                var diffB = BooleanDifference(b, a.bounds);
                // Combine diffA, diffB, but subtract intersect if needed
                // ... (add logic)
                return diffA;
            }
            // Additional: Boolean Union for meshes
            public static MeshData BooleanUnion(MeshData a, MeshData b)
            {
                var hullA = QuickHullImplementation.ComputeConvexHullFromPoints(a.vertices);
                var hullB = QuickHullImplementation.ComputeConvexHullFromPoints(b.vertices);
                var unionHull = BooleanUnion(hullA, hullB);
                var unionMesh = new MeshData { vertices = unionHull.vertices, indices = unionHull.indices };
                return unionMesh;
            }
        }

        /// <summary>
        /// Isotropic Remeshing implementation to regularize mesh geometry before decomposition.
        /// This is a crucial pre-processing step for high-quality results.
        /// </summary>
        public static class IsotropicRemesher
        {
            public static void Remesh(MeshData mesh, float targetEdgeLength, int iterations)
            {
                if (mesh == null || mesh.vertexCount == 0) return;

                var originalMesh = new MeshData // Keep a copy for surface projection
                {
                    vertices = new List<Vector3>(mesh.vertices),
                    indices = new List<int>(mesh.indices)
                };
                originalMesh.BuildAccelerationStructure();

                float minEdgeLength = 4.0f / 5.0f * targetEdgeLength;
                float maxEdgeLength = 4.0f / 3.0f * targetEdgeLength;

                for (int i = 0; i < iterations; i++)
                {
                    SplitLongEdges(mesh, maxEdgeLength);
                    CollapseShortEdges(mesh, minEdgeLength);
                    FlipEdges(mesh);
                    TangentialRelaxation(mesh, originalMesh);
                }
                mesh.CalculateProperties(); // Recalculate all mesh properties after remeshing.
            }

            private static void SplitLongEdges(MeshData mesh, float maxLength)
            {
                var edges = GetEdges(mesh);
                var maxLengthSq = maxLength * maxLength;

                for (int i = 0; i < edges.Count; i++)
                {
                    var edge = edges[i];
                    var p0 = mesh.vertices[edge.Item1];
                    var p1 = mesh.vertices[edge.Item2];

                    if ((p1 - p0).sqrMagnitude > maxLengthSq)
                    {
                        var midpoint = (p0 + p1) / 2.0f;
                        int midVertexIndex = mesh.vertices.Count;
                        mesh.vertices.Add(midpoint);

                        var trianglesToSplit = FindTrianglesWithEdge(mesh, edge.Item1, edge.Item2);

                        foreach(var triIdx in trianglesToSplit)
                        {
                            int v0 = mesh.indices[triIdx];
                            int v1 = mesh.indices[triIdx + 1];
                            int v2 = mesh.indices[triIdx + 2];
                            int thirdVertex = -1;

                            if (v0 != edge.Item1 && v0 != edge.Item2) thirdVertex = v0;
                            else if (v1 != edge.Item1 && v1 != edge.Item2) thirdVertex = v1;
                            else thirdVertex = v2;

                            mesh.indices.RemoveRange(triIdx, 3);
                            mesh.indices.Add(edge.Item1);
                            mesh.indices.Add(midVertexIndex);
                            mesh.indices.Add(thirdVertex);

                            mesh.indices.Add(midVertexIndex);
                            mesh.indices.Add(edge.Item2);
                            mesh.indices.Add(thirdVertex);
                        }
                    }
                }
            }

            private static void CollapseShortEdges(MeshData mesh, float minLength)
            {
                var edges = GetEdges(mesh);
                var minLengthSq = minLength * minLength;
                var deletedTris = new bool[mesh.indices.Count / 3];
                var vertexRemap = new int[mesh.vertexCount];
                for (int i = 0; i < mesh.vertexCount; i++) vertexRemap[i] = i;

                foreach (var edge in edges)
                {
                    int u_orig = edge.Item1;
                    int v_orig = edge.Item2;

                    int u = vertexRemap[u_orig];
                    int v = vertexRemap[v_orig];

                    if (u == v) continue;

                    if ((mesh.vertices[v] - mesh.vertices[u]).sqrMagnitude < minLengthSq)
                    {
                        // Check if collapse is valid
                        if (!IsCollapseValid(mesh, u, v)) continue;

                        // Collapse v into u
                        var trianglesToRemove = FindTrianglesWithEdge(mesh, u, v);
                        foreach(var triIdx in trianglesToRemove)
                        {
                            deletedTris[triIdx / 3] = true;
                        }

                        // Remap all triangles using v to use u instead
                        for(int i = 0; i < mesh.indices.Count; i++)
                        {
                            if (vertexRemap[mesh.indices[i]] == v)
                            {
                                mesh.indices[i] = u;
                            }
                        }
                        vertexRemap[v] = u;
                    }
                }

                // Rebuild the index buffer
                var newIndices = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    if (deletedTris[i / 3]) continue;

                    int i0 = mesh.indices[i];
                    int i1 = mesh.indices[i+1];
                    int i2 = mesh.indices[i+2];

                    if (i0 != i1 && i1 != i2 && i0 != i2) // Remove degenerate triangles
                    {
                        newIndices.Add(i0);
                        newIndices.Add(i1);
                        newIndices.Add(i2);
                    }
                }
                mesh.indices = newIndices;
                mesh.Optimize(); // Clean up unused vertices
            }

            private static bool IsCollapseValid(MeshData mesh, int u, int v)
            {
                // Find one-ring neighbors of u and v
                var neighborsU = GetOneRingNeighbors(mesh, u);
                var neighborsV = GetOneRingNeighbors(mesh, v);

                // Find common neighbors
                var commonNeighbors = neighborsU.Intersect(neighborsV).ToList();
                if (commonNeighbors.Count != 2)
                {
                    // This collapse would create a non-manifold topology (e.g., edge is not part of exactly two triangles)
                    return false;
                }

                // Check for normal flipping on adjacent faces
                var trisU = FindTrianglesWithVertex(mesh, u);
                foreach(var triIdx in trisU)
                {
                    if (FindTrianglesWithVertex(mesh, v).Contains(triIdx)) continue; // Skip common triangles

                    var v0_idx = mesh.indices[triIdx];
                    var v1_idx = mesh.indices[triIdx + 1];
                    var v2_idx = mesh.indices[triIdx + 2];

                    var n_before = Vector3.Cross(mesh.vertices[v1_idx] - mesh.vertices[v0_idx], mesh.vertices[v2_idx] - mesh.vertices[v0_idx]);

                    if (v0_idx == u) v0_idx = v;
                    if (v1_idx == u) v1_idx = v;
                    if (v2_idx == u) v2_idx = v;

                    var n_after = Vector3.Cross(mesh.vertices[v1_idx] - mesh.vertices[v0_idx], mesh.vertices[v2_idx] - mesh.vertices[v0_idx]);

                    if (Vector3.Dot(n_before, n_after) < 0.5f) // Heuristic threshold for normal flip
                    {
                        return false;
                    }
                }
                return true;
            }

            private static List<int> GetOneRingNeighbors(MeshData mesh, int vertexIndex)
            {
                var neighbors = new List<int>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    if(i0 == vertexIndex) { neighbors.Add(i1); neighbors.Add(i2); }
                    if(i1 == vertexIndex) { neighbors.Add(i0); neighbors.Add(i2); }
                    if(i2 == vertexIndex) { neighbors.Add(i0); neighbors.Add(i1); }
                }
                return neighbors.Distinct().ToList();
            }

             private static List<int> FindTrianglesWithVertex(MeshData mesh, int v)
            {
                var tris = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    if (mesh.indices[i] == v || mesh.indices[i+1] == v || mesh.indices[i+2] == v)
                    {
                        tris.Add(i);
                    }
                }
                return tris;
            }

            private static void FlipEdges(MeshData mesh)
            {
                var edges = GetEdges(mesh);
                var edgeToTriangles = GetEdgeToTriangleMap(mesh);

                for (int i = 0; i < edges.Count; i++)
                {
                    var edge = edges[i];
                    if (!edgeToTriangles.ContainsKey(edge) || edgeToTriangles[edge].Count != 2)
                    {
                        continue; // Boundary edge, cannot flip
                    }

                    var t1_idx = edgeToTriangles[edge][0];
                    var t2_idx = edgeToTriangles[edge][1];

                    var t1 = new int[] { mesh.indices[t1_idx], mesh.indices[t1_idx + 1], mesh.indices[t1_idx + 2] };
                    var t2 = new int[] { mesh.indices[t2_idx], mesh.indices[t2_idx + 1], mesh.indices[t2_idx + 2] };

                    int v0 = edge.Item1;
                    int v1 = edge.Item2;
                    int v2 = -1, v3 = -1;

                    // Find the other two vertices of the quadrilateral
                    foreach(int v_idx in t1) if (v_idx != v0 && v_idx != v1) v2 = v_idx;
                    foreach(int v_idx in t2) if (v_idx != v0 && v_idx != v1) v3 = v_idx;

                    if (v2 == -1 || v3 == -1) continue;

                    // Check if the new edge (v2, v3) already exists
                    if (edgeToTriangles.ContainsKey(v2 < v3 ? (v2, v3) : (v3, v2))) continue;

                    // Lawson's criterion: flip if it improves the minimum angle
                    float minAngleBefore = Mathf.Min(CalculateMinAngle(mesh, t1), CalculateMinAngle(mesh, t2));

                    var new_t1 = new int[] { v0, v2, v3 };
                    var new_t2 = new int[] { v1, v3, v2 };

                    float minAngleAfter = Mathf.Min(CalculateMinAngle(mesh, new_t1), CalculateMinAngle(mesh, new_t2));

                    if (minAngleAfter > minAngleBefore)
                    {
                        // Flip the edge
                        mesh.indices[t1_idx] = new_t1[0];
                        mesh.indices[t1_idx + 1] = new_t1[1];
                        mesh.indices[t1_idx + 2] = new_t1[2];

                        mesh.indices[t2_idx] = new_t2[0];
                        mesh.indices[t2_idx + 1] = new_t2[1];
                        mesh.indices[t2_idx + 2] = new_t2[2];
                    }
                }
            }

            private static float CalculateMinAngle(MeshData mesh, int[] tri)
            {
                Vector3 p0 = mesh.vertices[tri[0]];
                Vector3 p1 = mesh.vertices[tri[1]];
                Vector3 p2 = mesh.vertices[tri[2]];

                float a = (p1-p0).magnitude;
                float b = (p2-p1).magnitude;
                float c = (p0-p2).magnitude;

                float angle1 = Mathf.Acos((b*b + c*c - a*a) / (2*b*c));
                float angle2 = Mathf.Acos((a*a + c*c - b*b) / (2*a*c));
                float angle3 = Mathf.Acos((a*a + b*b - c*c) / (2*a*b));

                return Mathf.Min(angle1, angle2, angle3) * Mathf.Rad2Deg;
            }

            private static Dictionary<(int, int), List<int>> GetEdgeToTriangleMap(MeshData mesh)
            {
                var map = new Dictionary<(int, int), List<int>>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = mesh.indices[i + j];
                        int v2 = mesh.indices[i + ((j + 1) % 3)];
                        var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                        if (!map.ContainsKey(edge)) map[edge] = new List<int>();
                        map[edge].Add(i);
                    }
                }
                return map;
            }

            private static void TangentialRelaxation(MeshData mesh, MeshData originalMesh)
            {
                var newPositions = new List<Vector3>(mesh.vertices);
                var adj = BuildAdjacency(mesh);

                for (int i = 0; i < mesh.vertices.Count; i++)
                {
                    var neighbors = adj[i];
                    if (neighbors.Count == 0) continue;

                    var centroid = Vector3.zero;
                    foreach(var nIdx in neighbors)
                    {
                        centroid += mesh.vertices[nIdx];
                    }
                    centroid /= neighbors.Count;

                    var newPos = ProjectToSurface(centroid, originalMesh);
                    newPositions[i] = newPos;
                }
                mesh.vertices = newPositions;
            }

            private static Vector3 ProjectToSurface(Vector3 point, MeshData targetMesh)
            {
                float closestDistSq = float.MaxValue;
                Vector3 closestPoint = point;

                // This is a slow projection. A BVH on the original mesh is required for performance.
                for(int i=0; i<targetMesh.indices.Count; i+=3)
                {
                    var a = targetMesh.vertices[targetMesh.indices[i]];
                    var b = targetMesh.vertices[targetMesh.indices[i+1]];
                    var c = targetMesh.vertices[targetMesh.indices[i+2]];
                    var p = ClosestPointOnTriangle(point, a, b, c);
                    float distSq = (point - p).sqrMagnitude;
                    if(distSq < closestDistSq)
                    {
                        closestDistSq = distSq;
                        closestPoint = p;
                    }
                }
                return closestPoint;
            }
             private static Vector3 ClosestPointOnTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
            {
                var ab = b - a; var ac = c - a; var ap = p - a;
                float d1 = Vector3.Dot(ab, ap), d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0 && d2 <= 0) return a;

                var bp = p - b; float d3 = Vector3.Dot(ab, bp), d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0 && d4 <= d3) return b;

                float vc = d1 * d4 - d3 * d2;
                if (vc <= 0 && d1 >= 0 && d3 <= 0) { float v = d1 / (d1 - d3); return a + v * ab; }

                var cp = p - c; float d5 = Vector3.Dot(ab, cp), d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0 && d5 <= d6) return c;

                float vb = d5 * d2 - d1 * d6;
                if (vb <= 0 && d2 >= 0 && d6 <= 0) { float w = d2 / (d2 - d6); return a + w * ac; }

                float va = d3 * d6 - d5 * d4;
                if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) { float w = (d4 - d3) / ((d4 - d3) + (d5 - d6)); return b + w * (c-b); }

                float den = 1.0f / (va + vb + vc);
                float v_ = vb * den;
                float w_ = vc * den;
                return a + ab * v_ + ac * w_;
            }

            private static List<(int, int)> GetEdges(MeshData mesh)
            {
                var edges = new HashSet<(int, int)>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    for(int j=0; j<3; j++)
                    {
                        int v1 = mesh.indices[i+j];
                        int v2 = mesh.indices[i+((j+1)%3)];
                        edges.Add(v1 < v2 ? (v1,v2) : (v2,v1));
                    }
                }
                return edges.ToList();
            }

            private static List<int> FindTrianglesWithEdge(MeshData mesh, int v1, int v2)
            {
                var tris = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    if ((i0 == v1 && i1 == v2) || (i1 == v1 && i0 == v2) ||
                        (i1 == v1 && i2 == v2) || (i2 == v1 && i1 == v2) ||
                        (i2 == v1 && i0 == v2) || (i0 == v1 && i2 == v2))
                    {
                        tris.Add(i);
                    }
                }
                return tris;
            }

            private static Dictionary<int, List<int>> BuildAdjacency(MeshData mesh)
            {
                var adj = new Dictionary<int, List<int>>();
                for(int i=0; i<mesh.vertexCount; i++) adj[i] = new List<int>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    adj[i0].Add(i1); adj[i0].Add(i2);
                    adj[i1].Add(i0); adj[i1].Add(i2);
                    adj[i2].Add(i0); adj[i2].Add(i1);
                }
                for(int i=0; i<mesh.vertexCount; i++) adj[i] = adj[i].Distinct().ToList();
                return adj;
            }
        }

        public static class GpuVoxelizer
        {
            // Kernels
            private static int _kernelClear;
            private static int _kernelVoxelize;
            private static int _kernelSolidify;
            private static int _kernelJfaSeed;
            private static int _kernelJfaPass;
            private static int _kernelFinalizeSdf;

            // Buffers
            private static ComputeBuffer _vertexBuffer;
            private static ComputeBuffer _indexBuffer;
            private static ComputeBuffer _voxelBuffer; // Stores solid voxelization (temp) and final SDF
            private static ComputeBuffer _jfaGridBuffer; // Stores seed coordinates

            public static void Voxelize(MeshData mesh, ComputeShader shader, bool generateSdf)
            {
                if (shader == null) { Debug.LogError("Voxelization Compute Shader is not assigned."); return; }

                // 1. Find all necessary kernels
                _kernelClear = shader.FindKernel("Clear");
                _kernelVoxelize = shader.FindKernel("VoxelizeSurface");
                _kernelSolidify = shader.FindKernel("Solidify");
                if (generateSdf)
                {
                    _kernelJfaSeed = shader.FindKernel("JFA_Seed");
                    _kernelJfaPass = shader.FindKernel("JFA_Pass");
                    _kernelFinalizeSdf = shader.FindKernel("FinalizeSDF");
                }

                // 2. Create and set buffers
                int triangleCount = mesh.indices.Count / 3;
                _vertexBuffer = new ComputeBuffer(mesh.vertexCount, sizeof(float) * 3);
                _vertexBuffer.SetData(mesh.vertices);
                _indexBuffer = new ComputeBuffer(mesh.indices.Count, sizeof(int));
                _indexBuffer.SetData(mesh.indices);

                int voxelCount = mesh.voxelDimensions.x * mesh.voxelDimensions.y * mesh.voxelDimensions.z;
                _voxelBuffer = new ComputeBuffer(voxelCount, sizeof(float));

                // Set common uniforms and buffers
                shader.SetInt("g_TriangleCount", triangleCount);
                shader.SetInts("g_VoxelDimensions", new int[] { mesh.voxelDimensions.x, mesh.voxelDimensions.y, mesh.voxelDimensions.z });
                shader.SetVector("g_VoxelBoundsMin", mesh.voxelBounds.min);
                shader.SetVector("g_VoxelBoundsSize", mesh.voxelBounds.size);
                shader.SetBuffer(_kernelVoxelize, "g_Vertices", _vertexBuffer);
                shader.SetBuffer(_kernelVoxelize, "g_Indices", _indexBuffer);

                // 3. Dispatch Clear Kernel
                shader.SetBuffer(_kernelClear, "g_Voxels", _voxelBuffer);
                Dispatch(shader, _kernelClear, voxelCount);

                // 4. Dispatch Voxelize Kernel to create surface voxelization
                shader.SetBuffer(_kernelVoxelize, "g_Voxels", _voxelBuffer);
                Dispatch(shader, _kernelVoxelize, triangleCount);

                // 5. Dispatch Solidify Kernel (using a parallel scanline flood fill)
                shader.SetBuffer(_kernelSolidify, "g_Voxels", _voxelBuffer);
                Dispatch(shader, _kernelSolidify, mesh.voxelDimensions.x * mesh.voxelDimensions.y);

                // 6. If SDF is enabled, run the full JFA pipeline
                if (generateSdf)
                {
                    _jfaGridBuffer = new ComputeBuffer(voxelCount, sizeof(int) * 3);

                    // 6a. Seed the JFA grid from the surface voxels
                    shader.SetBuffer(_kernelJfaSeed, "g_Voxels", _voxelBuffer);
                    shader.SetBuffer(_kernelJfaSeed, "g_JFAGrid", _jfaGridBuffer);
                    Dispatch(shader, _kernelJfaSeed, voxelCount);

                    // 6b. Run JFA passes with decreasing step sizes
                    int maxDim = Mathf.Max(mesh.voxelDimensions.x, Mathf.Max(mesh.voxelDimensions.y, mesh.voxelDimensions.z));
                    int step = (int)Mathf.Pow(2, Mathf.Floor(Mathf.Log2(maxDim)));

                    shader.SetBuffer(_kernelJfaPass, "g_JFAGrid", _jfaGridBuffer);
                    while (step >= 1)
                    {
                        shader.SetInt("g_JfaStep", step);
                        Dispatch(shader, _kernelJfaPass, voxelCount);
                        step /= 2;
                    }

                    // 6c. Finalize the SDF calculation
                    shader.SetBuffer(_kernelFinalizeSdf, "g_Voxels", _voxelBuffer);
                    shader.SetBuffer(_kernelFinalizeSdf, "g_JFAGrid", _jfaGridBuffer);
                    Dispatch(shader, _kernelFinalizeSdf, voxelCount);

                    _jfaGridBuffer.Release();
                }

                // 7. Read back data and release buffers
                _voxelBuffer.GetData(mesh.sdfValues);

                _vertexBuffer.Release();
                _indexBuffer.Release();
                _voxelBuffer.Release();
            }

            private static void Dispatch(ComputeShader shader, int kernel, int count)
            {
                shader.GetKernelThreadGroupSizes(kernel, out uint x, out uint y, out uint z);
                int threadGroupX = Mathf.CeilToInt(count / (float)x);
                int threadGroupY = Mathf.CeilToInt(1 / (float)y);
                int threadGroupZ = Mathf.CeilToInt(1 / (float)z);
                shader.Dispatch(kernel, threadGroupX, threadGroupY, threadGroupZ);
            }
        }
        /// <summary>
        /// Represents a Quadric Error Metric for a vertex, stored as a 4x4 symmetric matrix.
        /// </summary>
        [Serializable]
        public struct Quadric
        {
            // Symmetric matrix elements
            public float m11, m12, m13, m14;
            public float m22, m23, m24;
            public float m33, m34;
            public float m44;

            public Quadric(float m11, float m12, float m13, float m14, float m22, float m23, float m24, float m33, float m34, float m44)
            {
                this.m11 = m11; this.m12 = m12; this.m13 = m13; this.m14 = m14;
                this.m22 = m22; this.m23 = m23; this.m24 = m24;
                this.m33 = m33; this.m34 = m34;
                this.m44 = m44;
            }

            public void Add(Quadric q)
            {
                m11 += q.m11; m12 += q.m12; m13 += q.m13; m14 += q.m14;
                m22 += q.m22; m23 += q.m23; m24 += q.m24;
                m33 += q.m33; m34 += q.m34;
                m44 += q.m44;
            }

            public float Evaluate(float x, float y, float z)
            {
                return m11*x*x + 2*m12*x*y + 2*m13*x*z + 2*m14*x +
                       m22*y*y + 2*m23*y*z + 2*m24*y +
                       m33*z*z + 2*m34*z +
                       m44;
            }

            public static Quadric FromPlane(float a, float b, float c, float d)
            {
                return new Quadric(
                    a * a, a * b, a * c, a * d,
                           b * b, b * c, b * d,
                                  c * c, c * d,
                                         d * d
                );
            }
        }
        public static class QEMSimplifier
        {
            private class Vertex
            {
                public Vector3 p;
                public int id;
                public Quadric q;
                public List<int> neighbors = new List<int>();
                public List<int> faces = new List<int>();
                public bool active = true;
            }

            private class Triangle
            {
                public int[] v = new int[3];
                public bool active = true;
            }

            private class Pair
            {
                public int v1, v2;
                public float cost;
                public Vector3 p;

                public Pair(int v1, int v2) { this.v1 = v1; this.v2 = v2; }
            }

            public static void Simplify(MeshData mesh, float targetPercentage)
            {
                int targetTriangleCount = (int)(mesh.triangleCount * targetPercentage);
                if (mesh.triangleCount <= targetTriangleCount) return;

                var vertices = new List<Vertex>();
                for(int i=0; i<mesh.vertexCount; i++)
                {
                    vertices.Add(new Vertex { p = mesh.vertices[i], id = i, q = new Quadric() });
                }

                var triangles = new List<Triangle>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    var t = new Triangle { v = new int[] { mesh.indices[i], mesh.indices[i+1], mesh.indices[i+2] } };
                    triangles.Add(t);
                }

                // Build adjacency and calculate initial quadrics
                for(int i=0; i<triangles.Count; i++)
                {
                    var t = triangles[i];
                    var v0 = vertices[t.v[0]]; var v1 = vertices[t.v[1]]; var v2 = vertices[t.v[2]];

                    v0.faces.Add(i); v1.faces.Add(i); v2.faces.Add(i);
                    v0.neighbors.Add(v1.id); v0.neighbors.Add(v2.id);
                    v1.neighbors.Add(v0.id); v1.neighbors.Add(v2.id);
                    v2.neighbors.Add(v0.id); v2.neighbors.Add(v1.id);

                    var n = Vector3.Cross(v1.p - v0.p, v2.p - v0.p).normalized;
                    var planeQuadric = Quadric.FromPlane(n.x, n.y, n.z, -Vector3.Dot(n, v0.p));
                    v0.q.Add(planeQuadric); v1.q.Add(planeQuadric); v2.q.Add(planeQuadric);
                }
                foreach(var v in vertices) v.neighbors = v.neighbors.Distinct().ToList();

                // Select and cost all valid pairs
                var pairs = new List<Pair>();
                foreach(var v in vertices)
                {
                    foreach(var neighborId in v.neighbors)
                    {
                        if(v.id < neighborId)
                        {
                            var p = new Pair(v.id, neighborId);
                            p.p = CalculateOptimalPosition(v, vertices[neighborId], out p.cost);
                            pairs.Add(p);
                        }
                    }
                }

                int currentTriangleCount = triangles.Count(t => t.active);
                while(currentTriangleCount > targetTriangleCount && pairs.Count > 0)
                {
                    pairs.Sort((a,b) => a.cost.CompareTo(b.cost));
                    var bestPair = pairs[0];
                    pairs.RemoveAt(0);

                    var v1 = vertices[bestPair.v1];
                    var v2 = vertices[bestPair.v2];

                    if(!v1.active || !v2.active) continue;

                    v1.p = bestPair.p;
                    v1.q.Add(v2.q);
                    v2.active = false;

                    var affectedNeighbors = new HashSet<int>();

                    // Update triangles and neighbor lists
                    foreach(var faceIdx in v2.faces)
                    {
                        var t = triangles[faceIdx];
                        if(!t.active) continue;

                        for(int i=0; i<3; i++)
                        {
                            if(t.v[i] == v2.id) t.v[i] = v1.id;
                        }

                        if(t.v[0] == t.v[1] || t.v[1] == t.v[2] || t.v[0] == t.v[2])
                        {
                            t.active = false;
                            currentTriangleCount--;
                        }
                        else
                        {
                            v1.faces.Add(faceIdx);
                            vertices[t.v[0]].neighbors.Add(v1.id);
                            vertices[t.v[1]].neighbors.Add(v1.id);
                            vertices[t.v[2]].neighbors.Add(v1.id);
                            affectedNeighbors.Add(t.v[0]);
                            affectedNeighbors.Add(t.v[1]);
                            affectedNeighbors.Add(t.v[2]);
                        }
                    }

                    // Update pairs
                    pairs.RemoveAll(p => p.v1 == v2.id || p.v2 == v2.id);
                    foreach (var neighborId in affectedNeighbors)
                    {
                        if(neighborId == v1.id) continue;
                        pairs.RemoveAll(p => (p.v1 == neighborId && p.v2 == v1.id) || (p.v1 == v1.id && p.v2 == neighborId));
                        var newPair = new Pair(Math.Min(v1.id, neighborId), Math.Max(v1.id, neighborId));
                        newPair.p = CalculateOptimalPosition(v1, vertices[neighborId], out newPair.cost);
                        pairs.Add(newPair);
                    }
                }

                // Rebuild mesh data from active vertices and triangles
                var newVerts = new List<Vector3>();
                var remap = new int[vertices.Count];
                int newIdx = 0;
                for(int i=0; i<vertices.Count; i++)
                {
                    if(vertices[i].active)
                    {
                        remap[i] = newIdx;
                        newVerts.Add(vertices[i].p);
                        newIdx++;
                    }
                }
                var newIndices = new List<int>();
                foreach(var t in triangles)
                {
                    if(t.active)
                    {
                        newIndices.Add(remap[t.v[0]]);
                        newIndices.Add(remap[t.v[1]]);
                        newIndices.Add(remap[t.v[2]]);
                    }
                }
                mesh.vertices = newVerts;
                mesh.indices = newIndices;
                mesh.CalculateProperties();
            }

            private static bool Invert(Quadric q, out Vector3 p)
            {
                // This computes the inverse of the top-left 3x3 sub-matrix of the Quadric
                // and solves for the optimal position. It uses double precision for stability.
                double det = q.m11 * (q.m22 * q.m33 - q.m23 * q.m23) -
                             q.m12 * (q.m12 * q.m33 - q.m13 * q.m23) +
                             q.m13 * (q.m12 * q.m23 - q.m22 * q.m13);

                if (System.Math.Abs(det) < 1e-15)
                {
                    p = Vector3.zero;
                    return false;
                }

                double invDet = 1.0 / det;

                // Calculate the inverse of the 3x3 matrix and multiply by the vector part of the quadric (-b)
                p.x = (float)(invDet * (
                    (q.m22 * q.m33 - q.m23 * q.m23) * (-q.m14) +
                    -(q.m12 * q.m33 - q.m13 * q.m23) * (-q.m24) +
                     (q.m12 * q.m23 - q.m22 * q.m13) * (-q.m34)
                ));
                p.y = (float)(invDet * (
                    -(q.m12 * q.m33 - q.m23 * q.m13) * (-q.m14) +
                     (q.m11 * q.m33 - q.m13 * q.m13) * (-q.m24) +
                    -(q.m11 * q.m23 - q.m12 * q.m13) * (-q.m34)
                ));
                p.z = (float)(invDet * (
                     (q.m12 * q.m23 - q.m13 * q.m22) * (-q.m14) +
                    -(q.m11 * q.m23 - q.m13 * q.m12) * (-q.m24) +
                     (q.m11 * q.m22 - q.m12 * q.m12) * (-q.m34)
                ));

                return true;
            }

            private static Vector3 CalculateOptimalPosition(Vertex v1, Vertex v2, out float cost)
            {
                var q = v1.q;
                q.Add(v2.q);

                // Attempt to find the optimal position by inverting the quadric matrix
                if (Invert(q, out Vector3 p))
                {
                    cost = q.Evaluate(p.x, p.y, p.z);
                    return p;
                }
                else
                {
                    // If matrix is singular, fallback to a simpler (but robust) method.
                    // Choose the best position among the two original vertices and their midpoint.
                    Vector3 p1 = v1.p;
                    Vector3 p2 = v2.p;
                    Vector3 p_mid = (p1 + p2) / 2.0f;
                    float cost1 = q.Evaluate(p1.x, p1.y, p1.z);
                    float cost2 = q.Evaluate(p2.x, p2.y, p2.z);
                    float cost_mid = q.Evaluate(p_mid.x, p_mid.y, p_mid.z);

                    if (cost1 < cost2 && cost1 < cost_mid) {
                        cost = cost1;
                        return p1;
                    } else if (cost2 < cost_mid) {
                        cost = cost2;
                        return p2;
                    } else {
                        cost = cost_mid;
                        return p_mid;
                    }
                }
            }
        }
        public static class DecompositionCache
        {
            private const string CACHE_EXTENSION = ".empart";

            public static bool TryLoad(EmpartDecomposer decomposer, out List<ConvexHull> hulls)
            {
                hulls = null;
                if (!decomposer.settings.enableCaching || decomposer.settings.forceRecalculate) return false;

                string hash = GenerateHash(decomposer);
                string path = Path.Combine(decomposer.settings.cachePath, hash + CACHE_EXTENSION);

                if (File.Exists(path))
                {
                    try
                    {
                        using (var stream = new FileStream(path, FileMode.Open))
                        {
                            using (var reader = new BinaryReader(stream))
                            {
                                hulls = BinarySerializer.ReadHulls(reader);
                                if (enableDetailedLoggingStatic) Debug.Log($"Loaded {hulls.Count} hulls from cache: {path}");
                                return true;
                            }
                        }
                    }
                    catch(Exception e)
                    {
                        Debug.LogError($"Failed to load cache file: {e.Message}");
                        return false;
                    }
                }
                return false;
            }

            public static void Save(EmpartDecomposer decomposer, List<ConvexHull> hulls)
            {
                if (!decomposer.settings.enableCaching) return;

                string hash = GenerateHash(decomposer);
                if (!Directory.Exists(decomposer.settings.cachePath))
                {
                    Directory.CreateDirectory(decomposer.settings.cachePath);
                }
                string path = Path.Combine(decomposer.settings.cachePath, hash + CACHE_EXTENSION);

                try
                {
                    using (var stream = new FileStream(path, FileMode.Create))
                    {
                        using (var writer = new BinaryWriter(stream))
                        {
                            BinarySerializer.WriteHulls(writer, hulls);
                            if(enableDetailedLoggingStatic) Debug.Log($"Saved {hulls.Count} hulls to cache: {path}");
                        }
                    }
                }
                catch(Exception e)
                {
                     Debug.LogError($"Failed to save cache file: {e.Message}");
                }
            }

            private static string GenerateHash(EmpartDecomposer decomposer)
            {
                // Simple hash based on object name and settings json.
                // A more robust implementation would hash the mesh data itself.
                string settingsJson = JsonUtility.ToJson(decomposer.settings);
                string combined = decomposer.sourceObject.name + settingsJson;

                using (var sha = new System.Security.Cryptography.SHA256Managed())
                {
                    byte[] textData = System.Text.Encoding.UTF8.GetBytes(combined);
                    byte[] hash = sha.ComputeHash(textData);
                    return BitConverter.ToString(hash).Replace("-", "");
                }
            }
        }

        public static class BinarySerializer
        {
            public static void WriteHulls(BinaryWriter writer, List<ConvexHull> hulls)
            {
                writer.Write(hulls.Count);
                foreach(var hull in hulls)
                {
                    WriteVector3List(writer, hull.vertices);
                    WriteIntList(writer, hull.indices);
                }
            }
            public static List<ConvexHull> ReadHulls(BinaryReader reader)
            {
                int hullCount = reader.ReadInt32();
                var hulls = new List<ConvexHull>(hullCount);
                for(int i=0; i<hullCount; i++)
                {
                    var hull = new ConvexHull();
                    hull.vertices = ReadVector3List(reader);
                    hull.indices = ReadIntList(reader);
                    hull.CalculateProperties();
                    hulls.Add(hull);
                }
                return hulls;
            }
            private static void WriteVector3List(BinaryWriter writer, List<Vector3> list)
            {
                writer.Write(list.Count);
                foreach(var v in list)
                {
                    writer.Write(v.x);
                    writer.Write(v.y);
                    writer.Write(v.z);
                }
            }
            private static List<Vector3> ReadVector3List(BinaryReader reader)
            {
                int count = reader.ReadInt32();
                var list = new List<Vector3>(count);
                for(int i=0; i<count; i++)
                {
                    list.Add(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()));
                }
                return list;
            }
            private static void WriteIntList(BinaryWriter writer, List<int> list)
            {
                writer.Write(list.Count);
                foreach(var i in list) writer.Write(i);
            }
            private static List<int> ReadIntList(BinaryReader reader)
            {
                int count = reader.ReadInt32();
                var list = new List<int>(count);
                for(int i=0; i<count; i++) list.Add(reader.ReadInt32());
                return list;
            }
        }
        /// <summary>
        /// Split plane evaluator for finding optimal split planes
        /// </summary>
        public static class SplitPlaneEvaluator
        {
            public static (Vector3 normal, Vector3 point) FindBestSplitPlane(MeshData mesh, ConvexHull hull, float concavity)
            {
                // Find the deepest point of concavity (witness point)
                Vector3 witnessPoint = Vector3.zero;
                float maxDist = -1f;
                foreach (var vert in mesh.vertices)
                {
                    float dist = hull.DistanceToPoint(vert);
                    if (dist > maxDist)
                    {
                        maxDist = dist;
                        witnessPoint = vert;
                    }
                }
                var candidates = GenerateSplitPlaneCandidates(mesh, hull, witnessPoint);
                if (candidates.Count == 0) return (Vector3.up, mesh.bounds.center);
                var bestPlane = (Vector3.zero, Vector3.zero);
                float bestScore = float.MaxValue; // We want to minimize the score
                foreach (var candidate in candidates)
                {
                    float score = EvaluateSplitPlane(mesh, candidate.normal, candidate.point);
                    if (score < bestScore)
                    {
                        bestScore = score;
                        bestPlane = candidate;
                    }
                }
                return bestPlane;
            }
            private static List<(Vector3 normal, Vector3 point)> GenerateSplitPlaneCandidates(MeshData mesh, ConvexHull hull, Vector3 witnessPoint)
            {
                var candidates = new List<(Vector3 normal, Vector3 point)>();
                if (mesh.vertices.Count < 10) return candidates;
                // Candidate 1: Plane aligned with axis-aligned bounding box
                candidates.Add((Vector3.right, mesh.bounds.center));
                candidates.Add((Vector3.up, mesh.bounds.center));
                candidates.Add((Vector3.forward, mesh.bounds.center));
                // Candidate 2: Plane through witness point
                Vector3 closestPointOnHull = hull.bounds.ClosestPoint(witnessPoint);
                Vector3 witnessNormal = (witnessPoint - closestPointOnHull).normalized;
                if (witnessNormal.sqrMagnitude > 0.1f)
                {
                    candidates.Add((witnessNormal, witnessPoint));
                }
                // Candidate 3: PCA-aligned plane
                CalculatePCA(mesh.vertices, out Vector3 pca1, out Vector3 pca2, out Vector3 pca3);
                candidates.Add((pca1, mesh.bounds.center));
                candidates.Add((pca2, mesh.bounds.center));
                candidates.Add((pca3, mesh.bounds.center));
                // Additional candidates: Based on features
                if (mesh.featureVertices != null)
                {
                    if (mesh.featureVertices.Count >= 3)
                    {
                        var fv1 = mesh.vertices[mesh.featureVertices[0]];
                        var fv2 = mesh.vertices[mesh.featureVertices[1]];
                        var fv3 = mesh.vertices[mesh.featureVertices[2]];
                        var featureNormal = Vector3.Cross(fv2 - fv1, fv3 - fv1).normalized;
                        candidates.Add((featureNormal, (fv1 + fv2 + fv3) / 3f));
                    }
                }
                // Additional: Voxel-based candidates
                var voxelCandidate = GenerateVoxelBasedCandidate(mesh);
                if (voxelCandidate.normal != Vector3.zero)
                    candidates.Add(voxelCandidate);
                return candidates;
            }
            private static (Vector3 normal, Vector3 point) GenerateVoxelBasedCandidate(MeshData mesh)
            {
                if (mesh.sdfValues == null || !mesh.sdfValues.IsCreated || mesh.sdfValues.Length == 0)
                {
                    return (Vector3.zero, Vector3.zero);
                }

                // Find the voxel with the maximum SDF value (deepest point in a concavity)
                float maxSdf = float.MinValue;
                int maxSdfIndex = -1;
                for (int i = 0; i < mesh.sdfValues.Length; i++)
                {
                    if (mesh.sdfValues[i] > maxSdf)
                    {
                        maxSdf = mesh.sdfValues[i];
                        maxSdfIndex = i;
                    }
                }

                if (maxSdfIndex == -1 || maxSdf < 0.001f) // No significant concavity found
                {
                    return (Vector3.zero, Vector3.zero);
                }

                int3 coord = mesh.GetVoxelCoord(maxSdfIndex);
                Vector3 point = mesh.VoxelToWorld(coord);

                // Calculate the SDF gradient at this point to get the normal
                int3 xp = new int3(coord.x + 1, coord.y, coord.z);
                int3 xn = new int3(coord.x - 1, coord.y, coord.z);
                int3 yp = new int3(coord.x, coord.y + 1, coord.z);
                int3 yn = new int3(coord.x, coord.y - 1, coord.z);
                int3 zp = new int3(coord.x, coord.y, coord.z + 1);
                int3 zn = new int3(coord.x, coord.y, coord.z - 1);

                float sdf_xp = mesh.IsVoxelInBounds(xp) ? mesh.sdfValues[mesh.GetVoxelIndex(xp)] : maxSdf;
                float sdf_xn = mesh.IsVoxelInBounds(xn) ? mesh.sdfValues[mesh.GetVoxelIndex(xn)] : maxSdf;
                float sdf_yp = mesh.IsVoxelInBounds(yp) ? mesh.sdfValues[mesh.GetVoxelIndex(yp)] : maxSdf;
                float sdf_yn = mesh.IsVoxelInBounds(yn) ? mesh.sdfValues[mesh.GetVoxelIndex(yn)] : maxSdf;
                float sdf_zp = mesh.IsVoxelInBounds(zp) ? mesh.sdfValues[mesh.GetVoxelIndex(zp)] : maxSdf;
                float sdf_zn = mesh.IsVoxelInBounds(zn) ? mesh.sdfValues[mesh.GetVoxelIndex(zn)] : maxSdf;

                Vector3 normal = new Vector3(
                    sdf_xp - sdf_xn,
                    sdf_yp - sdf_yn,
                    sdf_zp - sdf_zn
                ).normalized;

                if (normal.sqrMagnitude < 0.1f)
                {
                    return (Vector3.zero, Vector3.zero); // Gradient is too small
                }

                return (normal, point);
            }
            private static float EvaluateSplitPlane(MeshData mesh, Vector3 normal, Vector3 point)
            {
                // Use a cost function based on the Surface Area Heuristic (SAH)
                // This tries to create balanced splits.
                Bounds leftBounds = new Bounds();
                Bounds rightBounds = new Bounds();
                int leftCount = 0, rightCount = 0;
                bool firstLeft = true, firstRight = true;
                foreach (var v in mesh.vertices)
                {
                    float side = Vector3.Dot(v - point, normal);
                    if (side <= 0)
                    {
                        if (firstLeft) { leftBounds = new Bounds(v, Vector3.zero); firstLeft = false; }
                        else { leftBounds.Encapsulate(v); }
                        leftCount++;
                    }
                    else
                    {
                        if (firstRight) { rightBounds = new Bounds(v, Vector3.zero); firstRight = false; }
                        else { rightBounds.Encapsulate(v); }
                        rightCount++;
                    }
                }
                if (leftCount == 0 || rightCount == 0) return float.MaxValue; // Invalid split
                float surfaceAreaLeft = 2 * (leftBounds.size.x * leftBounds.size.y + leftBounds.size.x * leftBounds.size.z + leftBounds.size.y * leftBounds.size.z);
                float surfaceAreaRight = 2 * (rightBounds.size.x * rightBounds.size.y + rightBounds.size.x * rightBounds.size.z + rightBounds.size.y * rightBounds.size.z);
                float cost = surfaceAreaLeft * leftCount + surfaceAreaRight * rightCount;
                // Additional: Penalize unbalanced splits
                float balance = Mathf.Abs(leftCount - rightCount) / (float)(leftCount + rightCount);
                cost *= 1 + balance;
                return cost;
            }
            private static void CalculatePCA(List<Vector3> points, out Vector3 axis1, out Vector3 axis2, out Vector3 axis3)
            {
                if (points.Count < 3)
                {
                    axis1 = Vector3.right;
                    axis2 = Vector3.up;
                    axis3 = Vector3.forward;
                    return;
                }
                Vector3 mean = Vector3.zero;
                foreach (var p in points) mean += p;
                mean /= points.Count;
                float xx = 0, xy = 0, xz = 0, yy = 0, yz = 0, zz = 0;
                foreach (var p in points)
                {
                    Vector3 r = p - mean;
                    xx += r.x * r.x; xy += r.x * r.y; xz += r.x * r.z;
                    yy += r.y * r.y; yz += r.y * r.z; zz += r.z * r.z;
                }
                xx /= points.Count; xy /= points.Count; xz /= points.Count;
                yy /= points.Count; yz /= points.Count; zz /= points.Count;
                Matrix4x4 cov = new Matrix4x4();
                cov[0, 0] = xx; cov[0, 1] = xy; cov[0, 2] = xz;
                cov[1, 0] = xy; cov[1, 1] = yy; cov[1, 2] = yz;
                cov[2, 0] = xz; cov[2, 1] = yz; cov[2, 2] = zz;
                // Using Jacobi iterations for Eigendecomposition of the 3x3 covariance matrix
                const int maxIterations = 10;
                Matrix4x4 eigenVectors = Matrix4x4.identity;
                for (int i = 0; i < maxIterations; i++)
                {
                    float maxOffDiag = 0;
                    int p = 0, q = 1;
                    for (int j = 0; j < 3; j++)
                    {
                        for (int k = j + 1; k < 3; k++)
                        {
                            if (Mathf.Abs(cov[j, k]) > maxOffDiag)
                            {
                                maxOffDiag = Mathf.Abs(cov[j, k]);
                                p = j;
                                q = k;
                            }
                        }
                    }
                    if (maxOffDiag < 1e-6f) break;
                    float app = cov[p, p];
                    float aqq = cov[q, q];
                    float apq = cov[p, q];
                    float theta;
                    if (Mathf.Abs(app - aqq) < 1e-9f)
                    {
                        theta = Mathf.PI / 4.0f * (apq > 0 ? 1 : -1);
                    }
                    else
                    {
                        theta = 0.5f * Mathf.Atan(2 * apq / (app - aqq));
                    }
                    float c = Mathf.Cos(theta);
                    float s = Mathf.Sin(theta);
                    Matrix4x4 R = Matrix4x4.identity;
                    R[p, p] = c; R[p, q] = s;
                    R[q, p] = -s; R[q, q] = c;
                    cov = R.transpose * cov * R;
                    eigenVectors = eigenVectors * R;
                }
                axis1 = eigenVectors.GetColumn(0).normalized;
                axis2 = eigenVectors.GetColumn(1).normalized;
                axis3 = eigenVectors.GetColumn(2).normalized;
                // Additional: Sort by eigenvalue magnitude if needed
            }
            // New method for voxel-based plane scoring
            public static float ScorePlaneWithVoxels(MeshData mesh, Vector3 normal, Vector3 point, float concavityWeight, float sahWeight, float balanceWeight)
            {
                // Split voxels into left and right
                int leftVoxels = 0, rightVoxels = 0;
                float leftConcavity = 0, rightConcavity = 0;
                for (int idx = 0; idx < mesh.sdfValues.Length; idx++)
                {
                    int3 coord = new int3(idx % mesh.voxelDimensions.x, (idx / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, idx / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                    Vector3 voxelPos = mesh.VoxelToWorld(coord);
                    float side = Vector3.Dot(voxelPos - point, normal);
                    if (side <= 0)
                    {
                        leftVoxels++;
                        leftConcavity += mesh.sdfValues[idx] > 0 ? mesh.sdfValues[idx] : 0;
                    }
                    else
                    {
                        rightVoxels++;
                        rightConcavity += mesh.sdfValues[idx] > 0 ? mesh.sdfValues[idx] : 0;
                    }
                }
                float maxConcavity = Mathf.Max(leftConcavity / leftVoxels, rightConcavity / rightVoxels);
                float sahCost = EvaluateSplitPlane(mesh, normal, point);
                float balance = Mathf.Abs(leftVoxels - rightVoxels) / (float)(leftVoxels + rightVoxels);
                return concavityWeight * maxConcavity + sahWeight * sahCost + balanceWeight * balance;
            }
            // Additional: Feature-based plane generation
            public static (Vector3 normal, Vector3 point) GenerateFeaturePlane(MeshData mesh)
            {
                if (mesh.featureVertices.Count < 3) return (Vector3.up, mesh.bounds.center);
                var fv1 = mesh.vertices[mesh.featureVertices[0]];
                var fv2 = mesh.vertices[mesh.featureVertices[1]];
                var fv3 = mesh.vertices[mesh.featureVertices[2]];
                var normal = Vector3.Cross(fv2 - fv1, fv3 - fv1).normalized;
                var point = (fv1 + fv2 + fv3) / 3f;
                return (normal, point);
            }
        }
        /// <summary>
        /// Utility for splitting a MeshData object by a plane.
        /// </summary>
        public static class MeshSplitter
        {
            public static void Split(MeshData original, PlaneF plane, out MeshData positiveSide, out MeshData negativeSide)
            {
                positiveSide = new MeshData();
                negativeSide = new MeshData();
                var positiveVerts = new List<Vector3>();
                var negativeVerts = new List<Vector3>();
                int[] posRemap = new int[original.vertices.Count];
                int[] negRemap = new int[original.vertices.Count];
                float[] vertDistances = new float[original.vertices.Count];
                for (int i = 0; i < original.vertices.Count; i++)
                {
                    vertDistances[i] = plane.DistanceToPoint(original.vertices[i]);
                }
                for (int i = 0; i < original.indices.Count; i += 3)
                {
                    int i0 = original.indices[i];
                    int i1 = original.indices[i + 1];
                    int i2 = original.indices[i + 2];
                    float d0 = vertDistances[i0];
                    float d1 = vertDistances[i1];
                    float d2 = vertDistances[i2];
                    int posCount = (d0 > 0 ? 1 : 0) + (d1 > 0 ? 1 : 0) + (d2 > 0 ? 1 : 0);
                    if (posCount == 3)
                    {
                        AddTriangle(positiveSide, original, i0, i1, i2, posRemap);
                    }
                    else if (posCount == 0)
                    {
                        AddTriangle(negativeSide, original, i0, i1, i2, negRemap);
                    }
                    else // Triangle is clipped by the plane
                    {
                        ClipTriangle(original, plane, i0, i1, i2, d0, d1, d2, positiveSide, negativeSide, posRemap, negRemap);
                    }
                }
                positiveSide.Optimize();
                negativeSide.Optimize();
            }
            private static void AddTriangle(MeshData mesh, MeshData original, int i0, int i1, int i2, int[] remap)
            {
                int r0 = RemapVertex(mesh, original, i0, remap);
                int r1 = RemapVertex(mesh, original, i1, remap);
                int r2 = RemapVertex(mesh, original, i2, remap);
                mesh.indices.Add(r0); mesh.indices.Add(r1); mesh.indices.Add(r2);
            }
            private static int RemapVertex(MeshData mesh, MeshData original, int originalIndex, int[] remap)
            {
                if (remap[originalIndex] > 0) return remap[originalIndex] - 1;
                int newIndex = mesh.vertices.Count;
                mesh.vertices.Add(original.vertices[originalIndex]);
                if (original.normals.Count > originalIndex) mesh.normals.Add(original.normals[originalIndex]);
                remap[originalIndex] = newIndex + 1;
                return newIndex;
            }
            private static void ClipTriangle(MeshData original, PlaneF plane, int i0, int i1, int i2, float d0, float d1, float d2, MeshData posMesh, MeshData negMesh, int[] posRemap, int[] negRemap)
            {
                int[] indices = { i0, i1, i2 };
                float[] distances = { d0, d1, d2 };
                List<int> posIndices = new List<int>();
                List<int> negIndices = new List<int>();
                for (int i = 0; i < 3; i++)
                {
                    int current = indices[i];
                    int next = indices[(i + 1) % 3];
                    float dCurrent = distances[i];
                    float dNext = distances[(i + 1) % 3];
                    if (dCurrent >= 0)
                    {
                        posIndices.Add(RemapVertex(posMesh, original, current, posRemap));
                    }
                    else
                    {
                        negIndices.Add(RemapVertex(negMesh, original, current, negRemap));
                    }
                    // If edge crosses plane, create new vertex
                    if (dCurrent * dNext < 0)
                    {
                        float t = dCurrent / (dCurrent - dNext);
                        Vector3 intersectPoint = Vector3.Lerp(original.vertices[current], original.vertices[next], t);
                        int newPosVert = posMesh.vertices.Count;
                        posMesh.vertices.Add(intersectPoint);
                        posIndices.Add(newPosVert);
                        int newNegVert = negMesh.vertices.Count;
                        negMesh.vertices.Add(intersectPoint);
                        negIndices.Add(newNegVert);
                    }
                }
                // Triangulate resulting polygons
                if (posIndices.Count >= 3)
                {
                    for (int i = 1; i < posIndices.Count - 1; i++)
                    {
                        posMesh.indices.Add(posIndices[0]);
                        posMesh.indices.Add(posIndices[i]);
                        posMesh.indices.Add(posIndices[i + 1]);
                    }
                }
                if (negIndices.Count >= 3)
                {
                    for (int i = 1; i < negIndices.Count - 1; i++)
                    {
                        negMesh.indices.Add(negIndices[0]);
                        negMesh.indices.Add(negIndices[i]);
                        negMesh.indices.Add(negIndices[i + 1]);
                    }
                }
            }
            // Additional: Multi-plane split
            public static List<MeshData> MultiSplit(MeshData original, List<PlaneF> planes)
            {
                var parts = new List<MeshData> { original };
                foreach (var plane in planes)
                {
                    var newParts = new List<MeshData>();
                    foreach (var part in parts)
                    {
                        Split(part, plane, out MeshData pos, out MeshData neg);
                        if (pos.vertices.Count > 3) newParts.Add(pos);
                        if (neg.vertices.Count > 3) newParts.Add(neg);
                    }
                    parts = newParts;
                }
                return parts;
            }
        }
        [Header("Settings")]
        public ConvexDecompositionSettings settings;
        [Header("Input")]
        public GameObject sourceObject;
        public List<RegionBox> regionBoxes = new List<RegionBox>();
        [Header("Output")]
        public List<GameObject> hullObjects = new List<GameObject>();
        public DecompositionMetrics metrics = new DecompositionMetrics();
        [Header("Debug")]
        public bool enableInteractiveMode = false;
        public bool showRegionBounds = true;
        private MeshData combinedMesh;
        private List<ConvexHull> hulls = new List<ConvexHull>();
        private List<(Vector3, Vector3)> debugSplitPlanes = new List<(Vector3, Vector3)>();
        private bool isProcessing = false;
        private static bool enableDetailedLoggingStatic = false; // Static for class-wide logging
        private static bool enableProfilingStatic = false;
        float ToUnitsFromMm(float mm) => (mm * 0.001f) * settings.unitsPerMeter;
        void Start()
        {
            if (sourceObject == null)
            {
                sourceObject = gameObject;
            }
            if (settings == null)
            {
                Debug.LogError("No convex decomposition settings assigned!");
                return;
            }
        }
        private void LoadAndCombineMeshData()
        {
            if (sourceObject == null)
            {
                Debug.LogError("No source object assigned!");
                return;
            }
            var meshFilters = sourceObject.GetComponentsInChildren<MeshFilter>();
            if (meshFilters.Length == 0)
            {
                Debug.LogError("No MeshFilters found in source object or its children!");
                return;
            }
            combinedMesh = new MeshData();
            int vertexOffset = 0;
            foreach (var mf in meshFilters)
            {
                if (mf.sharedMesh == null) continue;
                var mesh = mf.sharedMesh;
                vertexOffset = combinedMesh.vertices.Count;
                Matrix4x4 toWorld = transform.worldToLocalMatrix * mf.transform.localToWorldMatrix;
                var transformedVerts = new Vector3[mesh.vertexCount];
                for (int i = 0; i < mesh.vertexCount; i++)
                {
                    transformedVerts[i] = toWorld.MultiplyPoint3x4(mesh.vertices[i]);
                }
                combinedMesh.vertices.AddRange(transformedVerts);
                if (mesh.normals.Length > 0)
                {
                    var transformedNormals = new Vector3[mesh.normals.Length];
                    for (int i = 0; i < mesh.normals.Length; i++)
                    {
                        transformedNormals[i] = toWorld.MultiplyVector(mesh.normals[i]).normalized;
                    }
                    combinedMesh.normals.AddRange(transformedNormals);
                }
                var triangles = mesh.triangles;
                for (int i = 0; i < triangles.Length; i++)
                {
                    triangles[i] += vertexOffset;
                }
                combinedMesh.indices.AddRange(triangles);
            }
            combinedMesh.Optimize(settings);

            if (settings.enableIsotropicRemeshing)
            {
                IsotropicRemesher.Remesh(combinedMesh, settings.remeshTargetEdgeLength, settings.remeshIterations);
            }
            if (settings.enableQemDecimation)
            {
                QEMSimplifier.Simplify(combinedMesh, settings.qemTargetPercentage);
            }

            combinedMesh.CalculateProperties();

            if (settings.acdMethod == ACDSubroutineType.CoACD)
            {
                combinedMesh.CalculateSaliency(settings.saliencyMethod, settings.heatDiffusionIterations);
                combinedMesh.IdentifySharpEdges(settings.sharpEdgeAngle);
                combinedMesh.IdentifyFeatureVertices();
            }

            combinedMesh.BuildAccelerationStructure();
            metrics.originalMeshVolume = combinedMesh.volume;
            metrics.originalMeshSurfaceArea = combinedMesh.surfaceArea;
        }
        [ContextMenu("Decompose Mesh")]
        public void DecomposeMesh()
        {
            if (isProcessing)
            {
                Debug.LogWarning("Decomposition already in progress!");
                return;
            }
            LoadAndCombineMeshData();
            if (combinedMesh == null || combinedMesh.vertexCount == 0)
            {
                Debug.LogWarning("Combined mesh is empty. Aborting decomposition.");
                return;
            }
            StartCoroutine(DecomposeMeshAsync());
        }
        private IEnumerator DecomposeMeshAsync()
        {
            isProcessing = true;
            float startTime = Time.realtimeSinceStartup;
            ClearResults();

            if (DecompositionCache.TryLoad(this, out hulls))
            {
                CreateHullObjects();
                CalculateMetrics();
                metrics.totalTime = Time.realtimeSinceStartup - startTime;
                isProcessing = false;
                yield break;
            }

            var regionHulls = new List<List<ConvexHull>>();
            // Process regions
            foreach (var regionBox in regionBoxes)
            {
                if (!regionBox.IsValid()) continue;
                var regionMesh = MeshBooleanOperations.BooleanIntersect(combinedMesh, regionBox.AABB);
                if (regionMesh.vertices.Count < 4) continue;
                regionMesh.Voxelize(settings);
                regionMesh.ComputeSDF(settings);
                var newHulls = DecomposeRegion(regionMesh, regionBox.partBudgetMax, ToUnitsFromMm(regionBox.epsilonMm));
                regionHulls.Add(newHulls);
                yield return null;
            }
            // Process remainder
            var remainderMesh = combinedMesh;
            foreach (var regionBox in regionBoxes)
            {
                remainderMesh = MeshBooleanOperations.BooleanDifference(remainderMesh, regionBox.AABB);
            }
            if (remainderMesh.vertices.Count >= 4)
            {
                remainderMesh.Voxelize(settings);
                remainderMesh.ComputeSDF(settings);
                regionHulls.Add(DecomposeRegion(remainderMesh, settings.maxHullCount, settings.errorTolerance));
            }
            // Flatten list
            foreach (var list in regionHulls) hulls.AddRange(list);
            MergeHulls();
            MergeHulls();
            ApplyPostProcessing();
            CreateHullObjects();
            CalculateMetrics();
            metrics.totalTime = Time.realtimeSinceStartup - startTime;
            isProcessing = false;
            Debug.Log($"Decomposition completed in {metrics.totalTime:F2}s with {hulls.Count} hulls");

            DecompositionCache.Save(this, hulls);
        }

        private void ApplyPostProcessing()
        {
            if (!settings.enablePostProcessing) return;

            foreach (var hull in hulls)
            {
                switch (settings.postProcessingType)
                {
                    case PostProcessingType.Smoothing:
                        hull.SmoothHull(settings.smoothingIterations, settings.smoothingLambda, settings.enableBoundaryLocking);
                        break;
                    case PostProcessingType.Simplification:
                        // This is already handled by OptimizeHull, maybe call it again with a different threshold
                        hull.OptimizeHull(settings, settings.postProcessingThreshold, HullOptimizationStrategy.VertexReduction);
                        break;
                    case PostProcessingType.HoleFilling:
                        hull.FillHoles();
                        break;
                    case PostProcessingType.SymmetryEnforcement:
                        hull.EnforceSymmetry();
                        break;
                }
                hull.CalculateProperties(); // Recalculate after any modification
            }
        }
        private List<ConvexHull> DecomposeRegion(MeshData regionMesh, int budget, float tolerance)
        {
            var finalHulls = new List<ConvexHull>();
            var processQueue = new MaxPQ<(MeshData, float)>();
            if (regionMesh.vertices.Count < 4) return finalHulls;
            processQueue.Enqueue((regionMesh, CalculateConcavity(regionMesh, null)));
            while (processQueue.Count > 0 && finalHulls.Count < budget)
            {
                processQueue.TryDequeue(out var(currentMesh, currentConcavity), out _);
                if (currentMesh.vertices.Count < 4) continue;
                // 1. Generate convex hull for the current mesh part
                var hull = QuickHullImplementation.ComputeConvexHullFromPoints(currentMesh.vertices);
                if (hull.vertices.Count < 4) continue;
                hull.BuildPlanes();
                // 2. Calculate concavity using voxel/SDF
                float concavity = CalculateConcavity(currentMesh, hull);
                // 3. Check termination condition
                if (concavity < tolerance)
                {
                    finalHulls.Add(hull);
                    continue;
                }
                // 4. If concavity is too high, find best split plane
                var (splitNormal, splitPoint) = SplitPlaneEvaluator.FindBestSplitPlane(currentMesh, hull, concavity);
                if(settings.drawSplitPlanes)
                {
                    debugSplitPlanes.Add((splitPoint, splitNormal));
                }
                var splitPlane = new PlaneF { n = splitNormal, d = -Vector3.Dot(splitNormal, splitPoint) };
                // 5. Split the mesh
                MeshSplitter.Split(currentMesh, splitPlane, out MeshData positiveSide, out MeshData negativeSide);
                // 6. Add new parts back to the queue with concavity priority
                if (positiveSide.vertices.Count > 3)
                {
                    positiveSide.Voxelize(settings);
                    positiveSide.ComputeSDF(settings.sdfMethod, settings.sdfIterationCount, settings.sdfSmoothingFactor);
                    float posConcavity = CalculateConcavity(positiveSide, null);
                    processQueue.Enqueue((positiveSide, posConcavity));
                }
                if (negativeSide.vertices.Count > 3)
                {
                    negativeSide.Voxelize(settings);
                    negativeSide.ComputeSDF(settings.sdfMethod, settings.sdfIterationCount, settings.sdfSmoothingFactor);
                    float negConcavity = CalculateConcavity(negativeSide, null);
                    processQueue.Enqueue((negativeSide, negConcavity));
                }
            }
            // Add any remaining parts from the queue as hulls if budget is exceeded
            while (processQueue.Count > 0)
            {
                processQueue.TryDequeue(out var(mesh, _), out _);
                if (mesh.vertices.Count > 3)
                {
                    finalHulls.Add(QuickHullImplementation.ComputeConvexHullFromPoints(mesh.vertices));
                }
            }
            return finalHulls;
        }
        private float CalculateConcavity(MeshData mesh, ConvexHull hull)
        {
            if (hull == null)
            {
                hull = QuickHullImplementation.ComputeConvexHullFromPoints(mesh.vertices);
            }
            // Use SDF/voxel-based concavity
            float maxConcavity = 0f;
            float averageConcavity = 0f;
            int outsideCount = 0;
            for (int idx = 0; idx < mesh.sdfValues.Length; idx++)
            {
                int3 coord = new int3(idx % mesh.voxelDimensions.x, (idx / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, idx / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                Vector3 voxelPos = mesh.VoxelToWorld(coord);
                if (!hull.ContainsPoint(voxelPos) && mesh.sdfValues[idx] < 0) // Outside hull but inside mesh
                {
                    float dist = hull.DistanceToPoint(voxelPos);
                    maxConcavity = Mathf.Max(maxConcavity, dist);
                    averageConcavity += dist;
                    outsideCount++;
                }
            }
            return outsideCount > 0 ? averageConcavity / outsideCount : 0f; // Weighted average
        }
        private void MergeHulls()
        {
            if (settings.mergingStrategy == MergingStrategy.Hierarchical)
            {
                HierarchicalMerge();
                return;
            }

            bool changed = true;
            int mergeIterations = 0;
            while (changed && mergeIterations < settings.maxOptimizationIterations)
            {
                changed = false;
                float bestCost = float.MaxValue;
                int best_i = -1, best_j = -1;

                for (int i = 0; i < hulls.Count; i++)
                {
                    for (int j = i + 1; j < hulls.Count; j++)
                    {
                        if (hulls[i].bounds.Intersects(hulls[j].bounds))
                        {
                            float cost = CalculateMergeCost(hulls[i], hulls[j], settings);
                            if (cost < bestCost)
                            {
                                bestCost = cost;
                                best_i = i;
                                best_j = j;
                            }
                        }
                    }
                }

                if (best_i != -1 && bestCost < settings.mergeThreshold)
                {
                    var merged = MeshBooleanOperations.BooleanUnion(hulls[best_i], hulls[best_j], settings);
                    hulls.RemoveAt(best_j);
                    hulls[best_i] = merged;
                    changed = true;
                    metrics.successfulMerges++;
                }
                mergeIterations++;
            }
            if (hulls.Count > 0) metrics.mergeEfficiency = (float)metrics.successfulMerges / hulls.Count;
        }

        private float CalculateMergeCost(ConvexHull h1, ConvexHull h2, ConvexDecompositionSettings settings)
        {
            var merged = MeshBooleanOperations.BooleanUnion(h1, h2);
            var hullMesh = new MeshData { vertices = merged.vertices, indices = merged.indices };
            hullMesh.Voxelize(settings);
            if (!hullMesh.sdfValues.IsCreated || hullMesh.sdfValues.Length == 0) return float.MaxValue;
            hullMesh.ComputeSDF(settings);

            float mergedConcavity = CalculateConcavity(hullMesh, merged);
            float volumeIncrease = merged.volume - (h1.volume + h2.volume);
            float surfaceAreaIncrease = merged.surfaceArea - (h1.surfaceArea + h2.surfaceArea);

            float concavityCost = mergedConcavity / settings.mergeConcavityThreshold;
            float volumeCost = Mathf.Max(0, volumeIncrease / (h1.volume + h2.volume));
            float surfaceAreaCost = Mathf.Max(0, surfaceAreaIncrease / (h1.surfaceArea + h2.surfaceArea));

            return concavityCost * 0.5f + volumeCost * 0.25f + surfaceAreaCost * 0.25f;
        }

        private void HierarchicalMerge()
        {
            if (hulls.Count <= 1) return;

            // Build a list of hull pairs and their merge costs
            var pairs = new List<(int, int, float)>();
            for (int i = 0; i < hulls.Count; i++)
            {
                for (int j = i + 1; j < hulls.Count; j++)
                {
                    float cost = CalculateMergeCost(hulls[i], hulls[j], settings);
                    if (cost < settings.mergeThreshold)
                    {
                        pairs.Add((i, j, cost));
                    }
                }
            }

            // Sort pairs by cost
            pairs.Sort((a, b) => a.Item3.CompareTo(b.Item3));

            var mergedIndices = new HashSet<int>();
            var newHulls = new List<ConvexHull>();

            foreach (var pair in pairs)
            {
                if (mergedIndices.Contains(pair.Item1) || mergedIndices.Contains(pair.Item2)) continue;

                var mergedHull = MeshBooleanOperations.BooleanUnion(hulls[pair.Item1], hulls[pair.Item2], settings);
                newHulls.Add(mergedHull);
                mergedIndices.Add(pair.Item1);
                mergedIndices.Add(pair.Item2);
                metrics.successfulMerges++;
            }

            // Add any unmerged hulls
            for (int i = 0; i < hulls.Count; i++)
            {
                if (!mergedIndices.Contains(i))
                {
                    newHulls.Add(hulls[i]);
                }
            }

            hulls = newHulls;
            if (hulls.Count > 0) metrics.mergeEfficiency = (float)metrics.successfulMerges / hulls.Count;
        }
        private void CreateHullObjects()
        {
            foreach (var hullObj in hullObjects) if (hullObj != null) Destroy(hullObj);
            hullObjects.Clear();
            var container = new GameObject("ConvexHulls");
            container.transform.SetParent(transform, false);
            for (int i = 0; i < hulls.Count; i++)
            {
                var hull = hulls[i];
                if (settings.enableHullOptimization && hull.vertices.Count > settings.maxVerticesPerHull)
                    hull.OptimizeHull(settings, settings.hullOptimizationThreshold, settings.hullOptimizationStrategy);
                // Safety for convex collider:
                if ((hull.indices.Count / 3) > 255)
                    hull.OptimizeHull(settings, settings.hullOptimizationThreshold, settings.hullOptimizationStrategy);
                var hullObj = new GameObject($"Hull_{i}");
                hullObj.transform.SetParent(container.transform, false);
                var mesh = new Mesh
                {
                    vertices = hull.vertices.ToArray(),
                    triangles = hull.indices.ToArray()
                };
                mesh.RecalculateNormals();
                mesh.RecalculateBounds();
                hullObj.AddComponent<MeshFilter>().sharedMesh = mesh;
                hullObj.AddComponent<MeshRenderer>().sharedMaterial = settings.hullMaterial ?? new Material(Shader.Find("Standard"));
                var col = hullObj.AddComponent<MeshCollider>();
                col.sharedMesh = mesh;
                col.convex = true;
                hullObjects.Add(hullObj);
            }
        }
        private void CalculateMetrics()
        {
            metrics = new DecompositionMetrics
            {
                vertexCount = combinedMesh.vertexCount,
                triangleCount = combinedMesh.triangleCount,
                hullCount = hulls.Count,
                originalMeshVolume = combinedMesh.volume,
                originalMeshSurfaceArea = combinedMesh.surfaceArea
            };
            metrics.errorDistribution = ErrorCalculator.CalculateErrorDistribution(combinedMesh, hulls, 1000);
            metrics.hullMetrics.Clear();
            for (int i = 0; i < hulls.Count; i++)
            {
                var hull = hulls[i];
                var hullMetric = new HullMetrics
                {
                    hullId = i,
                    vertexCount = hull.vertices.Count,
                    triangleCount = hull.indices.Count / 3,
                    volume = hull.volume,
                    surfaceArea = hull.surfaceArea,
                    bounds = hull.bounds,
                    centroid = hull.centroid,
                    compactness = hull.compactness,
                    aspectRatio = hull.aspectRatio
                };
                metrics.hullMetrics.Add(hullMetric);
            }
            metrics.CalculateDerivedMetrics();
            // Additional: Export if profiling
            if (settings.enableProfiling)
                metrics.ExportToCSV("decomposition_metrics.csv");
        }
        private void ClearResults()
        {
            foreach (var hullObj in hullObjects)
            {
                if (hullObj != null)
                {
#if UNITY_EDITOR
                    DestroyImmediate(hullObj);
#else
                    Destroy(hullObj);
#endif
                }
            }
            // Also destroy the container
            var container = transform.Find("ConvexHulls");
            if (container != null)
            {
#if UNITY_EDITOR
                DestroyImmediate(container.gameObject);
#else
                Destroy(container.gameObject);
#endif
            }
            hullObjects.Clear();
            hulls.Clear();
            metrics = new DecompositionMetrics();
        }
        private void OnDrawGizmos()
        {
            if (!enableInteractiveMode || settings == null) return;

            Gizmos.matrix = transform.localToWorldMatrix;

            if (showRegionBounds)
            {
                Gizmos.color = Color.yellow;
                foreach (var region in regionBoxes)
                {
                    Gizmos.DrawWireCube(region.AABB.center, region.AABB.size);
                }
            }

            if (settings.drawBvh && combinedMesh?.accelerationStructure != null)
            {
                DecompositionDebug.DrawBvh(combinedMesh.accelerationStructure);
            }
            if (settings.drawVoxels && combinedMesh?.sdfValues.IsCreated == true)
            {
                DecompositionDebug.DrawVoxels(combinedMesh);
            }
            if (settings.drawWitnessPoints)
            {
                foreach(var hull in hulls)
                {
                    if(hull.witnessPoints != null) DecompositionDebug.DrawWitnessPoints(hull);
                }
            }
            if (settings.drawSaliencyHeatmap && combinedMesh?.vertexSaliency != null)
            {
                DecompositionDebug.DrawSaliencyHeatmap(combinedMesh);
            }
            if (settings.drawSplitPlanes && debugSplitPlanes.Count > 0)
            {
                DecompositionDebug.DrawSplitPlanes(debugSplitPlanes);
            }
        }
    }

    public static class DecompositionDebug
    {
        public static void DrawBvh(EmpartDecomposer.BVH bvh)
        {
            if (bvh == null) return;
            bvh.DrawGizmos();
        }

        public static void DrawVoxels(EmpartDecomposer.MeshData mesh)
        {
            Gizmos.color = new Color(0, 1, 1, 0.1f);
            for (int i = 0; i < mesh.sdfValues.Length; i++)
            {
                if (mesh.sdfValues[i] < 0) // Inside
                {
                    var coord = new int3(i % mesh.voxelDimensions.x, (i / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, i / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                    var worldPos = mesh.VoxelToWorld(coord);
                    Gizmos.DrawCube(worldPos, mesh.voxelBounds.size / new Vector3(mesh.voxelDimensions.x, mesh.voxelDimensions.y, mesh.voxelDimensions.z));
                }
            }
        }

        public static void DrawWitnessPoints(EmpartDecomposer.ConvexHull hull)
        {
            Gizmos.color = Color.red;
            foreach (var p in hull.witnessPoints)
            {
                Gizmos.DrawSphere(p, 0.01f);
            }
        }

        public static void DrawSplitPlanes(List<(Vector3 point, Vector3 normal)> planes)
        {
            Gizmos.color = Color.cyan;
            foreach(var plane in planes)
            {
                var point = plane.point;
                var normal = plane.normal;
                var v3 = new Vector3();

                if (normal.normalized != Vector3.forward)
                    v3 = Vector3.Cross(normal, Vector3.forward).normalized * normal.magnitude;
                else
                    v3 = Vector3.Cross(normal, Vector3.up).normalized * normal.magnitude;

                var corner0 = point + v3;
                var corner2 = point - v3;
                var q = Quaternion.AngleAxis(90, normal);
                v3 = q * v3;
                var corner1 = point + v3;
                var corner3 = point - v3;

                Gizmos.DrawLine(corner0, corner2);
                Gizmos.DrawLine(corner1, corner3);
                Gizmos.DrawLine(corner0, corner1);
                Gizmos.DrawLine(corner1, corner2);
                Gizmos.DrawLine(corner2, corner3);
                Gizmos.DrawLine(corner3, corner0);
                Gizmos.DrawRay(point, normal * 1f);
            }
        }

        public static void DrawSaliencyHeatmap(EmpartDecomposer.MeshData mesh)
        {
            if(mesh.vertexSaliency == null || mesh.vertexSaliency.Count == 0) return;
            for(int i=0; i<mesh.indices.Count; i+=3)
            {
                var i0 = mesh.indices[i];
                var i1 = mesh.indices[i+1];
                var i2 = mesh.indices[i+2];

                var v0 = mesh.vertices[i0];
                var v1 = mesh.vertices[i1];
                var v2 = mesh.vertices[i2];

                var s0 = mesh.vertexSaliency[i0];
                var s1 = mesh.vertexSaliency[i1];
                var s2 = mesh.vertexSaliency[i2];

                var avgSaliency = (s0 + s1 + s2) / 3.0f;
                var color = Color.Lerp(Color.blue, Color.red, avgSaliency);

                Gizmos.color = color;
                Gizmos.DrawLine(v0, v1);
                Gizmos.DrawLine(v1, v2);
                Gizmos.DrawLine(v2, v0);
            }
        }
    }
}