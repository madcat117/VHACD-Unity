using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Empart.EmberPart
{
    /// <summary>
    /// Main convex decomposition system, implementing a production-ready V-HACD (Voxelized Hierarchical Approximate Convex Decomposition) algorithm.
    /// This class handles the full decomposition process, including voxelization, concavity measurement, plane splitting, hull generation, merging, and optimization.
    /// All components are consolidated into this single MonoBehaviour class for easy addition to Unity projects.
    /// </summary>
    public class EmpartDecomposer : MonoBehaviour
    {
        /// <summary>
        /// Quality presets for convex decomposition with detailed configurations
        /// </summary>
        public enum QualityPreset
        {
            Low,
            Medium,
            High,
            Ultra,
            Custom
        }
        /// <summary>
        /// Splitting strategies for hull decomposition
        /// </summary>
        public enum SplittingStrategy
        {
            Balanced,
            VolumeBased,
            SurfaceAreaBased,
            ConcavityBased,
            FeatureBased,
            Hybrid
        }
        /// <summary>
        /// Voxelization strategies for concavity calculation
        /// </summary>
        public enum VoxelizationStrategy
        {
            SurfaceOnly,
            SolidFill,
            RaycastBased,
            Hybrid,
            Adaptive
        }
        /// <summary>
        /// Merging strategies for hull optimization
        /// </summary>
        public enum MergingStrategy
        {
            VolumeBased,
            SurfaceAreaBased,
            DistanceBased,
            FeatureBased,
            Hierarchical,
            Adaptive
        }
        /// <summary>
        /// ACD subroutine types
        /// </summary>
        public enum ACDSubroutineType
        {
            VHACD,
            CoACD,
            QuickHull
        }
        /// <summary>
        /// Error metrics types for hull evaluation
        /// </summary>
        public enum ErrorMetricType
        {
            Hausdorff,
            MeanSquared,
            RootMeanSquared,
            SymmetricHausdorff,
            MaxDeviation,
            VolumeDifference,
            SurfaceAreaDifference
        }
        /// <summary>
        /// Sampling strategies for mesh surface
        /// </summary>
        public enum SamplingStrategy
        {
            Uniform,
            AreaWeighted,
            CurvatureWeighted,
            FeaturePreserving,
            Adaptive,
            Stratified
        }
        /// <summary>
        /// Additional enum for hull optimization strategies
        /// </summary>
        public enum HullOptimizationStrategy
        {
            VertexReduction,
            FaceMerging,
            EdgeCollapse,
            IterativeRefinement,
            GeneticAlgorithm,
            SimulatedAnnealing
        }
        /// <summary>
        /// Enum for post-processing techniques
        /// </summary>
        public enum PostProcessingType
        {
            None,
            Smoothing,
            Simplification,
            HoleFilling,
            BoundaryPreservation,
            SymmetryEnforcement
        }
        /// <summary>
        /// Burst-safe plane structure to replace UnityEngine.Plane
        /// </summary>
        public struct Plane4
        {
            public float3 n; // unit normal
            public float d; // ax + by + cz + d = 0
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public float DistanceToPoint(float3 p) => math.dot(n, p) + d;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool IntersectsRay(float3 rayOrigin, float3 rayDirection, out float t)
            {
                float denom = math.dot(n, rayDirection);
                if (math.abs(denom) < 1e-6f)
                {
                    t = 0f;
                    return false;
                }
                t = -(math.dot(n, rayOrigin) + d) / denom;
                return t > 0f;
            }
            // Additional utility: Project point onto plane
            public float3 ProjectPoint(float3 point)
            {
                return point - DistanceToPoint(point) * n;
            }
            // Equality check with epsilon
            public bool Equals(Plane4 other, float epsilon = 1e-5f)
            {
                return math.all(math.abs(n - other.n) < epsilon) && math.abs(d - other.d) < epsilon;
            }
            // Additional: Flip plane
            public void Flip()
            {
                n = -n;
                d = -d;
            }
            // Additional: Get plane equation string
            public string ToEquation()
            {
                return $"{n.x}x + {n.y}y + {n.z}z + {d} = 0";
            }
        }
        /// <summary>
        /// Simple max-priority queue for Unity (replaces System.Collections.Generic.PriorityQueue)
        /// </summary>
        public sealed class MaxPQ<T>
        {
            readonly List<(T item, float key)> _data = new();
            readonly IComparer<float> _cmp = Comparer<float>.Default;
            public int Count => _data.Count;
            public void Enqueue(T item, float key)
            {
                _data.Add((item, key));
                int i = _data.Count - 1;
                while (i > 0)
                {
                    int p = (i - 1) >> 1;
                    if (_cmp.Compare(_data[i].key, _data[p].key) <= 0) break;
                    (_data[i], _data[p]) = (_data[p], _data[i]);
                    i = p;
                }
            }
            public T Dequeue()
            {
                if (_data.Count == 0) throw new InvalidOperationException("Queue is empty");
                var root = _data[0].item;
                int last = _data.Count - 1;
                _data[0] = _data[last];
                _data.RemoveAt(last);
                int i = 0;
                while (true)
                {
                    int l = i * 2 + 1, r = l + 1, largest = i;
                    if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                    if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                    if (largest == i) break;
                    (_data[i], _data[largest]) = (_data[largest], _data[i]);
                    i = largest;
                }
                return root;
            }
            public T Peek()
            {
                if (_data.Count == 0) throw new InvalidOperationException("Queue is empty");
                return _data[0].item;
            }
            public bool TryDequeue(out T item, out float key)
            {
                if (_data.Count == 0)
                {
                    item = default;
                    key = default;
                    return false;
                }
                key = _data[0].key;
                item = Dequeue();
                return true;
            }
            public void Clear() => _data.Clear();
            // Additional: Update priority of an item (inefficient, but useful for production)
            public void UpdatePriority(T item, float newKey)
            {
                int index = -1;
                for (int i = 0; i < _data.Count; i++)
                {
                    if (EqualityComparer<T>.Default.Equals(_data[i].item, item))
                    {
                        index = i;
                        break;
                    }
                }
                if (index == -1) return;
                float oldKey = _data[index].key;
                _data[index] = (_data[index].item, newKey);
                if (newKey > oldKey)
                {
                    // Heapify up
                    while (index > 0)
                    {
                        int p = (index - 1) >> 1;
                        if (_cmp.Compare(_data[index].key, _data[p].key) <= 0) break;
                        (_data[index], _data[p]) = (_data[p], _data[index]);
                        index = p;
                    }
                }
                else
                {
                    // Heapify down
                    while (true)
                    {
                        int l = index * 2 + 1, r = l + 1, largest = index;
                        if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                        if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                        if (largest == index) break;
                        (_data[index], _data[largest]) = (_data[largest], _data[index]);
                        index = largest;
                    }
                }
            }
            // Additional: Check if contains item
            public bool Contains(T item)
            {
                return _data.Any(d => EqualityComparer<T>.Default.Equals(d.item, item));
            }
            // Additional: Get all items
            public List<T> GetAllItems()
            {
                return _data.Select(d => d.item).ToList();
            }
            // Additional: Remove specific item
            public bool Remove(T item)
            {
                int index = -1;
                for (int i = 0; i < _data.Count; i++)
                {
                    if (EqualityComparer<T>.Default.Equals(_data[i].item, item))
                    {
                        index = i;
                        break;
                    }
                }
                if (index == -1) return false;
                int last = _data.Count - 1;
                _data[index] = _data[last];
                _data.RemoveAt(last);
                // Heapify down
                while (true)
                {
                    int l = index * 2 + 1, r = l + 1, largest = index;
                    if (l < _data.Count && _cmp.Compare(_data[l].key, _data[largest].key) > 0) largest = l;
                    if (r < _data.Count && _cmp.Compare(_data[r].key, _data[largest].key) > 0) largest = r;
                    if (largest == index) break;
                    (_data[index], _data[largest]) = (_data[largest], _data[index]);
                    index = largest;
                }
                return true;
            }
        }
        /// <summary>
        /// Approximate Vector3 comparer for duplicate vertex detection
        /// </summary>
        sealed class ApproxVec3Comparer : IEqualityComparer<Vector3>
        {
            readonly float eps;
            public ApproxVec3Comparer(float e) { eps = e; }
            public bool Equals(Vector3 a, Vector3 b) => (a - b).sqrMagnitude <= eps * eps;
            public int GetHashCode(Vector3 v) => HashCode.Combine(
                Mathf.RoundToInt(v.x / eps),
                Mathf.RoundToInt(v.y / eps),
                Mathf.RoundToInt(v.z / eps));
            // Additional: Distance between two points
            public float Distance(Vector3 a, Vector3 b)
            {
                return (a - b).magnitude;
            }
            // Additional: Check if close enough
            public bool IsClose(Vector3 a, Vector3 b, float tolerance)
            {
                return (a - b).sqrMagnitude <= tolerance * tolerance;
            }
        }
        /// <summary>
        /// Settings asset for convex decomposition
        /// </summary>
        [CreateAssetMenu(fileName = "ConvexDecompositionSettings", menuName = "Empart/Convex Decomposition Settings")]
        public class ConvexDecompositionSettings : ScriptableObject
        {
            [Header("Quality Settings")]
            public QualityPreset qualityPreset = QualityPreset.Medium;
            public float errorTolerance = 0.01f;
            public int maxHullCount = 32;
            public int maxVerticesPerHull = 64;
            public float concavityWeight = 0.5f;
            public float volumeWeight = 0.5f;
            public float balanceWeight = 0.1f;
            public float sahAlpha = 0.01f;
            public bool useSAH = true;
            [Header("Voxelization Settings")]
            public VoxelizationStrategy voxelizationStrategy = VoxelizationStrategy.Adaptive;
            public float voxelSize = 0.05f;
            public float voxelAdaptivity = 0.5f;
            public int maxVoxelCount = 1000000;
            public bool adaptiveBoundsPadding = true;
            public float boundsPaddingFactor = 0.1f;
            [Header("Splitting Settings")]
            public SplittingStrategy splittingStrategy = SplittingStrategy.Hybrid;
            public float minSplitVolume = 0.001f;
            public float minSplitRatio = 0.2f;
            public float splitConcavityThreshold = 0.1f;
            [Header("Merging Settings")]
            public MergingStrategy mergingStrategy = MergingStrategy.Adaptive;
            public float mergeThreshold = 0.05f;
            public float mergeConcavityThreshold = 0.01f;
            [Header("Advanced Settings")]
            public bool enableAsyncProcessing = true;
            public int maxThreadCount = 0; // 0 = auto-detect
            public bool enableProfiling = false;
            public bool enableDebugVisualization = false;
            public Material hullMaterial;
            public bool enableDiagnosticsUI = true;
            [Header("Units")]
            [Tooltip("Unity units per meter (1 = meters, 0.01 = centimeters, 0.001 = millimeters)")]
            public float unitsPerMeter = 1f;
            [Header("Error Metrics")]
            public ErrorMetricType primaryErrorMetric = ErrorMetricType.SymmetricHausdorff;
            public ErrorMetricType secondaryErrorMetric = ErrorMetricType.MeanSquared;
            public float errorMetricWeight = 0.7f;
            [Header("Sampling Settings")]
            public SamplingStrategy samplingStrategy = SamplingStrategy.AreaWeighted;
            public int baseSampleCount = 1000;
            public int maxSampleCount = 10000;
            public float sampleAdaptivityFactor = 2.0f;
            [Header("Optimization Settings")]
            public bool enableHullOptimization = true;
            public float hullOptimizationThreshold = 0.01f;
            public int maxOptimizationIterations = 10;
            public bool enableVertexReduction = true;
            public float vertexReductionThreshold = 0.001f;
        [Header("Debug Visualization Settings")]
            public bool enableDetailedLogging = false;
        [Tooltip("Shows the AABB of the BVH nodes.")]
        public bool drawBvh = false;
        [Tooltip("Shows the voxel grid.")]
        public bool drawVoxels = false;
        [Tooltip("Shows the computed SDF as a 3D texture (requires custom shader).")]
        public bool drawSdf = false;
        [Tooltip("Shows the witness points used for error calculation.")]
        public bool drawWitnessPoints = false;
        [Tooltip("Shows the split planes used during decomposition.")]
        public bool drawSplitPlanes = false;
        [Tooltip("Shows a heatmap of the mesh saliency.")]
        public bool drawSaliencyHeatmap = false;
            // Additional settings for production readiness
            [Header("Additional Production Settings")]
            public bool enableCacheResults = false;
            public string cacheFilePath = "decomposition_cache.json";
            public bool enableMultiResolution = false;
            public int multiResolutionLevels = 3;
            public float resolutionScaleFactor = 0.5f;
            public bool enableSymmetryDetection = true;
            public float symmetryTolerance = 0.01f;
            public bool enablePostProcessing = true;
            public int postProcessingIterations = 5;
            public float postProcessingThreshold = 0.005f;
            public enum SDFGenerationMethod
            {
                Basic,
                JumpFlooding
            }

            [Header("Voxel Specific Settings")]
            public bool enableSDF = true;
            public SDFGenerationMethod sdfMethod = SDFGenerationMethod.JumpFlooding;
            public float sdfResolutionFactor = 1.5f;
            public int sdfIterationCount = 5; // Used for smoothing/refinement
            public float sdfSmoothingFactor = 0.1f;
            // Additional settings for extended functionality
            [Header("Extended Optimization")]
            public HullOptimizationStrategy hullOptimizationStrategy = HullOptimizationStrategy.EdgeCollapse;
            public float optimizationConvergenceThreshold = 0.0001f;
            public int maxGeneticGenerations = 50;
            public float mutationRate = 0.1f;
            [Header("Post Processing")]
            public PostProcessingType postProcessingType = PostProcessingType.Smoothing;
            public float smoothingLambda = 0.5f;
            public int smoothingIterations = 3;
            public bool enableBoundaryLocking = true;

        [Header("Pre-Processing: Isotropic Remeshing")]
        [Tooltip("Enable isotropic remeshing as a pre-processing step to improve mesh quality.")]
        public bool enableIsotropicRemeshing = false;
        [Tooltip("The target edge length for the remeshed output.")]
        public float remeshTargetEdgeLength = 0.1f;
        [Tooltip("Number of remeshing iterations to perform.")]
        [Range(1, 10)] public int remeshIterations = 3;
        [Header("CoACD Settings")]
        [Tooltip("The primary ACD method to use for decomposition.")]
        public ACDSubroutineType acdMethod = ACDSubroutineType.CoACD;
        [Tooltip("Weight for preserving mesh features during splitting.")]
        [Range(0, 1)] public float featureWeight = 0.3f;
        [Tooltip("Weight for preserving sharp edges during splitting.")]
        [Range(0, 1)] public float sharpnessWeight = 0.2f;
        [Tooltip("Weight for preserving symmetry during splitting.")]
        [Range(0, 1)] public float symmetryWeight = 0.1f;
        [Tooltip("How aggressively to pre-calculate features.")]
        [Range(0, 1)] public float precomputationLevel = 0.5f;
        [Tooltip("Maximum number of feature points to sample.")]
        public int maxFeatureSamples = 500;
        [Tooltip("Angle threshold for detecting sharp edges.")]
        public float sharpEdgeAngle = 45f;

        public enum SaliencyMethod
        {
            Curvature,
            Geodesic,
            HeatDiffusion
        }
        [Header("Advanced Feature Detection")]
        [Tooltip("Method to use for calculating mesh saliency.")]
        public SaliencyMethod saliencyMethod = SaliencyMethod.HeatDiffusion;
        [Tooltip("Number of iterations for the heat diffusion simulation.")]
        [Range(1, 20)] public int heatDiffusionIterations = 10;
            /// <summary>
            /// Apply quality preset settings
            /// </summary>
            public void ApplyQualityPreset()
            {
                switch (qualityPreset)
                {
                    case QualityPreset.Low:
                        errorTolerance = 0.05f;
                        maxHullCount = 16;
                        maxVerticesPerHull = 32;
                        baseSampleCount = 500;
                        maxSampleCount = 2000;
                        voxelSize = 0.1f;
                        maxVoxelCount = 500000;
                        maxOptimizationIterations = 5;
                        break;
                    case QualityPreset.Medium:
                        errorTolerance = 0.01f;
                        maxHullCount = 32;
                        maxVerticesPerHull = 64;
                        baseSampleCount = 1000;
                        maxSampleCount = 5000;
                        voxelSize = 0.05f;
                        maxVoxelCount = 1000000;
                        maxOptimizationIterations = 10;
                        break;
                    case QualityPreset.High:
                        errorTolerance = 0.005f;
                        maxHullCount = 64;
                        maxVerticesPerHull = 128;
                        baseSampleCount = 2000;
                        maxSampleCount = 10000;
                        voxelSize = 0.02f;
                        maxVoxelCount = 2000000;
                        maxOptimizationIterations = 15;
                        break;
                    case QualityPreset.Ultra:
                        errorTolerance = 0.001f;
                        maxHullCount = 128;
                        maxVerticesPerHull = 256;
                        baseSampleCount = 5000;
                        maxSampleCount = 20000;
                        voxelSize = 0.01f;
                        maxVoxelCount = 5000000;
                        maxOptimizationIterations = 20;
                        break;
                }
            }
            private void OnValidate()
            {
                if (qualityPreset != QualityPreset.Custom)
                {
                    ApplyQualityPreset();
                }
                // Validate ranges
                errorTolerance = Mathf.Max(0.0001f, errorTolerance);
                maxHullCount = Mathf.Max(1, maxHullCount);
                maxVerticesPerHull = Mathf.Max(4, maxVerticesPerHull);
                voxelSize = Mathf.Max(0.001f, voxelSize);
                maxVoxelCount = Mathf.Max(1000, maxVoxelCount);
                mergeThreshold = Mathf.Max(0f, mergeThreshold);
            }
            // Additional method: Load from JSON for production
            public void LoadFromJson(string json)
            {
                JsonUtility.FromJsonOverwrite(json, this);
            }
            // Additional method: Save to JSON
            public string SaveToJson()
            {
                return JsonUtility.ToJson(this, true);
            }
            // Additional method: Reset to default
            public void ResetToDefault()
            {
                qualityPreset = QualityPreset.Medium;
                ApplyQualityPreset();
            }
            // Additional method: Copy from another settings
            public void CopyFrom(ConvexDecompositionSettings other)
            {
                JsonUtility.FromJsonOverwrite(JsonUtility.ToJson(other), this);
            }
        }
        /// <summary>
        /// Region box data structure
        /// </summary>
        [Serializable]
        public struct RegionBox
        {
            public Bounds AABB;
            public float epsilonMm;
            public int partBudgetMin;
            public int partBudgetMax;
            public bool preserveExact;
            public float priority;
            public string label;
            // Additional properties for production
            public bool enableCustomVoxelization;
            public float customVoxelSize;
            public bool enableRegionOptimization;
            public int regionOptimizationIterations;
            // Validation method
            public bool IsValid()
            {
                return AABB.size.x > 0 && AABB.size.y > 0 && AABB.size.z > 0 &&
                       partBudgetMin <= partBudgetMax && priority >= 0;
            }
            // Additional: Calculate volume
            public float Volume()
            {
                return AABB.size.x * AABB.size.y * AABB.size.z;
            }
            // Additional: Check intersection with another box
            public bool Intersects(RegionBox other)
            {
                return AABB.Intersects(other.AABB);
            }
        }
        /// <summary>
        /// Comprehensive data structure for mesh information with additional attributes
        /// </summary>
        public class MeshData
        {
            public List<Vector3> vertices = new List<Vector3>();
            public List<int> indices = new List<int>();
            public List<Vector3> normals = new List<Vector3>();
            public List<Vector2> uvs;
            public List<Vector4> tangents;
            public List<Color> colors;
            public List<Vector4> boneWeights;
            public List<int> submeshIndices;
            public Bounds bounds;
            public float volume;
            public float surfaceArea;
            public bool isClosed;
            public bool isManifold;
            public int vertexCount;
            public int triangleCount;
            public int edgeCount;
            public float averageEdgeLength;
            public float maxEdgeLength;
            public float minEdgeLength;
            public Dictionary<string, object> customAttributes = new Dictionary<string, object>();
            // Additional properties for advanced processing
            public List<Vector3> curvature;
            public List<float> vertexSaliency;
            public List<float> triangleSaliency;
            public List<int> sharpEdges;
            public List<int> featureVertices;
            public BVH accelerationStructure;
            public bool hasPrecomputedData;
            // Additional production properties
            public List<Vector3> edgeNormals;
            public List<float> vertexDensities;
            public bool hasUVs;
            public bool hasTangents;
            public bool hasColors;
            public bool hasBoneWeights;
            public float meshComplexityScore;
            public DateTime lastUpdated;
            public NativeArray<float> sdfValues; // For SDF integration
            public int3 voxelDimensions; // Voxel grid dimensions
            public Bounds voxelBounds; // Bounds of voxel grid
            // Additional: List of submeshes
            public List<MeshData> subMeshes = new List<MeshData>();
            // Additional: Topology information
            public int genus;
            public int eulerCharacteristic;
            /// <summary>
            /// Validate mesh data integrity
            /// </summary>
            public bool Validate()
            {
                if (vertices.Count < 3)
                    return false;
                if (indices.Count % 3 != 0)
                    return false;
                if (normals.Count > 0 && normals.Count != vertices.Count)
                    return false;
                if (uvs != null && uvs.Count > 0 && uvs.Count != vertices.Count)
                    return false;
                if (tangents != null && tangents.Count > 0 && tangents.Count != vertices.Count)
                    return false;
                if (colors != null && colors.Count > 0 && colors.Count != vertices.Count)
                    return false;
                // Check for invalid indices
                for (int i = 0; i < indices.Count; i++)
                {
                    if (indices[i] < 0 || indices[i] >= vertices.Count)
                        return false;
                }
                // Additional checks
                hasUVs = uvs != null && uvs.Count == vertices.Count;
                hasTangents = tangents != null && tangents.Count == vertices.Count;
                hasColors = colors != null && colors.Count == vertices.Count;
                hasBoneWeights = boneWeights != null && boneWeights.Count == vertices.Count;
                return true;
            }
            /// <summary>
            /// Calculate mesh properties
            /// </summary>
            public void CalculateProperties()
            {
                vertexCount = vertices.Count;
                triangleCount = indices.Count / 3;
                // Calculate bounds
                bounds = new Bounds();
                if (vertices.Count > 0)
                {
                    bounds = new Bounds(vertices[0], Vector3.zero);
                    foreach (var v in vertices)
                        bounds.Encapsulate(v);
                }
                // Calculate surface area
                surfaceArea = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    surfaceArea += Vector3.Cross(b - a, c - a).magnitude / 2f;
                }
                // Calculate volume (assuming closed mesh)
                volume = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    volume += Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                }
                volume = Mathf.Abs(volume);
                // Calculate edge statistics
                CalculateEdgeStatistics();
                // Check if mesh is closed
                isClosed = IsMeshClosed();
                // Check if mesh is manifold
                isManifold = IsMeshManifold();
                // Additional: Calculate complexity score
                meshComplexityScore = triangleCount * Mathf.Log(vertexCount + 1) / surfaceArea;
                lastUpdated = DateTime.Now;
                // Additional: Calculate Euler characteristic
                CalculateTopology();
            }
            private void CalculateEdgeStatistics()
            {
                var edges = new HashSet<(int, int)>();
                float totalLength = 0f;
                maxEdgeLength = 0f;
                minEdgeLength = float.MaxValue;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        // Only add to total length if this is a new edge
                        if (edges.Add((v1, v2)))
                        {
                            float length = Vector3.Distance(vertices[v1], vertices[v2]);
                            totalLength += length;
                            maxEdgeLength = Mathf.Max(maxEdgeLength, length);
                            minEdgeLength = Mathf.Min(minEdgeLength, length);
                        }
                    }
                }
                edgeCount = edges.Count;
                averageEdgeLength = edges.Count > 0 ? totalLength / edges.Count : 0f;
                // Additional: Calculate edge normals if needed
                if (edgeNormals == null) edgeNormals = new List<Vector3>(edgeCount);
                // Additional: Calculate variance of edge lengths
                float variance = 0f;
                foreach (var edge in edges)
                {
                    float length = Vector3.Distance(vertices[edge.Item1], vertices[edge.Item2]);
                    variance += (length - averageEdgeLength) * (length - averageEdgeLength);
                }
                variance /= edgeCount;
                customAttributes["EdgeLengthVariance"] = variance;
            }
            private bool IsMeshClosed()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Mesh is closed if all edges are shared by exactly 2 triangles
                foreach (var count in edgeCountDict.Values)
                {
                    if (count != 2)
                        return false;
                }
                return true;
            }
            private bool IsMeshManifold()
            {
                // Check for non-manifold edges
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Check for non-manifold edges
                foreach (var count in edgeCountDict.Values)
                {
                    if (count > 2)
                        return false;
                }
                // Additional check for vertex manifoldness
                var vertexEdges = new List<int>[vertices.Count];
                for (int vi = 0; vi < vertices.Count; vi++)
                {
                    vertexEdges[vi] = new List<int>();
                }
                foreach (var edge in edgeCountDict.Keys)
                {
                    vertexEdges[edge.Item1].Add(edge.Item2);
                    vertexEdges[edge.Item2].Add(edge.Item1);
                }
                for (int vi = 0; vi < vertices.Count; vi++)
                {
                    if (vertexEdges[vi].Count % 2 != 0) return false; // Odd number of edges at vertex
                }
                return true;
            }
            /// <summary>
            /// Optimize mesh data for processing
            /// </summary>
            public void Optimize()
            {
                // Remove duplicate vertices
                RemoveDuplicateVertices();
                // Remove degenerate triangles
                RemoveDegenerateTriangles();
                // Recalculate properties
                CalculateProperties();
                // Additional optimization: Weld close vertices
                WeldVertices(0.0001f);
                // Reindex for cache efficiency
                ReindexForCache();
                // Additional: Decimate mesh if needed
                if (vertexCount > 10000)
                    Decimate(0.1f);
            }
            private void WeldVertices(float threshold)
            {
                var comparer = new ApproxVec3Comparer(threshold);
                var newVerts = new List<Vector3>();
                var remap = new int[vertices.Count];
                var lookup = new Dictionary<Vector3, int>(comparer);
                for (int i = 0; i < vertices.Count; i++)
                {
                    var v = vertices[i];
                    if (!lookup.TryGetValue(v, out int ni))
                    {
                        ni = newVerts.Count;
                        newVerts.Add(v);
                        lookup[v] = ni;
                    }
                    remap[i] = ni;
                }
                for (int i = 0; i < indices.Count; i++)
                    indices[i] = remap[indices[i]];
                vertices = newVerts;
            }
            private void ReindexForCache()
            {
                // Example: spatially sort vertices, then remap indices accordingly.
                var order = Enumerable.Range(0, vertices.Count)
                                      .OrderBy(i => vertices[i].x)
                                      .ThenBy(i => vertices[i].y)
                                      .ThenBy(i => vertices[i].z)
                                      .ToArray();
                var inv = new int[order.Length];
                for (int newIdx = 0; newIdx < order.Length; newIdx++) inv[order[newIdx]] = newIdx;
                var newVerts = new List<Vector3>(vertices.Count);
                for (int newIdx = 0; newIdx < order.Length; newIdx++) newVerts.Add(vertices[order[newIdx]]);
                vertices = newVerts;
                for (int i = 0; i < indices.Count; i++) indices[i] = inv[indices[i]];
            }
            private void RemoveDuplicateVertices()
            {
                var newVerts = new List<Vector3>();
                var remap = new int[vertices.Count];
                var lookup = new Dictionary<Vector3, int>(new ApproxVec3Comparer(1e-6f));
                for (int i = 0; i < vertices.Count; i++)
                {
                    var v = vertices[i];
                    if (!lookup.TryGetValue(v, out int ni))
                    {
                        ni = newVerts.Count;
                        newVerts.Add(v);
                        lookup[v] = ni;
                    }
                    remap[i] = ni;
                }
                for (int i = 0; i < indices.Count; i++)
                    indices[i] = remap[indices[i]];
                vertices = newVerts;
                // Fixed: Remap other channels with proper sizing
                if (normals != null && normals.Count == remap.Length) normals = Remap(normals, remap, newVerts.Count);
                if (uvs != null && uvs.Count == remap.Length) uvs = Remap(uvs, remap, newVerts.Count);
                if (tangents != null && tangents.Count == remap.Length) tangents = Remap(tangents, remap, newVerts.Count);
                if (colors != null && colors.Count == remap.Length) colors = Remap(colors, remap, newVerts.Count);
            }
            static List<T> Remap<T>(List<T> src, int[] remap, int newSize)
            {
                var dst = new List<T>(newSize);
                for (int i = 0; i < newSize; i++) dst.Add(default);
                for (int i = 0; i < remap.Length; i++)
                    dst[remap[i]] = src[i];
                return dst;
            }
            private void RemoveDegenerateTriangles()
            {
                int oldCount = indices.Count;
                var newIndices = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    // Check if triangle is degenerate
                    var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    if (area > 1e-6f)
                    {
                        newIndices.Add(indices[i]);
                        newIndices.Add(indices[i + 1]);
                        newIndices.Add(indices[i + 2]);
                    }
                }
                indices = newIndices;
                // Additional: Log removed count
                if (enableDetailedLoggingStatic)
                    Debug.Log($"Removed {(oldCount - indices.Count) / 3} degenerate triangles");
            }
            /// <summary>
            /// Calculate vertex curvature
            /// </summary>
            public void CalculateCurvature()
            {
                if (normals == null || normals.Count != vertices.Count)
                {
                    CalculateNormals();
                }
                curvature = new List<Vector3>(vertices.Count);
                for (int i = 0; i < vertices.Count; i++)
                {
                    curvature.Add(Vector3.zero);
                }
                // Calculate curvature using normal differences
                for (int i = 0; i < vertices.Count; i++)
                {
                    var normal = normals[i];
                    var curvatureVector = Vector3.zero;
                    int neighborCount = 0;
                    // Find neighboring vertices
                    for (int j = 0; j < indices.Count; j += 3)
                    {
                        bool containsVertex = false;
                        int other1 = -1, other2 = -1;
                        for (int k = 0; k < 3; k++)
                        {
                            if (indices[j + k] == i)
                            {
                                containsVertex = true;
                            }
                            else if (other1 == -1)
                            {
                                other1 = indices[j + k];
                            }
                            else
                            {
                                other2 = indices[j + k];
                            }
                        }
                        if (containsVertex && other1 != -1 && other2 != -1)
                        {
                            var normal1 = normals[other1];
                            var normal2 = normals[other2];
                            curvatureVector += (normal1 - normal) + (normal2 - normal);
                            neighborCount += 2;
                        }
                    }
                    if (neighborCount > 0)
                    {
                        curvature[i] = curvatureVector / neighborCount;
                    }
                }
                // Additional: Smooth curvature
                SmoothCurvature(1);
            }
            private void SmoothCurvature(int iterations)
            {
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newCurvature = new List<Vector3>(curvature);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        Vector3 sum = curvature[i];
                        int count = 1;
                        // Add neighbors
                        for (int j = 0; j < indices.Count; j += 3)
                        {
                            if (indices[j] == i || indices[j + 1] == i || indices[j + 2] == i)
                            {
                                for (int k = 0; k < 3; k++)
                                {
                                    if (indices[j + k] != i)
                                    {
                                        sum += curvature[indices[j + k]];
                                        count++;
                                    }
                                }
                            }
                        }
                        newCurvature[i] = sum / count;
                    }
                    curvature = newCurvature;
                }
            }
            /// <summary>
            /// Calculate vertex saliency using the specified method.
            /// </summary>
            public void CalculateSaliency(ConvexDecompositionSettings.SaliencyMethod method, int heatIterations = 10)
            {
                vertexSaliency = new List<float>(new float[vertices.Count]);
                triangleSaliency = new List<float>(new float[triangleCount]);

                switch(method)
                {
                    case ConvexDecompositionSettings.SaliencyMethod.HeatDiffusion:
                        var heat = Geodesic.CalculateHeat(this, heatIterations);
                        float maxHeat = 0;
                        for(int i=0; i<heat.Count; i++) maxHeat = Mathf.Max(maxHeat, heat[i]);
                        if(maxHeat > 0)
                        {
                            for(int i=0; i<heat.Count; i++) vertexSaliency[i] = heat[i] / maxHeat;
                        }
                        break;

                    case ConvexDecompositionSettings.SaliencyMethod.Geodesic:
                         // Placeholder for a more complex geodesic saliency metric
                         // For now, we'll fall back to curvature.
                    case ConvexDecompositionSettings.SaliencyMethod.Curvature:
                    default:
                        if (curvature == null || curvature.Count != vertices.Count) CalculateCurvature();
                        float maxCurvature = 0f;
                        for (int i = 0; i < vertices.Count; i++)
                        {
                            vertexSaliency[i] = curvature[i].magnitude;
                            maxCurvature = Mathf.Max(maxCurvature, vertexSaliency[i]);
                        }
                        if (maxCurvature > 0f)
                        {
                            for (int i = 0; i < vertices.Count; i++) vertexSaliency[i] /= maxCurvature;
                        }
                        break;
                }

                // Calculate triangle saliency as the average of its vertex saliencies
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    triangleSaliency[triIndex] = (vertexSaliency[indices[i]] + vertexSaliency[indices[i+1]] + vertexSaliency[indices[i+2]]) / 3.0f;
                }
            }
        }

        /// <summary>
        /// Provides methods for computing geodesic distances and related properties on a mesh.
        /// Uses the "Heat Method" for a fast and robust calculation.
        /// </summary>
        public static class Geodesic
        {
            // The heat method involves solving two linear systems. For a production Unity script
            // without external libraries, we'll use an iterative solver (Jacobi method)
            // which can be implemented with Burst and Jobs.

            [BurstCompile]
            private struct JacobiSolverJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<float> A_values; // Flattened Laplacian matrix
                [ReadOnly] public NativeArray<int> A_indices;
                [ReadOnly] public NativeArray<int> A_pointers;
                [ReadOnly] public NativeArray<float> b; // Right-hand side vector
                public NativeArray<float> x; // Solution vector (e.g., heat or distance)
                [ReadOnly] public int iterations;

                public void Execute(int index)
                {
                    for (int iter = 0; iter < iterations; iter++)
                    {
                        float sigma = 0;
                        int row_start = A_pointers[index];
                        int row_end = A_pointers[index + 1];

                        for(int j = row_start; j < row_end; j++)
                        {
                            int col = A_indices[j];
                            if(col != index)
                            {
                                sigma += A_values[j] * x[col];
                            }
                        }

                        float a_ii = 0;
                        for(int j = row_start; j < row_end; j++) { if(A_indices[j] == index) a_ii = A_values[j]; }

                        if(Mathf.Abs(a_ii) > 1e-6)
                        {
                           x[index] = (b[index] - sigma) / a_ii;
                        }
                    }
                }
            }

            public static List<float> CalculateHeat(MeshData mesh, int iterations)
            {
                int n = mesh.vertexCount;
                var L = BuildCotanLaplacian(mesh);
                var M = BuildMassMatrix(mesh);

                var heat = new NativeArray<float>(n, Allocator.TempJob);
                // Initial condition: heat source at a random vertex
                heat[UnityEngine.Random.Range(0, n)] = 1.0f;

                // Time-stepping (implicit Euler)
                // (M - t*L)u_t = u_t-1
                // This forms a linear system Ax = b where A = M - t*L, x = u_t, b = u_t-1
                float t = Mathf.Pow(mesh.averageEdgeLength, 2);
                var A = new SparseMatrix(n, n);
                for(int i=0; i<n; i++)
                {
                    A.Set(i,i, M.Get(i,i) - t * L.Get(i,i));
                    var neighbors = L.GetRow(i);
                    foreach(var neighbor in neighbors)
                    {
                         A.Set(i, neighbor.Key, -t * neighbor.Value);
                    }
                }

                var solver = new JacobiSolverJob
                {
                    A_values = A.values,
                    A_indices = A.indices,
                    A_pointers = A.pointers,
                    b = heat,
                    x = new NativeArray<float>(n, Allocator.TempJob),
                    iterations = iterations
                };
                solver.Schedule(n, 64).Complete();

                var result = new List<float>(solver.x.ToArray());

                heat.Dispose();
                solver.x.Dispose();
                A.Dispose();
                M.Dispose();
                L.Dispose();

                return result;
            }

            private static SparseMatrix BuildCotanLaplacian(MeshData mesh)
            {
                var L = new SparseMatrix(mesh.vertexCount, mesh.vertexCount);
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    Vector3 p0 = mesh.vertices[i0], p1 = mesh.vertices[i1], p2 = mesh.vertices[i2];

                    float cot_alpha = Vector3.Dot(p1 - p0, p2 - p0) / Vector3.Cross(p1 - p0, p2 - p0).magnitude;
                    float cot_beta = Vector3.Dot(p2 - p1, p0 - p1) / Vector3.Cross(p2 - p1, p0 - p1).magnitude;
                    float cot_gamma = Vector3.Dot(p0 - p2, p1 - p2) / Vector3.Cross(p0 - p2, p1 - p2).magnitude;

                    L.Add(i0, i1, -cot_gamma); L.Add(i1, i0, -cot_gamma);
                    L.Add(i1, i2, -cot_alpha); L.Add(i2, i1, -cot_alpha);
                    L.Add(i2, i0, -cot_beta); L.Add(i0, i2, -cot_beta);

                    L.Add(i0, i0, cot_beta + cot_gamma);
                    L.Add(i1, i1, cot_alpha + cot_gamma);
                    L.Add(i2, i2, cot_alpha + cot_beta);
                }
                return L;
            }

            private static SparseMatrix BuildMassMatrix(MeshData mesh)
            {
                var M = new SparseMatrix(mesh.vertexCount, mesh.vertexCount);
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    Vector3 p0 = mesh.vertices[i0], p1 = mesh.vertices[i1], p2 = mesh.vertices[i2];
                    float area = Vector3.Cross(p1-p0, p2-p0).magnitude / 2.0f;
                    M.Add(i0, i0, area / 3.0f);
                    M.Add(i1, i1, area / 3.0f);
                    M.Add(i2, i2, area / 3.0f);
                }
                return M;
            }
        }

        /// <summary>
        /// A simple sparse matrix implementation using CSR format for use with Burst/Jobs.
        /// </summary>
        public class SparseMatrix : IDisposable
        {
            public NativeArray<float> values;
            public NativeArray<int> indices; // column indices
            public NativeArray<int> pointers; // row pointers
            private Dictionary<int, float>[] rows;
            private int n, m;

            public SparseMatrix(int n_rows, int n_cols)
            {
                this.n = n_rows;
                this.m = n_cols;
                rows = new Dictionary<int, float>[n];
                for(int i=0; i<n; i++) rows[i] = new Dictionary<int, float>();
            }

            public void Set(int r, int c, float val) { rows[r][c] = val; }
            public void Add(int r, int c, float val) { rows[r][c] = Get(r,c) + val; }
            public float Get(int r, int c) { return rows[r].TryGetValue(c, out float v) ? v : 0; }
            public Dictionary<int, float> GetRow(int r) { return rows[r]; }

            public void ToNativeArrays()
            {
                int nnz = rows.Sum(row => row.Count);
                values = new NativeArray<float>(nnz, Allocator.TempJob);
                indices = new NativeArray<int>(nnz, Allocator.TempJob);
                pointers = new NativeArray<int>(n + 1, Allocator.TempJob);

                int val_idx = 0;
                for (int i = 0; i < n; i++)
                {
                    pointers[i] = val_idx;
                    foreach (var pair in rows[i].OrderBy(p => p.Key))
                    {
                        values[val_idx] = pair.Value;
                        indices[val_idx] = pair.Key;
                        val_idx++;
                    }
                }
                pointers[n] = val_idx;
            }

            public void Dispose()
            {
                if(values.IsCreated) values.Dispose();
                if(indices.IsCreated) indices.Dispose();
                if(pointers.IsCreated) pointers.Dispose();
            }
            /// <summary>
            /// Identify sharp edges
            /// </summary>
            public void IdentifySharpEdges(float angleThreshold = 30f)
            {
                if (normals == null || normals.Count != vertices.Count)
                {
                    CalculateNormals();
                }
                sharpEdges = new List<int>();
                float cosThreshold = Mathf.Cos(angleThreshold * Mathf.Deg2Rad);
                // Find edges with sharp angle between adjacent faces
                var edgeNormalsDict = new Dictionary<(int, int), List<Vector3>>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var normal = Vector3.Cross(
                        vertices[indices[i + 1]] - vertices[indices[i]],
                        vertices[indices[i + 2]] - vertices[indices[i]]
                    ).normalized;
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (!edgeNormalsDict.ContainsKey(edge))
                        {
                            edgeNormalsDict[edge] = new List<Vector3>();
                        }
                        edgeNormalsDict[edge].Add(normal);
                    }
                }
                // Check for sharp edges
                foreach (var kvp in edgeNormalsDict)
                {
                    if (kvp.Value.Count >= 2)
                    {
                        bool isSharp = false;
                        for (int m = 0; m < kvp.Value.Count - 1; m++)
                        {
                            for (int n = m + 1; n < kvp.Value.Count; n++)
                            {
                                float dot = Vector3.Dot(kvp.Value[m], kvp.Value[n]);
                                if (dot < cosThreshold)
                                {
                                    isSharp = true;
                                    break;
                                }
                            }
                            if (isSharp) break;
                        }
                        if (isSharp)
                        {
                            sharpEdges.Add(kvp.Key.Item1);
                            sharpEdges.Add(kvp.Key.Item2);
                        }
                    }
                }
                // Additional: Sort sharp edges for efficiency
                sharpEdges.Sort();
                // Additional: Calculate edge angles
                CalculateEdgeAngles();
            }
            private void CalculateEdgeAngles()
            {
                // Implementation for calculating angles on sharp edges
                for (int k = 0; k < sharpEdges.Count; k += 2)
                {
                    int v1 = sharpEdges[k];
                    int v2 = sharpEdges[k + 1];
                    // Find adjacent faces
                    // ... (add logic to calculate angle)
                }
            }
            /// <summary>
            /// Identify feature vertices
            /// </summary>
            public void IdentifyFeatureVertices(float saliencyThreshold = 0.5f)
            {
                if (vertexSaliency == null || vertexSaliency.Count != vertices.Count)
                {
                    CalculateSaliency();
                }
                featureVertices = new List<int>();
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (vertexSaliency[i] > saliencyThreshold)
                    {
                        featureVertices.Add(i);
                    }
                }
                // Additional: Cluster features
                ClusterFeatures(0.01f);
                // Additional: Prioritize features
                PrioritizeFeatures();
            }
            private void ClusterFeatures(float clusterDistance)
            {
                // Simple clustering to group close features
                var clustered = new List<List<int>>();
                foreach (var fv in featureVertices)
                {
                    bool added = false;
                    foreach (var cluster in clustered)
                    {
                        if (Vector3.Distance(vertices[fv], vertices[cluster[0]]) < clusterDistance)
                        {
                            cluster.Add(fv);
                            added = true;
                            break;
                        }
                    }
                    if (!added)
                    {
                        clustered.Add(new List<int> { fv });
                    }
                }
                // Replace with cluster representatives
                featureVertices.Clear();
                foreach (var cluster in clustered)
                {
                    featureVertices.Add(cluster[0]); // Use first as rep
                }
            }
            private void PrioritizeFeatures()
            {
                // Sort features by saliency
                featureVertices = featureVertices.OrderByDescending(f => vertexSaliency[f]).ToList();
            }
            /// <summary>
            /// Build acceleration structure for fast queries
            /// </summary>
            public void BuildAccelerationStructure()
            {
                accelerationStructure = new BVH(this);
                hasPrecomputedData = true;
                // Additional: Build additional structures if needed
                if (enableDetailedLoggingStatic)
                    Debug.Log("Acceleration structure built.");
            }
            /// <summary>
            /// Calculate normals if not present
            /// </summary>
            private void CalculateNormals()
            {
                normals = new List<Vector3>(vertices.Count);
                for (int i = 0; i < vertices.Count; i++)
                {
                    normals.Add(Vector3.zero);
                }
                // Calculate face normals and accumulate
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int i0 = indices[i];
                    int i1 = indices[i + 1];
                    int i2 = indices[i + 2];
                    var v0 = vertices[i0];
                    var v1 = vertices[i1];
                    var v2 = vertices[i2];
                    var normal = Vector3.Cross(v1 - v0, v2 - v0).normalized;
                    normals[i0] += normal;
                    normals[i1] += normal;
                    normals[i2] += normal;
                }
                // Normalize accumulated normals
                for (int i = 0; i < normals.Count; i++)
                {
                    normals[i] = normals[i].normalized;
                }
                // Additional: Smooth normals
                SmoothNormals(1);
            }
            private void SmoothNormals(int iterations)
            {
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newNormals = new List<Vector3>(normals);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        Vector3 sum = normals[i];
                        int count = 1;
                        // Add neighbors
                        for (int j = 0; j < indices.Count; j += 3)
                        {
                            if (indices[j] == i || indices[j + 1] == i || indices[j + 2] == i)
                            {
                                for (int k = 0; k < 3; k++)
                                {
                                    if (indices[j + k] != i)
                                    {
                                        sum += normals[indices[j + k]];
                                        count++;
                                    }
                                }
                            }
                        }
                        newNormals[i] = (sum / count).normalized;
                    }
                    normals = newNormals;
                }
            }
            /// <summary>
            /// Voxelize the mesh
            /// </summary>
            public void Voxelize(float voxelSize, VoxelizationStrategy strategy, float adaptivity = 0.5f)
            {
                voxelBounds = bounds;
                voxelBounds.Expand(voxelSize * 2); // Padding
                voxelDimensions = new int3(
                    Mathf.CeilToInt(voxelBounds.size.x / voxelSize),
                    Mathf.CeilToInt(voxelBounds.size.y / voxelSize),
                    Mathf.CeilToInt(voxelBounds.size.z / voxelSize)
                );
                int voxelCount = voxelDimensions.x * voxelDimensions.y * voxelDimensions.z;
                if (voxelCount > 10000000) {
                    if(enableDetailedLoggingStatic) Debug.LogWarning("Voxel count exceeds limit, aborting voxelization.");
                    return;
                }
                sdfValues = new NativeArray<float>(voxelCount, Allocator.Persistent);
                // Depending on strategy
                switch (strategy)
                {
                    case VoxelizationStrategy.SolidFill:
                        VoxelizeSolidFill();
                        break;
                    case VoxelizationStrategy.RaycastBased:
                        VoxelizeRaycast();
                        break;
                    case VoxelizationStrategy.Adaptive:
                        VoxelizeAdaptive(voxelSize, adaptivity);
                        break;
                    // Add other strategies...
                    default:
                        VoxelizeSolidFill();
                        break;
                }
                // Additional: Validate voxelization
                ValidateVoxelization();
            }

            private void VoxelizeAdaptive(float baseVoxelSize, float adaptivity)
            {
                // Adaptive voxelization: uses a higher resolution grid in areas of high curvature.
                if (curvature == null) CalculateCurvature();

                // 1. Initial low-resolution voxelization
                VoxelizeSolidFill();

                // 2. Identify regions for refinement
                var refinementRegions = new HashSet<int3>();
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (curvature[i].magnitude > 0.5f) // Curvature threshold
                    {
                        refinementRegions.Add(WorldToVoxel(vertices[i]));
                    }
                }

                if (refinementRegions.Count == 0) return;

                // 3. Create a higher-resolution grid for the refinement pass
                float refinedVoxelSize = baseVoxelSize * (1.0f - adaptivity);
                var refinedDimensions = new int3(
                    Mathf.CeilToInt(voxelBounds.size.x / refinedVoxelSize),
                    Mathf.CeilToInt(voxelBounds.size.y / refinedVoxelSize),
                    Mathf.CeilToInt(voxelBounds.size.z / refinedVoxelSize)
                );
                int refinedVoxelCount = refinedDimensions.x * refinedDimensions.y * refinedDimensions.z;
                if (refinedVoxelCount > 2 * sdfValues.Length) { // Safety cap
                    if(enableDetailedLoggingStatic) Debug.LogWarning("Refined voxel count too high, skipping adaptive step.");
                    return;
                }

                var refinedSDF = new NativeArray<float>(refinedVoxelCount, Allocator.TempJob);

                // 4. Run a focused, high-resolution voxelization job on the identified regions
                var job = new VoxelizationJob
                {
                    Vertices = new NativeArray<Vector3>(vertices.ToArray(), Allocator.TempJob),
                    Indices = new NativeArray<int>(indices.ToArray(), Allocator.TempJob),
                    SDFValues = refinedSDF,
                    VoxelBounds = voxelBounds,
                    VoxelDimensions = refinedDimensions,
                    VoxelSize = voxelBounds.size / new float3(refinedDimensions)
                };
                job.Schedule(refinedVoxelCount, 64).Complete();

                // 5. Merge the high-resolution data back into the original grid
                for(int i=0; i<sdfValues.Length; i++)
                {
                    var coord = new int3(i % voxelDimensions.x, (i / voxelDimensions.x) % voxelDimensions.y, i / (voxelDimensions.x * voxelDimensions.y));
                    if(refinementRegions.Contains(coord))
                    {
                        // Downsample the refined area back to the original grid
                        float averageSDF = 0;
                        int sampleCount = 0;
                        var worldPos = VoxelToWorld(coord);
                        var refinedCoord = new int3(
                            Mathf.FloorToInt((worldPos.x - voxelBounds.min.x) / refinedVoxelSize),
                            Mathf.FloorToInt((worldPos.y - voxelBounds.min.y) / refinedVoxelSize),
                            Mathf.FloorToInt((worldPos.z - voxelBounds.min.z) / refinedVoxelSize)
                        );

                        for(int x=-1; x<=1; x++) for(int y=-1; y<=1; y++) for(int z=-1; z<=1; z++)
                        {
                            var sampleCoord = refinedCoord + new int3(x,y,z);
                            if(sampleCoord.x >= 0 && sampleCoord.x < refinedDimensions.x &&
                               sampleCoord.y >= 0 && sampleCoord.y < refinedDimensions.y &&
                               sampleCoord.z >= 0 && sampleCoord.z < refinedDimensions.z)
                            {
                                int refinedIdx = sampleCoord.x + refinedDimensions.x * (sampleCoord.y + refinedDimensions.y * sampleCoord.z);
                                averageSDF += refinedSDF[refinedIdx];
                                sampleCount++;
                            }
                        }
                        if(sampleCount > 0) sdfValues[i] = averageSDF / sampleCount;
                    }
                }
                job.Vertices.Dispose();
                job.Indices.Dispose();
                refinedSDF.Dispose();
                if (enableDetailedLoggingStatic) Debug.Log($"Refined {refinementRegions.Count} voxel regions.");
            }

            private int3 WorldToVoxel(Vector3 worldPos)
            {
                var localPos = worldPos - voxelBounds.min;
                var voxelSize = voxelBounds.size / new Vector3(voxelDimensions.x, voxelDimensions.y, voxelDimensions.z);
                return new int3(
                    Mathf.FloorToInt(localPos.x / voxelSize.x),
                    Mathf.FloorToInt(localPos.y / voxelSize.y),
                    Mathf.FloorToInt(localPos.z / voxelSize.z)
                );
            }

            private bool IsVoxelInBounds(int3 coord)
            {
                return coord.x >= 0 && coord.x < voxelDimensions.x &&
                       coord.y >= 0 && coord.y < voxelDimensions.y &&
                       coord.z >= 0 && coord.z < voxelDimensions.z;
            }
            private void VoxelizeSolidFill()
            {
                // Use job system for voxelization
                var job = new VoxelizationJob
                {
                    Vertices = new NativeArray<Vector3>(vertices.ToArray(), Allocator.TempJob),
                    Indices = new NativeArray<int>(indices.ToArray(), Allocator.TempJob),
                    SDFValues = sdfValues,
                    VoxelBounds = voxelBounds,
                    VoxelDimensions = voxelDimensions,
                    VoxelSize = voxelBounds.size / new float3(voxelDimensions)
                };
                job.Schedule(sdfValues.Length, 64).Complete();
                job.Vertices.Dispose();
                job.Indices.Dispose();
            }
            private void VoxelizeRaycast()
            {
                // Implement raycast-based voxelization
                // For each voxel, raycast to determine if inside
                for (int x = 0; x < voxelDimensions.x; x++)
                {
                    for (int y = 0; y < voxelDimensions.y; y++)
                    {
                        for (int z = 0; z < voxelDimensions.z; z++)
                        {
                            Vector3 voxelPos = VoxelToWorld(new int3(x, y, z));
                            bool inside = IsPointInside(voxelPos);
                            sdfValues[GetVoxelIndex(new int3(x, y, z))] = inside ? -1f : 1f; // Simple signed distance
                        }
                    }
                }
            }
            private int GetVoxelIndex(int3 coord)
            {
                return coord.x + voxelDimensions.x * (coord.y + voxelDimensions.y * coord.z);
            }
            private Vector3 VoxelToWorld(int3 coord)
            {
                return voxelBounds.min + new Vector3(coord.x, coord.y, coord.z) * (voxelBounds.size / new Vector3(voxelDimensions));
            }
            private bool IsPointInside(Vector3 point)
            {
                // Raycast in multiple directions to count crossings
                int crossings = 0;
                Vector3[] directions = { Vector3.right, Vector3.up, Vector3.forward };
                foreach (var dir in directions)
                {
                    int hits = Physics.RaycastAll(point, dir, float.MaxValue).Length;
                    crossings += hits % 2;
                }
                return crossings > 1; // Majority vote
            }
            private void ValidateVoxelization()
            {
                // Check if voxel count matches
                if (sdfValues.Length != voxelDimensions.x * voxelDimensions.y * voxelDimensions.z)
                {
                    Debug.LogError("Voxelization validation failed: mismatched count");
                }
            }
            /// <summary>
            /// Compute SDF from voxel grid
            /// </summary>
            public void ComputeSDF(ConvexDecompositionSettings.SDFGenerationMethod method, int iterations = 5, float smoothing = 0.1f)
            {
                if (!enableSDF || sdfValues.Length == 0) return;

                switch (method)
                {
                    case ConvexDecompositionSettings.SDFGenerationMethod.JumpFlooding:
                        JumpFlooding.GenerateSDF(this);
                        break;
                    case ConvexDecompositionSettings.SDFGenerationMethod.Basic:
                    default:
                        // Use fast marching method or iterative smoothing for SDF
                        for (int iter = 0; iter < iterations; iter++)
                        {
                            var newSDF = new NativeArray<float>(sdfValues, Allocator.Temp);
                            for (int x = 1; x < voxelDimensions.x - 1; x++)
                            {
                                for (int y = 1; y < voxelDimensions.y - 1; y++)
                                {
                                    for (int z = 1; z < voxelDimensions.z - 1; z++)
                                    {
                                        int idx = GetVoxelIndex(new int3(x, y, z));
                                        float sum = 0f;
                                        int count = 0;
                                        // Neighbor offsets
                                        int3[] offsets = { new int3(1, 0, 0), new int3(-1, 0, 0), new int3(0, 1, 0), new int3(0, -1, 0), new int3(0, 0, 1), new int3(0, 0, -1) };
                                        foreach (var off in offsets)
                                        {
                                            int nIdx = GetVoxelIndex(new int3(x, y, z) + off);
                                            sum += sdfValues[nIdx];
                                            count++;
                                        }
                                        newSDF[idx] = sdfValues[idx] * (1 - smoothing) + (sum / count) * smoothing;
                                    }
                                }
                            }
                            sdfValues.CopyFrom(newSDF);
                            newSDF.Dispose();
                        }
                        break;
                }
            }
            /// <summary>
            /// Decimate mesh to reduce vertex count
            /// </summary>
            public void Decimate(float targetReduction)
            {
                // Simple decimation logic
                int targetVertices = Mathf.RoundToInt(vertices.Count * (1 - targetReduction));
                while (vertices.Count > targetVertices)
                {
                    // Remove vertex with lowest cost
                    // ... (add decimation algorithm)
                }
            }
            /// <summary>
            /// Calculate topology properties
            /// </summary>
            private void CalculateTopology()
            {
                // Euler characteristic V - E + F
                int V = vertexCount;
                int E = edgeCount;
                int F = triangleCount;
                eulerCharacteristic = V - E + F;
                // Genus for closed manifold mesh
                if (isClosed && isManifold)
                {
                    genus = (2 - eulerCharacteristic) / 2;
                }
            }
        }
        /// <summary>
        /// Voxelization job for burst compilation
        /// </summary>
        [BurstCompile]
        public struct VoxelizationJob : IJobParallelFor
        {
            [ReadOnly] public NativeArray<Vector3> Vertices;
            [ReadOnly] public NativeArray<int> Indices;
            public NativeArray<float> SDFValues;
            public Bounds VoxelBounds;
            public int3 VoxelDimensions;
            public float3 VoxelSize;
            public void Execute(int index)
            {
                int z = index / (VoxelDimensions.x * VoxelDimensions.y);
                int y = (index / VoxelDimensions.x) % VoxelDimensions.y;
                int x = index % VoxelDimensions.x;
                float3 voxelPos = VoxelBounds.min + new float3(x, y, z) * VoxelSize;
                // Check intersection with triangles
                bool inside = false;
                for (int i = 0; i < Indices.Length; i += 3)
                {
                    float3 a = Vertices[Indices[i]];
                    float3 b = Vertices[Indices[i + 1]];
                    float3 c = Vertices[Indices[i + 2]];
                    // Simple point in triangle test or ray intersection count
                    // For simplicity, use bounding box check first
                    if (math.all(voxelPos >= math.min(math.min(a, b), c)) && math.all(voxelPos <= math.max(math.max(a, b), c)))
                    {
                        inside = !inside; // Toggle for parity
                    }
                }
                SDFValues[index] = inside ? -VoxelSize.x : VoxelSize.x; // Approximate SDF
            }
        }
        /// <summary>
        /// Comprehensive data structure for decomposition metrics with detailed tracking
        /// </summary>
        [Serializable]
        public class DecompositionMetrics
        {
            // Basic metrics
            public int vertexCount;
            public int triangleCount;
            public int hullCount;
            public float totalTime;
            public float extractionTime;
            public float segmentationTime;
            public float voxelizationTime;
            public float bvhTime;
            public float decompositionTime;
            public float optimizationTime;
            public float mergingTime;
            public float finalizationTime;
            // Advanced metrics
            public float totalVolume;
            public float totalSurfaceArea;
            public float averageHullVolume;
            public float averageHullSurfaceArea;
            public float maxHullVolume;
            public float minHullVolume;
            public float maxHullSurfaceArea;
            public float minHullSurfaceArea;
            public float averageConcavity;
            public float maxConcavity;
            public float minConcavity;
            public float averageError;
            public float maxError;
            public float minError;
            public float volumeReduction;
            public float surfaceAreaReduction;
            public float compressionRatio;
            // Original mesh metrics for proper reduction calculation
            public float originalMeshVolume;
            public float originalMeshSurfaceArea;
            // Performance metrics
            public int memoryUsage;
            public int peakMemoryUsage;
            public float cpuUsage;
            public int jobCount;
            public int threadCount;
            public float jobOverhead;
            public float schedulingOverhead;
            // Quality metrics
            public float hausdorffDistance;
            public float meanSquaredError;
            public float rootMeanSquaredError;
            public float peakSignalToNoiseRatio;
            public float structuralSimilarityIndex;
            // Custom metrics
            public List<StringFloatKV> customMetrics = new List<StringFloatKV>();
            // Region metrics
            public List<RegionMetrics> regionMetrics = new List<RegionMetrics>();
            // Hull metrics
            public List<HullMetrics> hullMetrics = new List<HullMetrics>();
            // Error distribution metrics
            public List<float> errorDistribution = new List<float>();
            public float errorStandardDeviation;
            public float errorMedian;
            public float error90thPercentile;
            public float error95thPercentile;
            public float error99thPercentile;
            // Processing stage metrics
            public Dictionary<string, float> stageTimes = new Dictionary<string, float>();
            public Dictionary<string, int> stageOperations = new Dictionary<string, int>();
            // Memory metrics per stage
            public Dictionary<string, int> stageMemoryUsage = new Dictionary<string, int>();
            // Additional production metrics
            public float averageProcessingTimePerHull;
            public float totalVoxelizationVolume;
            public int totalVoxelCount;
            public float mergeEfficiency;
            public float splitEfficiency;
            public int failedSplits;
            public int successfulMerges;
            public float overallQualityScore;
            // Additional: Distribution statistics
            public float errorVariance;
            public float errorSkew;
            public float errorKurtosis;
            /// <summary>
            /// Calculate derived metrics
            /// </summary>
            public void CalculateDerivedMetrics()
            {
                if (hullMetrics.Count > 0)
                {
                    totalVolume = hullMetrics.Sum(h => h.volume);
                    totalSurfaceArea = hullMetrics.Sum(h => h.surfaceArea);
                    averageHullVolume = totalVolume / hullMetrics.Count;
                    averageHullSurfaceArea = totalSurfaceArea / hullMetrics.Count;
                    maxHullVolume = hullMetrics.Max(h => h.volume);
                    minHullVolume = hullMetrics.Min(h => h.volume);
                    maxHullSurfaceArea = hullMetrics.Max(h => h.surfaceArea);
                    minHullSurfaceArea = hullMetrics.Min(h => h.surfaceArea);
                    averageConcavity = hullMetrics.Average(h => h.concavity);
                    maxConcavity = hullMetrics.Max(h => h.concavity);
                    minConcavity = hullMetrics.Min(h => h.concavity);
                    averageError = hullMetrics.Average(h => h.hausdorffError);
                    maxError = hullMetrics.Max(h => h.hausdorffError);
                    minError = hullMetrics.Min(h => h.hausdorffError);
                    // Calculate error distribution statistics
                    CalculateErrorDistributionStatistics();
                }
                // Calculate compression ratios
                if (originalMeshVolume > 0)
                    volumeReduction = (originalMeshVolume - totalVolume) / originalMeshVolume;
                if (originalMeshSurfaceArea > 0)
                    surfaceAreaReduction = (originalMeshSurfaceArea - totalSurfaceArea) / originalMeshSurfaceArea;
                if (vertexCount > 0)
                    compressionRatio = (float)hullCount / vertexCount;
                // Additional derived
                averageProcessingTimePerHull = totalTime / hullCount;
                overallQualityScore = (1 - averageError) * (1 - volumeReduction) * compressionRatio;
            }
            /// <summary>
            /// Calculate error distribution statistics
            /// </summary>
            private void CalculateErrorDistributionStatistics()
            {
                if (errorDistribution.Count == 0) return;
                // Sort error values
                var sortedErrors = new List<float>(errorDistribution);
                sortedErrors.Sort();
                // Calculate median
                int count = sortedErrors.Count;
                if (count % 2 == 0)
                {
                    errorMedian = (sortedErrors[count / 2 - 1] + sortedErrors[count / 2]) / 2f;
                }
                else
                {
                    errorMedian = sortedErrors[count / 2];
                }
                // Calculate percentiles
                error90thPercentile = sortedErrors[Mathf.FloorToInt(0.9f * (count - 1))];
                error95thPercentile = sortedErrors[Mathf.FloorToInt(0.95f * (count - 1))];
                error99thPercentile = sortedErrors[Mathf.FloorToInt(0.99f * (count - 1))];
                // Calculate standard deviation
                float mean = sortedErrors.Average();
                float sumOfSquares = sortedErrors.Sum(x => (x - mean) * (x - mean));
                errorStandardDeviation = Mathf.Sqrt(sumOfSquares / count);
                // Additional: Variance and skew
                float variance = sumOfSquares / count;
                float skewSum = sortedErrors.Sum(x => Mathf.Pow(x - mean, 3));
                float skew = skewSum / (count * Mathf.Pow(variance, 1.5f));
                AddCustomMetric("ErrorVariance", variance);
                AddCustomMetric("ErrorSkew", skew);
                // Additional: Kurtosis
                float kurtSum = sortedErrors.Sum(x => Mathf.Pow(x - mean, 4));
                errorKurtosis = (kurtSum / (count * variance * variance)) - 3;
                AddCustomMetric("ErrorKurtosis", errorKurtosis);
            }
            /// <summary>
            /// Record stage time
            /// </summary>
            public void RecordStageTime(string stageName, float time)
            {
                if (stageTimes.ContainsKey(stageName))
                {
                    stageTimes[stageName] += time;
                }
                else
                {
                    stageTimes[stageName] = time;
                }
                // Additional: Log if profiling
                if (enableProfilingStatic)
                    Debug.Log($"Stage {stageName} time: {time:F3}s");
            }
            /// <summary>
            /// Record stage operation count
            /// </summary>
            public void RecordStageOperation(string stageName, int count = 1)
            {
                if (stageOperations.ContainsKey(stageName))
                {
                    stageOperations[stageName] += count;
                }
                else
                {
                    stageOperations[stageName] = count;
                }
            }
            /// <summary>
            /// Record stage memory usage
            /// </summary>
            public void RecordStageMemoryUsage(string stageName, int memoryUsageBytes)
            {
                stageMemoryUsage[stageName] = memoryUsageBytes;
                peakMemoryUsage = Mathf.Max(peakMemoryUsage, memoryUsageBytes);
            }
            /// <summary>
            /// Add custom metric
            /// </summary>
            public void AddCustomMetric(string key, float value)
            {
                customMetrics.Add(new StringFloatKV(key, value));
            }
            // Additional method: Export to CSV for production analysis
            public void ExportToCSV(string filePath)
            {
                using (var writer = new StreamWriter(filePath))
                {
                    writer.WriteLine("Metric,Value");
                    writer.WriteLine($"VertexCount,{vertexCount}");
                    writer.WriteLine($"TriangleCount,{triangleCount}");
                    writer.WriteLine($"HullCount,{hullCount}");
                    writer.WriteLine($"TotalTime,{totalTime}");
                    // ... add all others
                    foreach (var kv in customMetrics)
                    {
                        writer.WriteLine($"{kv.key},{kv.value}");
                    }
                }
            }
            // Additional method: Export to JSON
            public string ExportToJson()
            {
                return JsonUtility.ToJson(this, true);
            }
            // Additional method: Clear metrics
            public void ClearMetrics()
            {
                customMetrics.Clear();
                regionMetrics.Clear();
                hullMetrics.Clear();
                stageTimes.Clear();
                stageOperations.Clear();
                stageMemoryUsage.Clear();
            }
        }
        /// <summary>
        /// Helper class for serializing dictionaries
        /// </summary>
        [Serializable]
        public class StringFloatKV
        {
            public string key;
            public float value;
            public StringFloatKV(string key, float value)
            {
                this.key = key;
                this.value = value;
            }
        }
        /// <summary>
        /// Metrics for individual regions
        /// </summary>
        [Serializable]
        public class RegionMetrics
        {
            public int regionId;
            public int vertexCount;
            public int triangleCount;
            public int hullCount;
            public float volume;
            public float surfaceArea;
            public float saliency;
            public float processingTime;
            public Bounds bounds;
            public Vector3 principalAxis;
            public List<StringFloatKV> customMetrics = new List<StringFloatKV>();
            // Error metrics for this region
            public float averageError;
            public float maxError;
            public float minError;
            public float errorStandardDeviation;
            // Processing metrics
            public int splitCount;
            public int mergeCount;
            public int optimizationIterations;
            // Quality metrics
            public float concavity;
            public float compactness;
            public float aspectRatio;
            // Additional
            public float regionComplexity;
            public int voxelCount;
            public float voxelFillRatio;
            // Additional: Region specific
            public float regionDensity;
            public int boundaryEdges;
            public void CalculateDerived()
            {
                regionComplexity = triangleCount * (1 + saliency);
                voxelFillRatio = voxelCount > 0 ? volume / voxelCount : 0;
                regionDensity = volume > 0 ? vertexCount / volume : 0;
            }
        }
        /// <summary>
        /// Metrics for individual hulls
        /// </summary>
        [Serializable]
        public class HullMetrics
        {
            public int hullId;
            public int regionId;
            public int vertexCount;
            public int triangleCount;
            public float volume;
            public float surfaceArea;
            public float concavity;
            public float hausdorffError;
            public float meanSquaredError;
            public float maxDeviation;
            public Bounds bounds;
            public Vector3 centroid;
            public List<StringFloatKV> customMetrics = new List<StringFloatKV>();
            // Additional quality metrics
            public float compactness;
            public float aspectRatio;
            public float sphericity;
            public float elongation;
            public float flatness;
            // Processing metrics
            public bool wasMerged;
            public int mergeCount;
            public float optimizationTime;
            public int optimizationIterations;
            // Additional
            public float hullEfficiency;
            public bool isOptimized;
            // Additional: Symmetry metrics
            public int symmetryAxesCount;
            public float symmetryScore;
            public void CalculateDerived()
            {
                hullEfficiency = volume / surfaceArea;
                isOptimized = optimizationIterations > 0;
                symmetryScore = symmetryAxesCount / 3f;
            }
        }
        /// <summary>
        /// Represents a convex hull with comprehensive properties and methods
        /// </summary>
        public class ConvexHull
        {
            public List<Vector3> vertices = new List<Vector3>();
            public List<int> indices = new List<int>();
            public List<Vector3> normals = new List<Vector3>();
            public Bounds bounds;
            public float volume;
            public float surfaceArea;
            public float hausdorffError;
            public float meanSquaredError;
            public float maxDeviation;
            public float concavity;
            public int regionId;
            public int hullId;
            public List<HullEdge> edges = new List<HullEdge>();
            public List<PlaneF> planes = new List<PlaneF>();
            public Vector3 centroid;
            public float inertiaTensor;
            public Matrix4x4 inertiaMatrix;
            public float quality;
            public bool isValid;
            public List<int> neighborHulls = new List<int>();
            public Dictionary<string, object> customProperties = new Dictionary<string, object>();
            // Additional properties for advanced processing
            public List<Vector3> witnessPoints;
            public List<float> witnessErrors;
            public MeshData meshData;
            public BVH accelerationStructure;
            public bool hasPrecomputedData;
            public float compactness;
            public float aspectRatio;
            public float sphericity;
            public float elongation;
            public float flatness;
            // Additional production properties
            public bool isOptimized;
            public float optimizationScore;
            public DateTime creationTime;
            public List<Vector3> symmetryAxes;
            // Additional: Hull topology
            public int genus;
            public int eulerCharacteristic;
            /// <summary>
            /// Optimize hull to reduce vertex count while maintaining shape
            /// </summary>
            public void OptimizeHull(ConvexDecompositionSettings settings, float errorTolerance, HullOptimizationStrategy strategy = HullOptimizationStrategy.VertexReduction, int maxGenerations = 50, float mutationRate = 0.1f)
            {
                if (vertices.Count <= 8) return;

                switch (strategy)
                {
                    case HullOptimizationStrategy.VertexReduction:
                        var removed = new bool[vertices.Count];
                        var costs = new float[vertices.Count];
                        for (int i = 0; i < vertices.Count; i++)
                        {
                            costs[i] = CalculateVertexRemovalError(i);
                        }
                        int targetCount = Mathf.Max(8, (int)(vertices.Count * (1 - errorTolerance)));
                        int removedCount = 0;
                        while (vertices.Count - removedCount > targetCount)
                        {
                            float minCost = float.MaxValue;
                            int minIndex = -1;
                            for (int i = 0; i < vertices.Count; i++)
                            {
                                if (!removed[i] && costs[i] < minCost)
                                {
                                    minCost = costs[i];
                                    minIndex = i;
                                }
                            }
                            if (minIndex == -1) break;
                            removed[minIndex] = true;
                            removedCount++;
                        }
                        RebuildHull(removed);
                        break;
                    case HullOptimizationStrategy.EdgeCollapse:
                        EdgeCollapse(errorTolerance);
                        break;
                    case HullOptimizationStrategy.SimulatedAnnealing:
                        SimulatedAnnealing(1000, 0.99f);
                        break;
                    case HullOptimizationStrategy.GeneticAlgorithm:
                        GeneticAlgorithm(maxGenerations, 20, mutationRate);
                        break;
                }

                isOptimized = true;
                // Recalculate all properties after optimization
                CalculateProperties();
                BuildPlanes();
                BuildEdges();
                ValidateHull();
                // Additional: Apply post-optimization smoothing
                SmoothHull(settings.smoothingIterations, settings.smoothingLambda, settings.enableBoundaryLocking);
            }
            private void EdgeCollapse(float tolerance)
            {
                int targetCount = Mathf.Max(4, (int)(vertices.Count * (1.0f - tolerance)));
                var sortedEdges = new List<HullEdge>(edges.OrderBy(e => e.length));

                var adjacency = BuildAdjacency();

                while (vertices.Count > targetCount && sortedEdges.Count > 0)
                {
                    var edge = sortedEdges[0];
                    sortedEdges.RemoveAt(0);

                    int u = edge.vertex1;
                    int v = edge.vertex2;

                    // Collapse edge to its midpoint
                    var midpoint = (vertices[u] + vertices[v]) / 2.0f;
                    vertices[u] = midpoint;

                    // Update all triangles that used 'v' to now use 'u'
                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        if (indices[i] == v) indices[i] = u;
                        if (indices[i + 1] == v) indices[i + 1] = u;
                        if (indices[i + 2] == v) indices[i + 2] = u;
                    }

                    // Remove degenerate triangles
                    var newIndices = new List<int>();
                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        if (indices[i] != indices[i+1] && indices[i] != indices[i+2] && indices[i+1] != indices[i+2])
                        {
                            newIndices.AddRange(new []{indices[i], indices[i+1], indices[i+2]});
                        }
                    }
                    indices = newIndices;
                }

                // Clean up unused vertices and re-index the mesh
                RemoveUnusedVertices();
                BuildEdges(); // Rebuild edges after modification
            }

            private Dictionary<int, List<int>> BuildAdjacency()
            {
                var adj = new Dictionary<int, List<int>>();
                for(int i=0; i<vertices.Count; i++) adj[i] = new List<int>();
                foreach(var edge in edges)
                {
                    adj[edge.vertex1].Add(edge.vertex2);
                    adj[edge.vertex2].Add(edge.vertex1);
                }
                return adj;
            }

            private void SimulatedAnnealing(float initialTemp, float coolingRate)
            {
                var currentSolution = new List<Vector3>(vertices);
                float currentEnergy = CalculateEnergy(currentSolution);

                for (float t = initialTemp; t > 1; t *= coolingRate)
                {
                    var newSolution = new List<Vector3>(currentSolution);
                    // Perturb the solution by moving a random vertex
                    int randomIndex = UnityEngine.Random.Range(0, newSolution.Count);
                    newSolution[randomIndex] += UnityEngine.Random.onUnitSphere * 0.1f;

                    float newEnergy = CalculateEnergy(newSolution);

                    if (newEnergy < currentEnergy || UnityEngine.Random.value < Mathf.Exp((currentEnergy - newEnergy) / t))
                    {
                        currentSolution = newSolution;
                        currentEnergy = newEnergy;
                    }
                }
                vertices = currentSolution;
            }

            private void GeneticAlgorithm(int generations, int populationSize, float mutationRate)
            {
                var population = new List<List<Vector3>>();
                for (int i = 0; i < populationSize; i++)
                {
                    population.Add(new List<Vector3>(vertices)); // Start with the original hull
                }

                for (int gen = 0; gen < generations; gen++)
                {
                    var newPopulation = new List<List<Vector3>>();
                    // Elitism: Keep the best solution
                    var best = population.OrderBy(p => CalculateEnergy(p)).First();
                    newPopulation.Add(new List<Vector3>(best));

                    while (newPopulation.Count < populationSize)
                    {
                        var parent1 = Select(population);
                        var parent2 = Select(population);
                        var child = Crossover(parent1, parent2);
                        if (UnityEngine.Random.value < mutationRate)
                        {
                            Mutate(child);
                        }
                        newPopulation.Add(child);
                    }
                    population = newPopulation;
                }
                vertices = population.OrderBy(p => CalculateEnergy(p)).First();
            }

            private float CalculateEnergy(List<Vector3> solution)
            {
                // Energy function: A combination of hull volume and compactness.
                // We avoid re-computing the hull for every energy calculation.
                // This is a simplified energy function. A more robust one would
                // also consider the Hausdorff distance to the original mesh.
                if (solution.Count < 4) return float.MaxValue;

                // Use the existing hull's properties as a proxy for the energy of the solution
                var bounds = new Bounds(solution[0], Vector3.zero);
                foreach(var v in solution) bounds.Encapsulate(v);

                // A simple energy function: combination of volume and surface area of the bounding box
                float volume = bounds.size.x * bounds.size.y * bounds.size.z;
                float surfaceArea = 2 * (bounds.size.x * bounds.size.y + bounds.size.x * bounds.size.z + bounds.size.y * bounds.size.z);

                if (surfaceArea < 1e-6) return float.MaxValue;

                return volume * 0.7f + surfaceArea * 0.3f;
            }

            private List<Vector3> Select(List<List<Vector3>> population)
            {
                // Tournament selection
                var tournament = population.OrderBy(x => UnityEngine.Random.value).Take(5).ToList();
                return tournament.OrderBy(p => CalculateEnergy(p)).First();
            }

            private List<Vector3> Crossover(List<Vector3> p1, List<Vector3> p2)
            {
                int crossoverPoint = UnityEngine.Random.Range(1, p1.Count - 1);
                var child = new List<Vector3>();
                child.AddRange(p1.Take(crossoverPoint));
                child.AddRange(p2.Skip(crossoverPoint));
                return child;
            }

            private void Mutate(List<Vector3> solution)
            {
                int index = UnityEngine.Random.Range(0, solution.Count);
                solution[index] += UnityEngine.Random.onUnitSphere * 0.1f;
            }

            private void RemoveUnusedVertices()
            {
                var used = new HashSet<int>(indices);
                var remap = new int[vertices.Count];
                var newVerts = new List<Vector3>();
                int newIdx = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (used.Contains(i))
                    {
                        remap[i] = newIdx;
                        newVerts.Add(vertices[i]);
                        newIdx++;
                    }
                }

                for (int i = 0; i < indices.Count; i++)
                {
                    indices[i] = remap[indices[i]];
                }
                vertices = newVerts;
            }

            private float CalculateVertexRemovalError(int vertexIndex)
            {
                // Calculate error introduced by removing this vertex
                float error = 0f;
                var vertex = vertices[vertexIndex];
                // Find all triangles using this vertex
                var affectedTriangles = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    if (indices[i] == vertexIndex ||
                        indices[i + 1] == vertexIndex ||
                        indices[i + 2] == vertexIndex)
                    {
                        affectedTriangles.Add(i);
                    }
                }
                // Calculate error for each affected triangle
                foreach (var triIndex in affectedTriangles)
                {
                    var i1 = indices[triIndex];
                    var i2 = indices[triIndex + 1];
                    var i3 = indices[triIndex + 2];
                    // Skip if triangle would become degenerate
                    if ((i1 == vertexIndex && i2 == vertexIndex) ||
                        (i2 == vertexIndex && i3 == vertexIndex) ||
                        (i3 == vertexIndex && i1 == vertexIndex))
                    {
                        error += float.MaxValue;
                        continue;
                    }
                    // Calculate distance from vertex to opposite edge
                    var v1 = vertices[i1];
                    var v2 = vertices[i2];
                    var v3 = vertices[i3];
                    Vector3 edge1, edge2;
                    if (i1 == vertexIndex)
                    {
                        edge1 = v3 - v2;
                        edge2 = vertex - v2;
                    }
                    else if (i2 == vertexIndex)
                    {
                        edge1 = v1 - v3;
                        edge2 = vertex - v3;
                    }
                    else
                    {
                        edge1 = v2 - v1;
                        edge2 = vertex - v1;
                    }
                    var distance = Vector3.Cross(edge1, edge2).magnitude / edge1.magnitude;
                    error += distance * distance; // Use squared for better scaling
                }
                return error;
            }
            private void RebuildHull(bool[] removedVertices)
            {
                // Create vertex remapping
                var vertexMap = new Dictionary<int, int>();
                var newVertices = new List<Vector3>();
                int newIndex = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (!removedVertices[i])
                    {
                        vertexMap[i] = newIndex;
                        newVertices.Add(vertices[i]);
                        newIndex++;
                    }
                }
                // Rebuild indices
                var newIndices = new List<int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var i1 = indices[i];
                    var i2 = indices[i + 1];
                    var i3 = indices[i + 2];
                    // Skip triangles with removed vertices
                    if (removedVertices[i1] || removedVertices[i2] || removedVertices[i3])
                        continue;
                    newIndices.Add(vertexMap[i1]);
                    newIndices.Add(vertexMap[i2]);
                    newIndices.Add(vertexMap[i3]);
                }
                // Update hull
                vertices = newVertices;
                indices = newIndices;
                // Recalculate properties
                CalculateProperties();
                // Additional: Update normals if present
                if (normals.Count > 0)
                {
                    var newNormals = new List<Vector3>(newVertices.Count);
                    for (int k = 0; k < newVertices.Count; k++) newNormals.Add(Vector3.zero);
                    foreach (var kv in vertexMap)
                        if (kv.Value < newNormals.Count && kv.Key < normals.Count)
                            newNormals[kv.Value] = normals[kv.Key];
                    normals = newNormals;
                }
            }
            /// <summary>
            /// Check if point is inside hull
            /// </summary>
            public bool ContainsPoint(Vector3 point)
            {
                // Use precomputed planes for faster containment checks
                for (int i = 0; i < planes.Count; i++)
                {
                    var plane = planes[i];
                    if (Vector3.Dot(plane.n, point) + plane.d > 1e-3f)
                        return false;
                }
                return true;
            }
            /// <summary>
            /// Calculate distance from point to hull surface
            /// </summary>
            public float DistanceToPoint(Vector3 point)
            {
                if (ContainsPoint(point))
                    return 0f;
                float minDistance = float.MaxValue;
                // Check distance to each triangle
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    // Calculate distance to triangle
                    var distance = DistanceToTriangle(point, a, b, c);
                    minDistance = Mathf.Min(minDistance, distance);
                }
                return minDistance;
            }
            private float DistanceToTriangle(Vector3 point, Vector3 a, Vector3 b, Vector3 c)
            {
                // Calculate closest point on triangle to the given point
                var ab = b - a;
                var ac = c - a;
                var ap = point - a;
                var d1 = Vector3.Dot(ab, ap);
                var d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0f && d2 <= 0f)
                    return Vector3.Distance(point, a);
                var bp = point - b;
                var d3 = Vector3.Dot(ab, bp);
                var d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0f && d4 <= d3)
                    return Vector3.Distance(point, b);
                var vc = d1 * d4 - d3 * d2;
                if (vc <= 0f && d1 >= 0f && d3 <= 0f)
                {
                    var v = d1 / (d1 - d3);
                    return Vector3.Distance(point, a + v * ab);
                }
                var cp = point - c;
                var d5 = Vector3.Dot(ab, cp);
                var d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0f && d5 <= d6)
                    return Vector3.Distance(point, c);
                var vb = d5 * d2 - d1 * d6;
                if (vb <= 0f && d2 >= 0f && d6 <= 0f)
                {
                    var w = d2 / (d2 - d6);
                    return Vector3.Distance(point, a + w * ac);
                }
                var va = d3 * d6 - d5 * d4;
                if (va <= 0f && (d4 - d3) >= 0f && (d5 - d6) >= 0f)
                {
                    var w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                    return Vector3.Distance(point, b + w * (c - b));
                }
                // Inside triangle
                var denom = 1f / (va + vb + vc);
                var v2 = vb * denom;
                var w2 = vc * denom;
                var closestPoint = a + ab * v2 + ac * w2;
                return Vector3.Distance(point, closestPoint);
            }
            /// <summary>
            /// Precompute face planes for faster containment checks
            /// </summary>
            public void BuildPlanes()
            {
                planes.Clear();
                if (vertices.Count == 0) return;
                // Calculate centroid
                centroid = Vector3.zero;
                foreach (var v in vertices)
                    centroid += v;
                centroid /= vertices.Count;
                // Build planes for each triangle
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var n = Vector3.Cross(b - a, c - a);
                    n.Normalize();
                    var d = -Vector3.Dot(n, a);
                    // Ensure normal points outward
                    if (Vector3.Dot(n, centroid) + d > 0f)
                    {
                        n = -n;
                        d = -d;
                    }
                    planes.Add(new PlaneF { n = n, d = d });
                }
                // Additional: Optimize planes list
                planes = planes.Distinct(new PlaneFComparer()).ToList();
            }
            class PlaneFComparer : IEqualityComparer<PlaneF>
            {
                public bool Equals(PlaneF x, PlaneF y)
                {
                    return Vector3.Dot(x.n, y.n) > 0.99f && Mathf.Abs(x.d - y.d) < 0.001f;
                }
                public int GetHashCode(PlaneF obj)
                {
                    const float q = 1e-3f;
                    var n = new Vector3(Mathf.Round(obj.n.x / q) * q, Mathf.Round(obj.n.y / q) * q, Mathf.Round(obj.n.z / q) * q);
                    var d = Mathf.Round(obj.d / q) * q;
                    return n.GetHashCode() ^ d.GetHashCode();
                }
            }
            /// <summary>
            /// Calculate hull properties
            /// </summary>
            public void CalculateProperties()
            {
                // Calculate bounds
                bounds = new Bounds();
                if (vertices.Count > 0)
                {
                    bounds = new Bounds(vertices[0], Vector3.zero);
                    foreach (var v in vertices)
                        bounds.Encapsulate(v);
                }
                // Calculate centroid
                centroid = Vector3.zero;
                foreach (var v in vertices)
                    centroid += v;
                if (vertices.Count > 0)
                    centroid /= vertices.Count;
                // Calculate volume
                volume = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    volume += Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                }
                volume = Mathf.Abs(volume);
                // Calculate surface area
                surfaceArea = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    surfaceArea += Vector3.Cross(b - a, c - a).magnitude / 2f;
                }
                // Calculate inertia tensor
                CalculateInertiaTensor();
                // Calculate shape metrics
                CalculateShapeMetrics();
                // Build edges
                BuildEdges();
                // Validate hull
                ValidateHull();
                // Additional: Calculate symmetry
                DetectSymmetry();
                creationTime = DateTime.Now;
                // Additional: Calculate topology
                CalculateTopology();
            }
            private void CalculateInertiaTensor()
            {
                // Calculate inertia tensor using parallel axis theorem
                float xx = 0f, yy = 0f, zz = 0f, xy = 0f, xz = 0f, yz = 0f;
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    // Calculate tetrahedron contribution to inertia
                    float vol = Vector3.Dot(a, Vector3.Cross(b, c)) / 6f;
                    if (vol <= 0) continue;
                    // Center of mass of tetrahedron
                    var com = (a + b + c) / 4f;
                    // Inertia contribution
                    xx += vol * (com.y * com.y + com.z * com.z);
                    yy += vol * (com.x * com.x + com.z * com.z);
                    zz += vol * (com.x * com.x + com.y * com.y);
                    xy -= vol * com.x * com.y;
                    xz -= vol * com.x * com.z;
                    yz -= vol * com.y * com.z;
                }
                // Build inertia tensor matrix
                inertiaMatrix = new Matrix4x4(
                    new Vector4(xx, xy, xz, 0),
                    new Vector4(xy, yy, yz, 0),
                    new Vector4(xz, yz, zz, 0),
                    new Vector4(0, 0, 0, 1)
                );
                // Calculate scalar inertia tensor (trace)
                inertiaTensor = xx + yy + zz;
            }
            /// <summary>
            /// Calculate shape metrics for quality assessment
            /// </summary>
            private void CalculateShapeMetrics()
            {
                if (volume <= 1e-6f || surfaceArea <= 1e-6f)
                {
                    compactness = sphericity = aspectRatio = elongation = flatness = 0;
                    return;
                }
                // Calculate compactness (volume to surface area ratio)
                compactness = volume / surfaceArea;
                // Calculate sphericity (how sphere-like the shape is)
                float sphereSurfaceArea = Mathf.Pow(Mathf.PI, 1 / 3f) * Mathf.Pow(6 * volume, 2 / 3f);
                sphericity = sphereSurfaceArea / surfaceArea;
                // Calculate aspect ratio (based on bounding box)
                var size = bounds.size;
                var sortedSize = new float[] { size.x, size.y, size.z };
                Array.Sort(sortedSize);
                if (sortedSize[0] < 1e-6f)
                {
                    aspectRatio = elongation = flatness = 0;
                    return;
                }
                aspectRatio = sortedSize[2] / sortedSize[0]; // max / min
                // Calculate elongation and flatness
                elongation = (sortedSize[1] - sortedSize[0]) / sortedSize[2];
                flatness = sortedSize[0] / sortedSize[2];
                // Additional: Calculate more metrics like convexity measure
                float convexity = volume / bounds.size.x / bounds.size.y / bounds.size.z;
                customProperties["Convexity"] = convexity;
            }
            private void BuildEdges()
            {
                edges.Clear();
                var edgeSet = new HashSet<(int, int)>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    int i0 = indices[i];
                    int i1 = indices[i + 1];
                    int i2 = indices[i + 2];
                    // Add edges (ensure consistent ordering)
                    AddEdge(i0, i1, edgeSet);
                    AddEdge(i1, i2, edgeSet);
                    AddEdge(i2, i0, edgeSet);
                }
                // Additional: Sort edges by length
                edges.Sort((e1, e2) => e1.length.CompareTo(e2.length));
                // Additional: Calculate edge angles
                CalculateEdgeAngles();
            }
            private void AddEdge(int i1, int i2, HashSet<(int, int)> edgeSet)
            {
                // Ensure consistent ordering
                if (i1 > i2)
                {
                    (i1, i2) = (i2, i1);
                }
                var edge = (i1, i2);
                if (edgeSet.Add(edge))
                {
                    edges.Add(new HullEdge
                    {
                        vertex1 = i1,
                        vertex2 = i2,
                        length = Vector3.Distance(vertices[i1], vertices[i2])
                    });
                }
            }
            private void CalculateEdgeAngles()
            {
                // Calculate angles for each edge
                for (int k = 0; k < edges.Count; k++)
                {
                    var edge = edges[k];
                    // Find adjacent faces
                    List<Vector3> adjNormals = new List<Vector3>();
                    for (int m = 0; m < indices.Count; m += 3)
                    {
                        bool hasEdge = false;
                        for (int n = 0; n < 3; n++)
                        {
                            int v1 = indices[m + n];
                            int v2 = indices[m + (n + 1) % 3];
                            if ((v1 == edge.vertex1 && v2 == edge.vertex2) || (v1 == edge.vertex2 && v2 == edge.vertex1))
                            {
                                hasEdge = true;
                                break;
                            }
                        }
                        if (hasEdge)
                        {
                            var a = vertices[indices[m]];
                            var b = vertices[indices[m + 1]];
                            var c = vertices[indices[m + 2]];
                            var normal = Vector3.Cross(b - a, c - a).normalized;
                            adjNormals.Add(normal);
                        }
                    }
                    if (adjNormals.Count == 2)
                    {
                        edges[k].CalculateAngle(adjNormals[0], adjNormals[1]);
                    }
                }
            }
            private void ValidateHull()
            {
                isValid = true;
                if (vertices.Count < 4 || indices.Count < 12)
                {
                    isValid = false;
                    return;
                }

                if (!IsConvex() || !IsClosed() || !IsManifold())
                {
                    if (enableDetailedLoggingStatic) Debug.LogWarning("Hull is not manifold, attempting repair.");
                    RepairManifold();
                    // Re-validate after repair
                    if (!IsConvex() || !IsClosed() || !IsManifold())
                    {
                        isValid = false;
                        return;
                    }
                }

                // Check for degenerate triangles
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    if (area < 1e-6f)
                    {
                        isValid = false;
                        return;
                    }
                }
                // Additional: Check self-intersections
                if (HasSelfIntersections())
                {
                    isValid = false;
                }
            }
            private bool HasSelfIntersections()
            {
                // Basic check for intersecting triangles
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = i + 3; j < indices.Count; j += 3)
                    {
                        if (TrianglesIntersect(i, j))
                            return true;
                    }
                }
                return false;
            }
            private bool TrianglesIntersect(int tri1, int tri2)
            {
                var a1 = vertices[indices[tri1]];
                var b1 = vertices[indices[tri1 + 1]];
                var c1 = vertices[indices[tri1 + 2]];
                var a2 = vertices[indices[tri2]];
                var b2 = vertices[indices[tri2 + 1]];
                var c2 = vertices[indices[tri2 + 2]];
                // Check if any edge of tri1 intersects tri2
                if (LineTriangleIntersect(a1, b1, a2, b2, c2) ||
                    LineTriangleIntersect(b1, c1, a2, b2, c2) ||
                    LineTriangleIntersect(c1, a1, a2, b2, c2))
                    return true;
                // Check if any edge of tri2 intersects tri1
                if (LineTriangleIntersect(a2, b2, a1, b1, c1) ||
                    LineTriangleIntersect(b2, c2, a1, b1, c1) ||
                    LineTriangleIntersect(c2, a2, a1, b1, c1))
                    return true;
                return false;
            }
            private bool LineTriangleIntersect(Vector3 p1, Vector3 p2, Vector3 a, Vector3 b, Vector3 c)
            {
                // Implement line-triangle intersection
                var plane = new Plane(a, b, c);
                if (!plane.Raycast(new Ray(p1, p2 - p1), out float enter))
                    return false;
                if (enter < 0 || enter > Vector3.Distance(p1, p2))
                    return false;
                var point = p1 + enter * (p2 - p1);
                // Check if point is inside triangle
                var u = Vector3.Cross(b - a, point - a).magnitude;
                var v = Vector3.Cross(c - b, point - b).magnitude;
                var w = Vector3.Cross(a - c, point - c).magnitude;
                var area = Vector3.Cross(b - a, c - a).magnitude / 2f;
                return Mathf.Abs(u + v + w - area * 2) < 0.01f;
            }
            private bool IsConvex()
            {
                // Check if all face normals point outward relative to the centroid
                for (int i = 0; i < indices.Count; i += 3)
                {
                    var a = vertices[indices[i]];
                    var b = vertices[indices[i + 1]];
                    var c = vertices[indices[i + 2]];
                    var normal = Vector3.Cross(b - a, c - a).normalized;
                    var center = (a + b + c) / 3f;
                    // Check if centroid is on the "inside" of the face
                    if (Vector3.Dot(normal, centroid - center) > 1e-6f)
                    {
                        return false;
                    }
                }
                return true;
            }
            private bool IsManifold()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2) (v1, v2) = (v2, v1);
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge)) edgeCountDict[edge]++;
                        else edgeCountDict[edge] = 1;
                    }
                }
                foreach (var count in edgeCountDict.Values)
                {
                    if (count > 2) return false; // Edge shared by more than 2 faces
                }
                return true;
            }

            private bool IsClosed()
            {
                var edgeCountDict = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        if (v1 > v2)
                        {
                            (v1, v2) = (v2, v1);
                        }
                        var edge = (v1, v2);
                        if (edgeCountDict.ContainsKey(edge))
                            edgeCountDict[edge]++;
                        else
                            edgeCountDict[edge] = 1;
                    }
                }
                // Hull is closed if all edges are shared by exactly 2 triangles
                foreach (var count in edgeCountDict.Values)
                {
                    if (count != 2)
                        return false;
                }
                return true;
            }
            /// <summary>
            /// Build mesh data representation
            /// </summary>
            public void BuildMeshData()
            {
                meshData = new MeshData();
                meshData.vertices = new List<Vector3>(vertices);
                meshData.indices = new List<int>(indices);
                meshData.normals = new List<Vector3>(normals);
                meshData.CalculateProperties();
            }
            /// <summary>
            /// Build acceleration structure for fast queries
            /// </summary>
            public void BuildAccelerationStructure()
            {
                if (meshData == null)
                {
                    BuildMeshData();
                }
                accelerationStructure = new BVH(meshData);
                hasPrecomputedData = true;
            }
            /// <summary>
            /// Calculate witness points for error analysis
            /// </summary>
            public void CalculateWitnessPoints(MeshData referenceMesh, int sampleCount = 100)
            {
                if (accelerationStructure == null)
                {
                    BuildAccelerationStructure();
                }
                witnessPoints = new List<Vector3>();
                witnessErrors = new List<float>();
                // Sample points from reference mesh
                var samples = ErrorCalculator.SampleMeshSurface(referenceMesh, sampleCount);
                foreach (var sample in samples)
                {
                    float distance = DistanceToPoint(sample);
                    witnessPoints.Add(sample);
                    witnessErrors.Add(distance);
                }
                // Additional: Sort by error
                var sortedIndices = Enumerable.Range(0, witnessErrors.Count).OrderByDescending(idx => witnessErrors[idx]).ToList();
                var sortedPoints = new List<Vector3>();
                var sortedErrors = new List<float>();
                foreach (var idx in sortedIndices)
                {
                    sortedPoints.Add(witnessPoints[idx]);
                    sortedErrors.Add(witnessErrors[idx]);
                }
                witnessPoints = sortedPoints;
                witnessErrors = sortedErrors;
            }
            private void DetectSymmetry()
            {
                symmetryAxes = new List<Vector3>();
                // Basic symmetry detection along axes
                if (IsSymmetricAlongAxis(Vector3.right))
                    symmetryAxes.Add(Vector3.right);
                if (IsSymmetricAlongAxis(Vector3.up))
                    symmetryAxes.Add(Vector3.up);
                if (IsSymmetricAlongAxis(Vector3.forward))
                    symmetryAxes.Add(Vector3.forward);
                // Additional: Detect arbitrary symmetry planes
                DetectArbitrarySymmetry();
            }
            private void DetectArbitrarySymmetry()
            {
                // Advanced symmetry detection
                // ... (add logic for PCA or other methods)
            }
            private bool IsSymmetricAlongAxis(Vector3 axis)
            {
                // Check if reflecting across plane gives the same hull
                var plane = new PlaneF { n = axis, d = -Vector3.Dot(centroid, axis) };
                var reflectedVertices = new List<Vector3>();
                foreach (var v in vertices)
                {
                    float dist = plane.DistanceToPoint(v);
                    var reflected = v - 2 * dist * plane.n;
                    reflectedVertices.Add(reflected);
                }
                // Check if all reflected points are in hull
                foreach (var rv in reflectedVertices)
                {
                    if (!ContainsPoint(rv))
                        return false;
                }
                return true;
            }
            public void SmoothHull(int iterations, float lambda, bool lockBoundaries)
            {
                // Identify boundary vertices if we need to lock them
                HashSet<int> boundaryVertices = null;
                if (lockBoundaries)
                {
                    boundaryVertices = new HashSet<int>();
                    var edgeCounts = new Dictionary<(int, int), int>();
                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        for (int j = 0; j < 3; j++)
                        {
                            int v1 = indices[i + j];
                            int v2 = indices[i + (j + 1) % 3];
                            var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                            edgeCounts.TryGetValue(edge, out int count);
                            edgeCounts[edge] = count + 1;
                        }
                    }
                    foreach (var edge in edgeCounts)
                    {
                        if (edge.Value == 1) // Boundary edge
                        {
                            boundaryVertices.Add(edge.Key.Item1);
                            boundaryVertices.Add(edge.Key.Item2);
                        }
                    }
                }

                // Apply Laplacian smoothing
                for (int iter = 0; iter < iterations; iter++)
                {
                    var newVertices = new List<Vector3>(vertices);
                    for (int i = 0; i < vertices.Count; i++)
                    {
                        if (lockBoundaries && boundaryVertices != null && boundaryVertices.Contains(i)) continue;

                        var neighbors = new List<Vector3>();
                        foreach (var edge in edges)
                        {
                            if (edge.vertex1 == i) neighbors.Add(vertices[edge.vertex2]);
                            else if (edge.vertex2 == i) neighbors.Add(vertices[edge.vertex1]);
                        }

                        if (neighbors.Count > 0)
                        {
                            var avg = Vector3.zero;
                            foreach (var n in neighbors) avg += n;
                            newVertices[i] = Vector3.Lerp(vertices[i], avg / neighbors.Count, lambda);
                        }
                    }
                    vertices = newVertices;
                }
            }

            /// <summary>
            /// Fills holes in the hull by identifying and triangulating boundary edge loops.
            /// </summary>
            public void FillHoles()
            {
                var edgeCounts = new Dictionary<(int, int), int>();
                for (int i = 0; i < indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = indices[i + j];
                        int v2 = indices[i + (j + 1) % 3];
                        var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                        edgeCounts.TryGetValue(edge, out int count);
                        edgeCounts[edge] = count + 1;
                    }
                }

                var boundaryEdges = new HashSet<(int, int)>();
                foreach (var edge in edgeCounts)
                {
                    if (edge.Value == 1) boundaryEdges.Add(edge.Key);
                }

                if (boundaryEdges.Count == 0) return;

                var adjacency = new Dictionary<int, List<int>>();
                foreach(var edge in boundaryEdges)
                {
                    if (!adjacency.ContainsKey(edge.Item1)) adjacency[edge.Item1] = new List<int>();
                    if (!adjacency.ContainsKey(edge.Item2)) adjacency[edge.Item2] = new List<int>();
                    adjacency[edge.Item1].Add(edge.Item2);
                    adjacency[edge.Item2].Add(edge.Item1);
                }

                var visited = new HashSet<int>();
                var loops = new List<List<int>>();
                foreach(var startNode in adjacency.Keys)
                {
                    if (visited.Contains(startNode)) continue;
                    var loop = new List<int>();
                    var stack = new Stack<int>();
                    stack.Push(startNode);

                    var path = new Dictionary<int, int>();

                    while(stack.Count > 0)
                    {
                        var current = stack.Pop();
                        if (visited.Contains(current)) continue;
                        visited.Add(current);
                        loop.Add(current);

                        foreach(var neighbor in adjacency[current])
                        {
                            if (!visited.Contains(neighbor))
                            {
                                stack.Push(neighbor);
                            }
                        }
                    }
                    if (loop.Count > 2) loops.Add(loop);
                }

                foreach(var loop in loops)
                {
                    var poly = new List<int>(loop);
                    while(poly.Count > 2)
                    {
                        int earIndex = FindEar(poly, loop);
                        if(earIndex == -1) break; // Could not find an ear

                        int prev = poly[(earIndex == 0) ? poly.Count - 1 : earIndex - 1];
                        int curr = poly[earIndex];
                        int next = poly[(earIndex + 1) % poly.Count];

                        indices.Add(prev);
                        indices.Add(curr);
                        indices.Add(next);

                        poly.RemoveAt(earIndex);
                    }
                }
            }

            private int FindEar(List<int> poly, List<int> originalLoop)
            {
                for(int i=0; i < poly.Count; i++)
                {
                    int p_idx = poly[(i == 0) ? poly.Count - 1 : i - 1];
                    int c_idx = poly[i];
                    int n_idx = poly[(i + 1) % poly.Count];

                    Vector3 p = vertices[p_idx];
                    Vector3 c = vertices[c_idx];
                    Vector3 n = vertices[n_idx];

                    Vector3 loopNormal = CalculateLoopNormal(originalLoop);
                    if (Vector3.Dot(Vector3.Cross(c - p, n - p), loopNormal) < 0) continue;

                    bool isEar = true;
                    for (int j = 0; j < poly.Count; j++)
                    {
                        int vert_idx = poly[j];
                        if (vert_idx == p_idx || vert_idx == c_idx || vert_idx == n_idx) continue;
                        if (IsPointInTriangle(vertices[vert_idx], p, c, n))
                        {
                            isEar = false;
                            break;
                        }
                    }
                    if (isEar) return i;
                }
                return -1;
            }

            private Vector3 CalculateLoopNormal(List<int> loop)
            {
                Vector3 normal = Vector3.zero;
                for(int i=0; i < loop.Count; i++)
                {
                    Vector3 current = vertices[loop[i]];
                    Vector3 next = vertices[loop[(i + 1) % loop.Count]];
                    normal.x += (current.y - next.y) * (current.z + next.z);
                    normal.y += (current.z - next.z) * (current.x + next.x);
                    normal.z += (current.x - next.x) * (current.y + next.y);
                }
                return normal.normalized;
            }

            private bool IsPointInTriangle(Vector3 pt, Vector3 v1, Vector3 v2, Vector3 v3)
            {
                var d1 = pt - v1;
                var d2 = v2 - v1;
                var d3 = v3 - v1;

                var dot00 = Vector3.Dot(d3, d3);
                var dot01 = Vector3.Dot(d3, d2);
                var dot02 = Vector3.Dot(d3, d1);
                var dot11 = Vector3.Dot(d2, d2);
                var dot12 = Vector3.Dot(d2, d1);

                var invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                return (u >= 0) && (v >= 0) && (u + v < 1);
            }

            /// <summary>
            /// Enforces symmetry on the hull based on its detected symmetry planes.
            /// </summary>
            public void EnforceSymmetry()
            {
                if (symmetryAxes == null || symmetryAxes.Count == 0)
                {
                    DetectSymmetry();
                    if (symmetryAxes.Count == 0) return; // No symmetry found
                }

                var symmetrizedPoints = new List<Vector3>(vertices);
                var originalPoints = new List<Vector3>(vertices);

                foreach (var axis in symmetryAxes)
                {
                    var plane = new PlaneF { n = axis.normalized, d = -Vector3.Dot(centroid, axis.normalized) };
                    var reflectedPoints = new List<Vector3>();
                    foreach (var v in originalPoints)
                    {
                        float dist = plane.DistanceToPoint(v);
                        var reflectedV = v - 2 * dist * plane.n;
                        reflectedPoints.Add(reflectedV);
                    }
                    symmetrizedPoints.AddRange(reflectedPoints);
                }

                // Re-hull with the combined original and reflected points to create a symmetric hull
                var newHull = QuickHullImplementation.ComputeConvexHullFromPoints(symmetrizedPoints.Distinct().ToList());
                if (newHull.vertices.Count > 3)
                {
                    this.vertices = newHull.vertices;
                    this.indices = newHull.indices;
                }
            }
            private void CalculateTopology()
            {
                // Calculate Euler characteristic for hull
                int V = vertices.Count;
                int E = edges.Count;
                int F = indices.Count / 3;
                eulerCharacteristic = V - E + F;
                genus = (2 - eulerCharacteristic) / 2;
            }

            private void RepairManifold()
            {
                // 1. Remove duplicate triangles
                var triSet = new HashSet<string>();
                var newIndices = new List<int>();
                for(int i=0; i<indices.Count; i+=3)
                {
                    var tri = new int[]{indices[i], indices[i+1], indices[i+2]};
                    Array.Sort(tri);
                    var key = $"{tri[0]}_{tri[1]}_{tri[2]}";
                    if(triSet.Add(key))
                    {
                        newIndices.AddRange(tri);
                    }
                }
                indices = newIndices;

                // 2. Fill holes
                FillHoles();

                // 3. Re-calculate properties after repair
                CalculateProperties();
            }
        }
        /// <summary>
        /// Represents an edge in a convex hull
        /// </summary>
        [Serializable]
        public struct HullEdge
        {
            public int vertex1;
            public int vertex2;
            public float length;
            // Additional
            public bool isSharp;
            public float angle;
            public float CalculateAngle(Vector3 n1, Vector3 n2)
            {
                angle = Mathf.Acos(Vector3.Dot(n1, n2)) * Mathf.Rad2Deg;
                isSharp = angle > 30f;
                return angle;
            }
        }
        /// <summary>
        /// Burst-safe plane structure
        /// </summary>
        [Serializable]
        public struct PlaneF
        {
            public Vector3 n; // normal
            public float d; // distance from origin
            public float DistanceToPoint(Vector3 point)
            {
                return Vector3.Dot(n, point) + d;
            }
            // Additional
            public Vector3 ProjectPoint(Vector3 point)
            {
                return point - DistanceToPoint(point) * n;
            }
            public bool Equals(PlaneF other, float epsilon = 1e-5f)
            {
                return Vector3.Dot(n, other.n) > 1 - epsilon && Mathf.Abs(d - other.d) < epsilon;
            }
        }
        /// <summary>
        /// Error calculator for mesh comparison with multiple metrics
        /// </summary>
        public static class ErrorCalculator
        {
            /// <summary>
            /// Sample points from mesh surface using specified strategy
            /// </summary>
            public static List<Vector3> SampleMeshSurface(MeshData mesh, int sampleCount, SamplingStrategy strategy = SamplingStrategy.AreaWeighted)
            {
                var samples = new List<Vector3>();
                if (mesh.triangleCount == 0) return samples;
                switch (strategy)
                {
                    case SamplingStrategy.Uniform:
                        return SampleUniform(mesh, sampleCount);
                    case SamplingStrategy.AreaWeighted:
                        return SampleAreaWeighted(mesh, sampleCount);
                    case SamplingStrategy.CurvatureWeighted:
                        return SampleCurvatureWeighted(mesh, sampleCount);
                    case SamplingStrategy.FeaturePreserving:
                        return SampleFeaturePreserving(mesh, sampleCount);
                    case SamplingStrategy.Adaptive:
                        return SampleAdaptive(mesh, sampleCount);
                    case SamplingStrategy.Stratified:
                        return SampleStratified(mesh, sampleCount);
                    default:
                        return SampleAreaWeighted(mesh, sampleCount);
                }
            }
            /// <summary>
            /// Uniform sampling across triangles
            /// </summary>
            private static List<Vector3> SampleUniform(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                int trianglesPerSample = Mathf.Max(1, mesh.triangleCount / sampleCount);
                for (int i = 0; i < mesh.indices.Count; i += 3 * trianglesPerSample)
                {
                    if (samples.Count >= sampleCount) break;
                    // Select a triangle from this group
                    int triIndex = i + UnityEngine.Random.Range(0, trianglesPerSample * 3);
                    triIndex = Mathf.Min(triIndex, mesh.indices.Count - 3);
                    // Get triangle vertices
                    var a = mesh.vertices[mesh.indices[triIndex]];
                    var b = mesh.vertices[mesh.indices[triIndex + 1]];
                    var c = mesh.vertices[mesh.indices[triIndex + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Area-weighted sampling
            /// </summary>
            private static List<Vector3> SampleAreaWeighted(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                if (mesh.triangleCount == 0) return samples;
                // Calculate triangle areas for weighted sampling
                var areas = new float[mesh.triangleCount];
                float totalArea = 0f;
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    var a = mesh.vertices[mesh.indices[i]];
                    var b = mesh.vertices[mesh.indices[i + 1]];
                    var c = mesh.vertices[mesh.indices[i + 2]];
                    areas[triIndex] = Vector3.Cross(b - a, c - a).magnitude / 2f;
                    totalArea += areas[triIndex];
                }
                if (totalArea < 1e-6f) return samples;
                // Normalize areas to create cumulative distribution
                var cumulativeAreas = new float[areas.Length];
                float cumulative = 0f;
                for (int i = 0; i < areas.Length; i++)
                {
                    cumulative += areas[i];
                    cumulativeAreas[i] = cumulative;
                }
                // Sample points
                for (int s = 0; s < sampleCount; s++)
                {
                    float r = UnityEngine.Random.value * totalArea;
                    // Find triangle using binary search
                    int low = 0;
                    int high = cumulativeAreas.Length - 1;
                    while (low < high)
                    {
                        int mid = (low + high) / 2;
                        if (cumulativeAreas[mid] < r)
                            low = mid + 1;
                        else
                            high = mid;
                    }
                    int triIndex = low;
                    // Get triangle vertices
                    int idx = triIndex * 3;
                    var a = mesh.vertices[mesh.indices[idx]];
                    var b = mesh.vertices[mesh.indices[idx + 1]];
                    var c = mesh.vertices[mesh.indices[idx + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Curvature-weighted sampling
            /// </summary>
            private static List<Vector3> SampleCurvatureWeighted(MeshData mesh, int sampleCount)
            {
                // Calculate curvature if not already present
                if (mesh.curvature == null || mesh.curvature.Count != mesh.vertices.Count)
                {
                    mesh.CalculateCurvature();
                }
                var samples = new List<Vector3>();
                // Calculate triangle curvature weights
                var weights = new float[mesh.triangleCount];
                float totalWeight = 0f;
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int triIndex = i / 3;
                    var i0 = mesh.indices[i];
                    var i1 = mesh.indices[i + 1];
                    var i2 = mesh.indices[i + 2];
                    // Use average curvature of triangle vertices
                    weights[triIndex] = (mesh.curvature[i0].magnitude +
                                         mesh.curvature[i1].magnitude +
                                         mesh.curvature[i2].magnitude) / 3f;
                    totalWeight += weights[triIndex];
                }
                if (totalWeight < 1e-6f) return SampleAreaWeighted(mesh, sampleCount);
                // Normalize weights to create cumulative distribution
                var cumulativeWeights = new float[weights.Length];
                float cumulative = 0f;
                for (int i = 0; i < weights.Length; i++)
                {
                    cumulative += weights[i];
                    cumulativeWeights[i] = cumulative;
                }
                // Sample points
                for (int s = 0; s < sampleCount; s++)
                {
                    float r = UnityEngine.Random.value * totalWeight;
                    // Find triangle using binary search
                    int low = 0;
                    int high = cumulativeWeights.Length - 1;
                    while (low < high)
                    {
                        int mid = (low + high) / 2;
                        if (cumulativeWeights[mid] < r)
                            low = mid + 1;
                        else
                            high = mid;
                    }
                    int triIndex = low;
                    // Get triangle vertices
                    int idx = triIndex * 3;
                    var a = mesh.vertices[mesh.indices[idx]];
                    var b = mesh.vertices[mesh.indices[idx + 1]];
                    var c = mesh.vertices[mesh.indices[idx + 2]];
                    // Generate random barycentric coordinates
                    float r1 = UnityEngine.Random.value;
                    float r2 = UnityEngine.Random.value;
                    if (r1 + r2 > 1f)
                    {
                        r1 = 1f - r1;
                        r2 = 1f - r2;
                    }
                    float u = r1;
                    float v = r2;
                    float w = 1f - u - v;
                    // Calculate point
                    var point = a * u + b * v + c * w;
                    samples.Add(point);
                }
                return samples;
            }
            /// <summary>
            /// Feature-preserving sampling
            /// </summary>
            private static List<Vector3> SampleFeaturePreserving(MeshData mesh, int sampleCount)
            {
                // Identify features if not already present
                if (mesh.featureVertices == null || mesh.featureVertices.Count == 0)
                {
                    mesh.IdentifyFeatureVertices();
                }
                var samples = new List<Vector3>();
                // Reserve some samples for feature vertices
                int featureSampleCount = Mathf.Min(sampleCount / 4, mesh.featureVertices.Count);
                int regularSampleCount = sampleCount - featureSampleCount;
                // Sample feature vertices
                if (mesh.featureVertices.Count > 0)
                {
                    var featureIndices = new List<int>(mesh.featureVertices);
                    // Randomly select feature vertices
                    for (int i = 0; i < featureSampleCount; i++)
                    {
                        if (featureIndices.Count == 0) break;
                        int idx = UnityEngine.Random.Range(0, featureIndices.Count);
                        samples.Add(mesh.vertices[featureIndices[idx]]);
                        featureIndices.RemoveAt(idx);
                    }
                }
                // Sample remaining points using area-weighted strategy
                if (regularSampleCount > 0)
                {
                    var regularSamples = SampleAreaWeighted(mesh, regularSampleCount);
                    samples.AddRange(regularSamples);
                }
                // Additional: Ensure no duplicates
                samples = samples.Distinct(new Vector3Comparer()).ToList();
                return samples;
            }
            class Vector3Comparer : IEqualityComparer<Vector3>
            {
                public bool Equals(Vector3 x, Vector3 y)
                {
                    return (x - y).sqrMagnitude < 1e-6f;
                }
                public int GetHashCode(Vector3 obj)
                {
                    return obj.GetHashCode();
                }
            }
            /// <summary>
            /// Adaptive sampling based on error
            /// </summary>
            private static List<Vector3> SampleAdaptive(MeshData mesh, int sampleCount)
            {
                // Start with area-weighted sampling
                var samples = SampleAreaWeighted(mesh, sampleCount / 2);
                // Add more samples in high-error regions (using curvature as a proxy)
                var curvatureSamples = SampleCurvatureWeighted(mesh, sampleCount / 2);
                samples.AddRange(curvatureSamples);
                // Additional: Adapt based on density
                AdjustSampleDensity(samples, mesh.bounds, 0.05f);
                return samples;
            }
            private static void AdjustSampleDensity(List<Vector3> samples, Bounds bounds, float minDistance)
            {
                for (int i = samples.Count - 1; i >= 0; i--)
                {
                    for (int j = 0; j < i; j++)
                    {
                        if (Vector3.Distance(samples[i], samples[j]) < minDistance)
                        {
                            samples.RemoveAt(i);
                            break;
                        }
                    }
                }
            }
            /// <summary>
            /// Stratified sampling
            /// </summary>
            private static List<Vector3> SampleStratified(MeshData mesh, int sampleCount)
            {
                var samples = new List<Vector3>();
                // Divide the mesh into strata based on spatial location
                var bounds = mesh.bounds;
                int strataPerAxis = Mathf.CeilToInt(Mathf.Pow(sampleCount, 1f / 3f));
                float strataSizeX = bounds.size.x / strataPerAxis;
                float strataSizeY = bounds.size.y / strataPerAxis;
                float strataSizeZ = bounds.size.z / strataPerAxis;
                // Create strata
                var strata = new List<List<int>>();
                for (int x = 0; x < strataPerAxis; x++)
                {
                    for (int y = 0; y < strataPerAxis; y++)
                    {
                        for (int z = 0; z < strataPerAxis; z++)
                        {
                            var stratumBounds = new Bounds(
                                bounds.min + new Vector3(x * strataSizeX, y * strataSizeY, z * strataSizeZ) + new Vector3(strataSizeX, strataSizeY, strataSizeZ) / 2,
                                new Vector3(strataSizeX, strataSizeY, strataSizeZ)
                            );
                            var stratumTriangles = new List<int>();
                            // Find triangles in this stratum
                            for (int i = 0; i < mesh.indices.Count; i += 3)
                            {
                                var a = mesh.vertices[mesh.indices[i]];
                                var b = mesh.vertices[mesh.indices[i + 1]];
                                var c = mesh.vertices[mesh.indices[i + 2]];
                                var triBounds = new Bounds(a, Vector3.zero);
                                triBounds.Encapsulate(b);
                                triBounds.Encapsulate(c);
                                if (stratumBounds.Intersects(triBounds))
                                {
                                    stratumTriangles.Add(i);
                                }
                            }
                            strata.Add(stratumTriangles);
                        }
                    }
                }
                // Sample from each stratum
                int samplesPerStratum = Mathf.Max(1, sampleCount / strata.Count);
                foreach (var stratum in strata)
                {
                    if (stratum.Count == 0) continue;
                    for (int i = 0; i < samplesPerStratum && samples.Count < sampleCount; i++)
                    {
                        // Randomly select a triangle from this stratum
                        int triIndex = stratum[UnityEngine.Random.Range(0, stratum.Count)];
                        // Get triangle vertices
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        // Generate random barycentric coordinates
                        float r1 = UnityEngine.Random.value;
                        float r2 = UnityEngine.Random.value;
                        if (r1 + r2 > 1f)
                        {
                            r1 = 1f - r1;
                            r2 = 1f - r2;
                        }
                        float u = r1;
                        float v = r2;
                        float w = 1f - u - v;
                        // Calculate point
                        var point = a * u + b * v + c * w;
                        samples.Add(point);
                    }
                }
                // Additional: Fill remaining samples if needed
                if (samples.Count < sampleCount)
                {
                    var additional = SampleAreaWeighted(mesh, sampleCount - samples.Count);
                    samples.AddRange(additional);
                }
                return samples;
            }
            /// <summary>
            /// Calculate symmetric Hausdorff distance between two meshes
            /// </summary>
            public static float CalculateSymmetricHausdorff(MeshData mesh1, MeshData mesh2, int sampleCount = 1000)
            {
                // Sample points from both meshes
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                var samples2 = SampleMeshSurface(mesh2, sampleCount);
                if (samples1.Count == 0 || samples2.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate max distance from mesh1 to mesh2
                float maxDist1 = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    maxDist1 = Mathf.Max(maxDist1, dist);
                }
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate max distance from mesh2 to mesh1
                float maxDist2 = 0f;
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    maxDist2 = Mathf.Max(maxDist2, dist);
                }
                // Return symmetric Hausdorff distance
                return Mathf.Max(maxDist1, maxDist2);
            }
            /// <summary>
            /// Calculate error using specified metric
            /// </summary>
            public static float CalculateError(MeshData mesh1, MeshData mesh2, ErrorMetricType metricType)
            {
                switch (metricType)
                {
                    case ErrorMetricType.Hausdorff:
                        return CalculateHausdorff(mesh1, mesh2);
                    case ErrorMetricType.SymmetricHausdorff:
                        return CalculateSymmetricHausdorff(mesh1, mesh2);
                    case ErrorMetricType.MeanSquared:
                        return CalculateMeanSquaredError(mesh1, mesh2);
                    case ErrorMetricType.RootMeanSquared:
                        return Mathf.Sqrt(CalculateMeanSquaredError(mesh1, mesh2));
                    case ErrorMetricType.MaxDeviation:
                        return CalculateMaxDeviation(mesh1, mesh2);
                    case ErrorMetricType.VolumeDifference:
                        return CalculateVolumeDifference(mesh1, mesh2);
                    case ErrorMetricType.SurfaceAreaDifference:
                        return CalculateSurfaceAreaDifference(mesh1, mesh2);
                    default:
                        return CalculateSymmetricHausdorff(mesh1, mesh2);
                }
            }
            /// <summary>
            /// Calculate Hausdorff distance from mesh1 to mesh2
            /// </summary>
            public static float CalculateHausdorff(MeshData mesh1, MeshData mesh2)
            {
                // Sample points from mesh1
                int sampleCount = Mathf.Min(1000, mesh1.triangleCount * 10);
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                if (samples1.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate max distance from mesh1 to mesh2
                float maxDist = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    maxDist = Mathf.Max(maxDist, dist);
                }
                return maxDist;
            }
            /// <summary>
            /// Calculate mean squared error between two meshes
            /// </summary>
            public static float CalculateMeanSquaredError(MeshData mesh1, MeshData mesh2)
            {
                // Sample points from both meshes
                int sampleCount = Mathf.Min(1000, mesh1.triangleCount * 10);
                var samples1 = SampleMeshSurface(mesh1, sampleCount);
                var samples2 = SampleMeshSurface(mesh2, sampleCount);
                if (samples1.Count == 0 || samples2.Count == 0)
                    return 0f;
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate squared distances from mesh1 to mesh2
                float sumSquaredDist = 0f;
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    sumSquaredDist += dist * dist;
                }
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate squared distances from mesh2 to mesh1
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    sumSquaredDist += dist * dist;
                }
                // Return mean squared error
                return sumSquaredDist / (samples1.Count + samples2.Count);
            }
            /// <summary>
            /// Calculate maximum deviation between two meshes
            /// </summary>
            public static float CalculateMaxDeviation(MeshData mesh1, MeshData mesh2)
            {
                // This is equivalent to symmetric Hausdorff
                return CalculateSymmetricHausdorff(mesh1, mesh2);
            }
            /// <summary>
            /// Calculate volume difference between two meshes
            /// </summary>
            public static float CalculateVolumeDifference(MeshData mesh1, MeshData mesh2)
            {
                return Mathf.Abs(mesh1.volume - mesh2.volume);
            }
            /// <summary>
            /// Calculate surface area difference between two meshes
            /// </summary>
            public static float CalculateSurfaceAreaDifference(MeshData mesh1, MeshData mesh2)
            {
                return Mathf.Abs(mesh1.surfaceArea - mesh2.surfaceArea);
            }
            /// <summary>
            /// Calculate error distribution between two meshes
            /// </summary>
            public static List<float> CalculateErrorDistribution(MeshData mesh1, MeshData mesh2, int sampleCount = 1000)
            {
                var errors = new List<float>();
                // Sample points from mesh1
                var samples1 = SampleMeshSurface(mesh1, sampleCount / 2);
                // Build spatial acceleration structure for mesh2
                var bvh2 = new BVH(mesh2);
                // Calculate distances from mesh1 to mesh2
                foreach (var point in samples1)
                {
                    float dist = bvh2.DistanceToPoint(point);
                    errors.Add(dist);
                }
                // Sample points from mesh2
                var samples2 = SampleMeshSurface(mesh2, sampleCount / 2);
                // Build spatial acceleration structure for mesh1
                var bvh1 = new BVH(mesh1);
                // Calculate distances from mesh2 to mesh1
                foreach (var point in samples2)
                {
                    float dist = bvh1.DistanceToPoint(point);
                    errors.Add(dist);
                }
                return errors;
            }
            public static float CalculateSymmetricHausdorff(MeshData mesh, List<ConvexHull> hulls, int maxSamples = 2000)
            {
                var hullMesh = CombineHullsToMesh(hulls);
                if (hullMesh.vertices.Count == 0) return 0f;
                return CalculateSymmetricHausdorff(mesh, hullMesh, maxSamples);
            }
            public static List<float> CalculateErrorDistribution(MeshData mesh, List<ConvexHull> hulls, int sampleCount = 1000)
            {
                var hullMesh = CombineHullsToMesh(hulls);
                if (hullMesh.vertices.Count == 0) return new List<float>();
                return CalculateErrorDistribution(mesh, hullMesh, sampleCount);
            }
            static MeshData CombineHullsToMesh(List<ConvexHull> hulls)
            {
                var m = new MeshData();
                foreach (var h in hulls)
                {
                    if (h.vertices == null || h.indices == null || h.vertices.Count == 0 || h.indices.Count == 0) continue;
                    int baseIdx = m.vertices.Count;
                    m.vertices.AddRange(h.vertices);
                    if (h.normals != null && h.normals.Count == h.vertices.Count) m.normals.AddRange(h.normals);
                    else { for (int i = 0; i < h.vertices.Count; i++) m.normals.Add(Vector3.zero); } // Add placeholder normals
                    for (int i = 0; i < h.indices.Count; i++) m.indices.Add(h.indices[i] + baseIdx);
                }
                m.CalculateProperties();
                return m;
            }
            // Additional: Calculate PSNR
            public static float CalculatePSNR(MeshData mesh1, MeshData mesh2)
            {
                float mse = CalculateMeanSquaredError(mesh1, mesh2);
                if (mse == 0) return float.PositiveInfinity;
                float maxValue = Mathf.Max(mesh1.bounds.size.magnitude, mesh2.bounds.size.magnitude);
                return 20 * Mathf.Log10(maxValue / Mathf.Sqrt(mse));
            }
            // Additional: Calculate SSIM
            public static float CalculateSSIM(MeshData mesh1, MeshData mesh2)
            {
                // Simplified SSIM calculation
                // ... (add logic)
                return 1f; // Placeholder
            }
        }
        /// <summary>
        /// Bounding Volume Hierarchy for spatial acceleration
        /// </summary>
        public class BVH
        {
            private class Node
            {
                public Bounds bounds;
                public List<int> triangleIndices;
                public Node left;
                public Node right;
                public bool isLeaf;
                public int depth;
            }
            private Node root;
            private MeshData mesh;
            private int maxTrianglesPerNode = 10;
            private int maxDepth = 20;
            public BVH(MeshData mesh)
            {
                this.mesh = mesh;
                Build();
            }
            private void Build()
            {
                if (mesh == null || mesh.triangleCount == 0) return;
                var allIndices = Enumerable.Range(0, mesh.triangleCount).Select(i => i * 3).ToList();
                root = BuildRecursive(allIndices, 0);
            }
            private Node BuildRecursive(List<int> triangleIndices, int depth)
            {
                var node = new Node
                {
                    triangleIndices = triangleIndices,
                    depth = depth,
                    bounds = CalculateBounds(triangleIndices)
                };
                if (triangleIndices.Count <= maxTrianglesPerNode || depth >= maxDepth)
                {
                    node.isLeaf = true;
                    return node;
                }
                // Find longest axis to split
                int axis = 0;
                var size = node.bounds.size;
                if (size.y > size.x) axis = 1;
                if (size.z > size[axis]) axis = 2;
                float splitPos = node.bounds.center[axis];
                var leftIndices = new List<int>();
                var rightIndices = new List<int>();
                foreach (var triIndex in triangleIndices)
                {
                    var triCenter = (mesh.vertices[mesh.indices[triIndex]] +
                                     mesh.vertices[mesh.indices[triIndex + 1]] +
                                     mesh.vertices[mesh.indices[triIndex + 2]]) / 3f;
                    if (triCenter[axis] < splitPos)
                        leftIndices.Add(triIndex);
                    else
                        rightIndices.Add(triIndex);
                }
                // Handle cases where split fails
                if (leftIndices.Count == 0 || rightIndices.Count == 0)
                {
                    node.isLeaf = true;
                    return node;
                }
                node.isLeaf = false;
                node.left = BuildRecursive(leftIndices, depth + 1);
                node.right = BuildRecursive(rightIndices, depth + 1);
                return node;
            }
            private Bounds CalculateBounds(List<int> triangleIndices)
            {
                if (triangleIndices.Count == 0) return new Bounds();
                var bounds = new Bounds(mesh.vertices[mesh.indices[triangleIndices[0]]], Vector3.zero);
                foreach (var triIndex in triangleIndices)
                {
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex]]);
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex + 1]]);
                    bounds.Encapsulate(mesh.vertices[mesh.indices[triIndex + 2]]);
                }
                return bounds;
            }
            public float DistanceToPoint(Vector3 point)
            {
                if (root == null) return float.MaxValue;
                return DistanceToPointRecursive(point, root);
            }
            private float DistanceToPointRecursive(Vector3 point, Node node)
            {
                if (node.isLeaf)
                {
                    float minDistance = float.MaxValue;
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        minDistance = Mathf.Min(minDistance, DistanceToTriangle(point, a, b, c));
                    }
                    return minDistance;
                }
                float distToLeftBounds = SqrDistanceToBounds(point, node.left.bounds);
                float distToRightBounds = SqrDistanceToBounds(point, node.right.bounds);
                if (distToLeftBounds < distToRightBounds)
                {
                    float distLeft = DistanceToPointRecursive(point, node.left);
                    if (distToRightBounds >= distLeft * distLeft) return distLeft;
                    return Mathf.Min(distLeft, DistanceToPointRecursive(point, node.right));
                }
                else
                {
                    float distRight = DistanceToPointRecursive(point, node.right);
                    if (distToLeftBounds >= distRight * distRight) return distRight;
                    return Mathf.Min(distRight, DistanceToPointRecursive(point, node.left));
                }
            }
            private float SqrDistanceToBounds(Vector3 point, Bounds bounds)
            {
                var closest = bounds.ClosestPoint(point);
                return (point - closest).sqrMagnitude;
            }
            private float DistanceToTriangle(Vector3 point, Vector3 a, Vector3 b, Vector3 c)
            {
                var ab = b - a;
                var ac = c - a;
                var ap = point - a;
                var d1 = Vector3.Dot(ab, ap);
                var d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0f && d2 <= 0f) return Vector3.Distance(point, a);
                var bp = point - b;
                var d3 = Vector3.Dot(ab, bp);
                var d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0f && d4 <= d3) return Vector3.Distance(point, b);
                var vc = d1 * d4 - d3 * d2;
                if (vc <= 0f && d1 >= 0f && d3 <= 0f)
                {
                    var v = d1 / (d1 - d3);
                    return Vector3.Distance(point, a + v * ab);
                }
                var cp = point - c;
                var d5 = Vector3.Dot(ab, cp);
                var d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0f && d5 <= d6) return Vector3.Distance(point, c);
                var vb = d5 * d2 - d1 * d6;
                if (vb <= 0f && d2 >= 0f && d6 <= 0f)
                {
                    var w = d2 / (d2 - d6);
                    return Vector3.Distance(point, a + w * ac);
                }
                var va = d3 * d6 - d5 * d4;
                if (va <= 0f && (d4 - d3) >= 0f && (d5 - d6) >= 0f)
                {
                    var w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                    return Vector3.Distance(point, b + w * (c - b));
                }
                var denom = va + vb + vc;
                if (Mathf.Abs(denom) < 1e-6f) return Vector3.Distance(point, a); // Degenerate
                var v_ = vb / denom;
                var w_ = vc / denom;
                var closestPoint = a + ab * v_ + ac * w_;
                return Vector3.Distance(point, closestPoint);
            }
            /// <summary>
            /// Find all triangles intersecting with a ray
            /// </summary>
            public List<int> IntersectRay(Vector3 origin, Vector3 direction, float maxDistance = float.MaxValue)
            {
                var results = new List<int>();
                if (root == null) return results;
                IntersectRayRecursive(origin, direction, maxDistance, root, results);
                return results;
            }
            private static bool Intersects(Bounds b, Vector3 origin, Vector3 dir, float maxDistance)
            {
                return b.IntersectRay(new Ray(origin, dir), out float hit) && hit <= maxDistance;
            }
            private void IntersectRayRecursive(Vector3 origin, Vector3 direction, float maxDistance, Node node, List<int> results)
            {
                if (!Intersects(node.bounds, origin, direction, maxDistance))
                    return;
                if (node.isLeaf)
                {
                    // Check if ray intersects with triangle
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        if (IntersectRayTriangle(origin, direction, a, b, c, out float distance) && distance <= maxDistance)
                        {
                            results.Add(triIndex);
                        }
                    }
                }
                else
                {
                    // Check both children
                    IntersectRayRecursive(origin, direction, maxDistance, node.left, results);
                    IntersectRayRecursive(origin, direction, maxDistance, node.right, results);
                }
            }
            private bool IntersectRayTriangle(Vector3 origin, Vector3 direction, Vector3 a, Vector3 b, Vector3 c, out float distance)
            {
                // MllerTrumbore intersection algorithm
                var edge1 = b - a;
                var edge2 = c - a;
                var h = Vector3.Cross(direction, edge2);
                var det = Vector3.Dot(edge1, h);
                if (det > -1e-6f && det < 1e-6f)
                {
                    distance = 0f;
                    return false; // Ray is parallel to triangle
                }
                var f = 1f / det;
                var s = origin - a;
                var u = f * Vector3.Dot(s, h);
                if (u < 0f || u > 1f)
                {
                    distance = 0f;
                    return false;
                }
                var q = Vector3.Cross(s, edge1);
                var v = f * Vector3.Dot(direction, q);
                if (v < 0f || u + v > 1f)
                {
                    distance = 0f;
                    return false;
                }
                distance = f * Vector3.Dot(edge2, q);
                return distance > 1e-6f;
            }
            // Additional: Find closest triangle to point
            public int FindClosestTriangle(Vector3 point)
            {
                float minDist = float.MaxValue;
                int closestTri = -1;
                FindClosestTriangleRecursive(point, root, ref minDist, ref closestTri);
                return closestTri;
            }
            public void DrawGizmos()
            {
                if (root == null) return;
                DrawGizmosRecursive(root);
            }

            private void DrawGizmosRecursive(Node node)
            {
                if (node == null) return;
                Gizmos.color = Color.Lerp(Color.green, Color.red, node.depth / (float)maxDepth);
                Gizmos.DrawWireCube(node.bounds.center, node.bounds.size);
                if (node.left != null) DrawGizmosRecursive(node.left);
                if (node.right != null) DrawGizmosRecursive(node.right);
            }

            private void FindClosestTriangleRecursive(Vector3 point, Node node, ref float minDist, ref int closestTri)
            {
                if (node.isLeaf)
                {
                    foreach (var triIndex in node.triangleIndices)
                    {
                        var a = mesh.vertices[mesh.indices[triIndex]];
                        var b = mesh.vertices[mesh.indices[triIndex + 1]];
                        var c = mesh.vertices[mesh.indices[triIndex + 2]];
                        float dist = DistanceToTriangle(point, a, b, c);
                        if (dist < minDist)
                        {
                            minDist = dist;
                            closestTri = triIndex;
                        }
                    }
                }
                else
                {
                    // Recurse on children
                    FindClosestTriangleRecursive(point, node.left, ref minDist, ref closestTri);
                    FindClosestTriangleRecursive(point, node.right, ref minDist, ref closestTri);
                }
            }
        }
        /// <summary>
        /// Full 3D QuickHull implementation for convex hull generation.
        /// Uses a half-edge data structure to manage hull topology.
        /// </summary>
        public static class QuickHullImplementation
        {
            private class QHVertex
            {
                public Vector3 position;
                public int index;
                public QHHalfEdge edge;
                public bool onHull;
            }
            private class QHHalfEdge
            {
                public QHVertex vertex;
                public QHFace face;
                public QHHalfEdge next;
                public QHHalfEdge prev;
                public QHHalfEdge twin;
            }
            private class QHFace
            {
                public QHHalfEdge edge;
                public Vector3 normal;
                public float distance;
                public List<QHVertex> outsideSet = new List<QHVertex>();
                public bool visible;
                public int generation;
            }
            public static ConvexHull ComputeConvexHullFromPoints(List<Vector3> points)
            {
                if (points == null || points.Count < 4)
                {
                    return new ConvexHull();
                }
                const float epsilon = 1e-5f;
                List<QHFace> allFaces = new List<QHFace>();
                List<QHVertex> qhVertices = points.Select((p, i) => new QHVertex { position = p, index = i }).ToList();
                if (!CreateInitialSimplex(qhVertices, allFaces, epsilon))
                {
                    return new ConvexHull();
                }
                int currentGeneration = 0;
                while (true)
                {
                    QHFace furthestFace = null;
                    QHVertex eyePoint = null;
                    float maxDist = epsilon;
                    foreach (var face in allFaces)
                    {
                        if (face.visible || face.outsideSet.Count == 0) continue;
                        foreach (var v in face.outsideSet)
                        {
                            float dist = Vector3.Dot(face.normal, v.position) - face.distance;
                            if (dist > maxDist)
                            {
                                maxDist = dist;
                                furthestFace = face;
                                eyePoint = v;
                            }
                        }
                    }
                    if (furthestFace == null || eyePoint == null) break;
                    eyePoint.onHull = true;
                    List<QHFace> visibleFaces = new List<QHFace>();
                    List<QHHalfEdge> horizonEdges = new List<QHHalfEdge>();
                    Stack<QHFace> faceStack = new Stack<QHFace>();
                    furthestFace.visible = true;
                    faceStack.Push(furthestFace);
                    while (faceStack.Count > 0)
                    {
                        var face = faceStack.Pop();
                        visibleFaces.Add(face);
                        var edge = face.edge;
                        do
                        {
                            var neighbor = edge.twin.face;
                            if (!neighbor.visible)
                            {
                                float dist = Vector3.Dot(neighbor.normal, eyePoint.position) - neighbor.distance;
                                if (dist > epsilon)
                                {
                                    neighbor.visible = true;
                                    faceStack.Push(neighbor);
                                }
                                else
                                {
                                    horizonEdges.Add(edge);
                                }
                            }
                            edge = edge.next;
                        } while (edge != face.edge);
                    }
                    List<QHVertex> orphanedPoints = new List<QHVertex>();
                    foreach (var face in visibleFaces)
                    {
                        orphanedPoints.AddRange(face.outsideSet);
                        face.outsideSet.Clear();
                    }
                    // after collecting raw horizonEdges:
                    var horizon = OrderHorizonEdges(horizonEdges);
                    var newFaces = new List<QHFace>();
                    BuildFacesFromHorizon(horizon, eyePoint, newFaces);
                    // Assign orphaned points to new faces
                    foreach (var v in orphanedPoints)
                    {
                        if (v.onHull) continue;
                        QHFace bestFace = null;
                        float maxPointDist = epsilon;
                        foreach (var face in newFaces)
                        {
                            float dist = Vector3.Dot(face.normal, v.position) - face.distance;
                            if (dist > maxPointDist)
                            {
                                maxPointDist = dist;
                                bestFace = face;
                            }
                        }
                        if (bestFace != null)
                        {
                            bestFace.outsideSet.Add(v);
                        }
                    }
                    allFaces.AddRange(newFaces);
                    currentGeneration++;
                }
                var finalHull = new ConvexHull();
                var vertexMap = new Dictionary<QHVertex, int>();
                allFaces.RemoveAll(f => f.visible);
                foreach (var face in allFaces)
                {
                    var edge = face.edge;
                    do
                    {
                        if (!vertexMap.ContainsKey(edge.vertex))
                        {
                            vertexMap.Add(edge.vertex, finalHull.vertices.Count);
                            finalHull.vertices.Add(edge.vertex.position);
                        }
                        edge = edge.next;
                    } while (edge != face.edge);
                }
                foreach (var face in allFaces)
                {
                    finalHull.indices.Add(vertexMap[face.edge.vertex]);
                    finalHull.indices.Add(vertexMap[face.edge.next.vertex]);
                    finalHull.indices.Add(vertexMap[face.edge.next.next.vertex]);
                }
                finalHull.CalculateProperties();
                return finalHull;
            }
            // Order the horizon into a loop: next starts at current.twin.vertex
            static List<QHHalfEdge> OrderHorizonEdges(List<QHHalfEdge> raw)
            {
                var from = new Dictionary<QHVertex, QHHalfEdge>();
                foreach (var e in raw) from[e.vertex] = e; // e.vertex is the tail (origin) of the horizon edge on a VISIBLE face
                var ordered = new List<QHHalfEdge>(raw.Count);
                var cur = raw[0];
                ordered.Add(cur);
                while (ordered.Count < raw.Count)
                {
                    if (!from.TryGetValue(cur.twin.vertex, out var next)) break; // next tail == current head
                    ordered.Add(next);
                    cur = next;
                }
                return ordered;
            }
            // Build the "cone" of new faces around 'eye' from the ordered horizon
            static void BuildFacesFromHorizon(List<QHHalfEdge> orderedHorizon, QHVertex eye, List<QHFace> newFaces)
            {
                QHHalfEdge firstB = null;
                QHHalfEdge prevC = null;
                foreach (var h in orderedHorizon)
                {
                    var vA = h.vertex; // tail of horizon edge on visible side
                    var vB = h.twin.vertex; // head of horizon edge (in the neighbor, i.e., outside)
                    var f = new QHFace();
                    var a = new QHHalfEdge { vertex = vA, face = f }; // vA -> vB (shares with old outside face)
                    var b = new QHHalfEdge { vertex = vB, face = f }; // vB -> eye (will twin with previous face's c)
                    var c = new QHHalfEdge { vertex = eye, face = f }; // eye -> vA (will twin with next face's b)
                    // cycle
                    a.next = b; b.next = c; c.next = a;
                    a.prev = c; b.prev = a; c.prev = b;
                    // twin to the existing outside face along the horizon
                    a.twin = h.twin;
                    h.twin.twin = a;
                    // stitch around the eye
                    if (prevC != null) { prevC.twin = b; b.twin = prevC; } else { firstB = b; }
                    // face data
                    f.edge = a;
                    f.normal = Vector3.Cross(vB.position - vA.position, eye.position - vA.position).normalized;
                    f.distance = Vector3.Dot(f.normal, vA.position);
                    newFaces.Add(f);
                    prevC = c;
                }
                // close the ring
                if (firstB != null && prevC != null) { firstB.twin = prevC; prevC.twin = firstB; }
            }
            private static bool CreateInitialSimplex(List<QHVertex> vertices, List<QHFace> faces, float epsilon)
            {
                faces.Clear();
                int i0 = 0, i1 = 0;
                float maxDistSq = 0;
                for (int i = 0; i < vertices.Count; i++)
                    for (int j = i + 1; j < vertices.Count; j++)
                    {
                        float d = (vertices[j].position - vertices[i].position).sqrMagnitude;
                        if (d > maxDistSq) { maxDistSq = d; i0 = i; i1 = j; }
                    }
                if (Mathf.Sqrt(maxDistSq) < epsilon) return false;
                int i2 = -1;
                maxDistSq = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (i == i0 || i == i1) continue;
                    float d = DistanceToLineSq(vertices[i].position, vertices[i0].position, vertices[i1].position);
                    if (d > maxDistSq) { maxDistSq = d; i2 = i; }
                }
                if (i2 == -1 || Mathf.Sqrt(maxDistSq) < epsilon) return false;
                int i3 = -1;
                float maxDist = 0;
                for (int i = 0; i < vertices.Count; i++)
                {
                    if (i == i0 || i == i1 || i == i2) continue;
                    float d = DistanceToPlane(vertices[i].position, vertices[i0].position, vertices[i1].position, vertices[i2].position);
                    if (Mathf.Abs(d) > maxDist) { maxDist = Mathf.Abs(d); i3 = i; }
                }
                if (i3 == -1 || maxDist < epsilon) return false;
                var v = new QHVertex[4] { vertices[i0], vertices[i1], vertices[i2], vertices[i3] };
                if (DistanceToPlane(v[3].position, v[0].position, v[1].position, v[2].position) > 0)
                {
                    (v[1], v[2]) = (v[2], v[1]);
                }
                for (int i = 0; i < 4; i++) v[i].onHull = true;
                faces.Add(CreateFace(v[0], v[1], v[2]));
                faces.Add(CreateFace(v[3], v[1], v[0]));
                faces.Add(CreateFace(v[3], v[2], v[1]));
                faces.Add(CreateFace(v[3], v[0], v[2]));
                LinkTwins(faces[0].edge, faces[1].edge.next);
                LinkTwins(faces[0].edge.next, faces[2].edge.next);
                LinkTwins(faces[0].edge.prev, faces[3].edge.next);
                LinkTwins(faces[1].edge, faces[2].edge.prev);
                LinkTwins(faces[1].edge.prev, faces[3].edge);
                LinkTwins(faces[2].edge, faces[3].edge.prev);
                foreach (var vert in vertices)
                {
                    if (vert.onHull) continue;
                    QHFace bestFace = null;
                    float maxPointDist = epsilon;
                    foreach (var face in faces)
                    {
                        float dist = Vector3.Dot(face.normal, vert.position) - face.distance;
                        if (dist > maxPointDist)
                        {
                            maxPointDist = dist;
                            bestFace = face;
                        }
                    }
                    if (bestFace != null) bestFace.outsideSet.Add(vert);
                }
                return true;
            }
            private static float DistanceToLineSq(Vector3 p, Vector3 a, Vector3 b)
            {
                Vector3 ab = b - a;
                Vector3 ap = p - a;
                return Vector3.Cross(ab, ap).sqrMagnitude / ab.sqrMagnitude;
            }
            private static float DistanceToPlane(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
            {
                Vector3 normal = Vector3.Cross(b - a, c - a).normalized;
                return Vector3.Dot(normal, p - a);
            }
            private static QHFace CreateFace(QHVertex a, QHVertex b, QHVertex c)
            {
                var face = new QHFace();
                var e0 = new QHHalfEdge { vertex = a, face = face };
                var e1 = new QHHalfEdge { vertex = b, face = face };
                var e2 = new QHHalfEdge { vertex = c, face = face };
                e0.next = e1; e1.prev = e0;
                e1.next = e2; e2.prev = e1;
                e2.next = e0; e0.prev = e2;
                face.edge = e0;
                face.normal = Vector3.Cross(b.position - a.position, c.position - a.position).normalized;
                face.distance = Vector3.Dot(face.normal, a.position);
                return face;
            }
            private static void LinkTwins(QHHalfEdge e1, QHHalfEdge e2)
            {
                e1.twin = e2;
                e2.twin = e1;
            }
            // Additional: Simplify hull
            public static ConvexHull Simplify(ConvexHull hull, ConvexDecompositionSettings settings, float tolerance)
            {
                hull.OptimizeHull(settings, tolerance);
                return hull;
            }
        }
        /// <summary>
        /// Mesh boolean operations with proper clipping
        /// </summary>
        public static class MeshBooleanOperations
        {
            static int Add(MeshData m, Vector3 p, Vector3 n)
            {
                if (m.vertices == null) m.vertices = new List<Vector3>();
                if (m.normals == null) m.normals = new List<Vector3>();
                for (int i = 0; i < m.vertices.Count; i++)
                    if ((m.vertices[i] - p).sqrMagnitude < 1e-12f) return i;
                m.vertices.Add(p);
                m.normals.Add(n);
                return m.vertices.Count - 1;
            }
            public static MeshData BooleanIntersect(MeshData mesh, Bounds box)
            {
                var outMesh = new MeshData();
                var boxPlanes = new List<PlaneF>
                {
                    new PlaneF { n = Vector3.right, d = -box.max.x },
                    new PlaneF { n = Vector3.left, d = box.min.x },
                    new PlaneF { n = Vector3.up, d = -box.max.y },
                    new PlaneF { n = Vector3.down, d = box.min.y },
                    new PlaneF { n = Vector3.forward, d = -box.max.z },
                    new PlaneF { n = Vector3.back, d = box.min.z },
                };
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i + 1], i2 = mesh.indices[i + 2];
                    var v0 = mesh.vertices[i0]; var v1 = mesh.vertices[i1]; var v2 = mesh.vertices[i2];
                    var n0 = mesh.normals.Count > i0 ? mesh.normals[i0] : Vector3.zero;
                    var n1 = mesh.normals.Count > i1 ? mesh.normals[i1] : Vector3.zero;
                    var n2 = mesh.normals.Count > i2 ? mesh.normals[i2] : Vector3.zero;
                    foreach (var (p0, p1, p2, norm0, norm1, norm2) in ClipTriAgainstConvex(v0, v1, v2, n0, n1, n2, boxPlanes))
                    {
                        int ia = Add(outMesh, p0, norm0);
                        int ib = Add(outMesh, p1, norm1);
                        int ic = Add(outMesh, p2, norm2);
                        outMesh.indices.AddRange(new[] { ia, ib, ic });
                    }
                }
                outMesh.Optimize();
                return outMesh;
            }
            public static MeshData BooleanDifference(MeshData mesh, Bounds box)
            {
                var outMesh = new MeshData();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i + 1], i2 = mesh.indices[i + 2];
                    var center = (mesh.vertices[i0] + mesh.vertices[i1] + mesh.vertices[i2]) / 3f;
                    if (!box.Contains(center)) // This is still a simplification, full difference is much harder.
                    {
                        var n0 = mesh.normals.Count > i0 ? mesh.normals[i0] : Vector3.up;
                        var n1 = mesh.normals.Count > i1 ? mesh.normals[i1] : Vector3.up;
                        var n2 = mesh.normals.Count > i2 ? mesh.normals[i2] : Vector3.up;
                        int ia = Add(outMesh, mesh.vertices[i0], n0);
                        int ib = Add(outMesh, mesh.vertices[i1], n1);
                        int ic = Add(outMesh, mesh.vertices[i2], n2);
                        outMesh.indices.AddRange(new[] { ia, ib, ic });
                    }
                }
                outMesh.Optimize();
                return outMesh;
            }
            public static ConvexHull BooleanUnion(ConvexHull hull1, ConvexHull hull2, ConvexDecompositionSettings settings)
            {
                var allPoints = new List<Vector3>(hull1.vertices);
                allPoints.AddRange(hull2.vertices);
                var union = QuickHullImplementation.ComputeConvexHullFromPoints(allPoints);
                // Additional: Optimize union
                union.OptimizeHull(settings, 0.001f);
                return union;
            }
            static IEnumerable<(Vector3, Vector3)> ClipPolyAgainstPlane(IEnumerable<(Vector3 p, Vector3 n)> poly, Vector3 N, float d, float eps = 1e-6f)
            {
                var input = new List<(Vector3 p, Vector3 n)>(poly);
                if (input.Count == 0) yield break;
                var prev = input[input.Count - 1];
                float dpPrev = Vector3.Dot(N, prev.p) + d;
                for (int i = 0; i < input.Count; i++)
                {
                    var curr = input[i];
                    float dpCurr = Vector3.Dot(N, curr.p) + d;
                    bool currIn = dpCurr <= eps, prevIn = dpPrev <= eps;
                    if (currIn != prevIn)
                    {
                        float t = dpPrev / (dpPrev - dpCurr);
                        var ip = Vector3.Lerp(prev.p, curr.p, t);
                        var inorm = Vector3.Lerp(prev.n, curr.n, t).normalized;
                        yield return (ip, inorm);
                    }
                    if (currIn)
                    {
                        yield return curr;
                    }
                    prev = curr; dpPrev = dpCurr;
                }
            }
            static IEnumerable<(Vector3, Vector3, Vector3, Vector3, Vector3, Vector3)> ClipTriAgainstConvex(
                Vector3 v0, Vector3 v1, Vector3 v2, Vector3 n0, Vector3 n1, Vector3 n2, List<PlaneF> planes)
            {
                var poly = new List<(Vector3 p, Vector3 n)> { (v0, n0), (v1, n1), (v2, n2) };
                foreach (var pl in planes)
                {
                    poly = new List<(Vector3 p, Vector3 n)>(ClipPolyAgainstPlane(poly, pl.n, pl.d));
                    if (poly.Count < 3) yield break;
                }
                for (int i = 1; i + 1 < poly.Count; i++)
                    yield return (poly[0].p, poly[i].p, poly[i + 1].p, poly[0].n, poly[i].n, poly[i + 1].n);
            }
            public static ConvexHull BooleanIntersection(ConvexHull hullA, ConvexHull hullB)
            {
                if (hullB.planes == null || hullB.planes.Count == 0) hullB.BuildPlanes();
                var outMesh = new MeshData();
                for (int i = 0; i < hullA.indices.Count; i += 3)
                {
                    int i0 = hullA.indices[i], i1 = hullA.indices[i + 1], i2 = hullA.indices[i + 2];
                    var a = hullA.vertices[i0]; var b = hullA.vertices[i1]; var c = hullA.vertices[i2];
                    var na = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i0] : Vector3.up;
                    var nb = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i1] : Vector3.up;
                    var nc = (hullA.normals.Count == hullA.vertices.Count) ? hullA.normals[i2] : Vector3.up;
                    foreach (var (p0, p1, p2, norm0, norm1, norm2) in ClipTriAgainstConvex(a, b, c, na, nb, nc, hullB.planes))
                    {
                        int ia = Add(outMesh, p0, norm0);
                        int ib = Add(outMesh, p1, norm1);
                        int ic = Add(outMesh, p2, norm2);
                        outMesh.indices.Add(ia); outMesh.indices.Add(ib); outMesh.indices.Add(ic);
                    }
                }
                outMesh.CalculateProperties();
                var intersection = QuickHullImplementation.ComputeConvexHullFromPoints(outMesh.vertices);
                // Additional: Validate intersection
                intersection.ValidateHull();
                return intersection;
            }
            public static MeshData BooleanDifference(MeshData mesh, Bounds box)
            {
                 var boxPlanes = new List<PlaneF>
                {
                    new PlaneF { n = Vector3.right, d = box.min.x },
                    new PlaneF { n = Vector3.left, d = -box.max.x },
                    new PlaneF { n = Vector3.up, d = box.min.y },
                    new PlaneF { n = Vector3.down, d = -box.max.y },
                    new PlaneF { n = Vector3.forward, d = box.min.z },
                    new PlaneF { n = Vector3.back, d = -box.max.z },
                };

                var tempMesh = mesh;
                foreach(var plane in boxPlanes)
                {
                    var clippedOut = new MeshData();
                    // We want the part of the mesh that is OUTSIDE the box, so we take the negative side of the inverted planes
                    var invertedPlane = new PlaneF { n = -plane.n, d = -plane.d};
                    MeshSplitter.Split(tempMesh, invertedPlane, out _, out clippedOut);
                    tempMesh = clippedOut;
                }
                return tempMesh;
            }

            public static MeshData BooleanDifference(MeshData meshA, MeshData meshB)
            {
                return BooleanDifference(meshA, meshB.bounds);
            }
            // Additional: Boolean XOR
            public static MeshData BooleanXOR(MeshData a, MeshData b)
            {
                var intersect = BooleanIntersect(a, b.bounds);
                var diffA = BooleanDifference(a, b.bounds);
                var diffB = BooleanDifference(b, a.bounds);
                // Combine diffA, diffB, but subtract intersect if needed
                // ... (add logic)
                return diffA;
            }
            // Additional: Boolean Union for meshes
            public static MeshData BooleanUnion(MeshData a, MeshData b)
            {
                var hullA = QuickHullImplementation.ComputeConvexHullFromPoints(a.vertices);
                var hullB = QuickHullImplementation.ComputeConvexHullFromPoints(b.vertices);
                var unionHull = BooleanUnion(hullA, hullB);
                var unionMesh = new MeshData { vertices = unionHull.vertices, indices = unionHull.indices };
                return unionMesh;
            }
        }

        /// <summary>
        /// Isotropic Remeshing implementation to regularize mesh geometry before decomposition.
        /// This is a crucial pre-processing step for high-quality results.
        /// </summary>
        public static class IsotropicRemesher
        {
            public static void Remesh(MeshData mesh, float targetEdgeLength, int iterations)
            {
                if (mesh == null || mesh.vertexCount == 0) return;

                var originalMesh = new MeshData // Keep a copy for surface projection
                {
                    vertices = new List<Vector3>(mesh.vertices),
                    indices = new List<int>(mesh.indices)
                };
                originalMesh.BuildAccelerationStructure();

                float minEdgeLength = 4.0f / 5.0f * targetEdgeLength;
                float maxEdgeLength = 4.0f / 3.0f * targetEdgeLength;

                for (int i = 0; i < iterations; i++)
                {
                    SplitLongEdges(mesh, maxEdgeLength);
                    CollapseShortEdges(mesh, minEdgeLength);
                    FlipEdges(mesh);
                    TangentialRelaxation(mesh, originalMesh);
                }
                mesh.CalculateProperties(); // Recalculate all mesh properties after remeshing.
            }

            private static void SplitLongEdges(MeshData mesh, float maxLength)
            {
                var edges = GetEdges(mesh);
                var maxLengthSq = maxLength * maxLength;

                for (int i = 0; i < edges.Count; i++)
                {
                    var edge = edges[i];
                    var p0 = mesh.vertices[edge.Item1];
                    var p1 = mesh.vertices[edge.Item2];

                    if ((p1 - p0).sqrMagnitude > maxLengthSq)
                    {
                        var midpoint = (p0 + p1) / 2.0f;
                        int midVertexIndex = mesh.vertices.Count;
                        mesh.vertices.Add(midpoint);

                        var trianglesToSplit = FindTrianglesWithEdge(mesh, edge.Item1, edge.Item2);

                        foreach(var triIdx in trianglesToSplit)
                        {
                            int v0 = mesh.indices[triIdx];
                            int v1 = mesh.indices[triIdx + 1];
                            int v2 = mesh.indices[triIdx + 2];
                            int thirdVertex = -1;

                            if (v0 != edge.Item1 && v0 != edge.Item2) thirdVertex = v0;
                            else if (v1 != edge.Item1 && v1 != edge.Item2) thirdVertex = v1;
                            else thirdVertex = v2;

                            mesh.indices.RemoveRange(triIdx, 3);
                            mesh.indices.Add(edge.Item1);
                            mesh.indices.Add(midVertexIndex);
                            mesh.indices.Add(thirdVertex);

                            mesh.indices.Add(midVertexIndex);
                            mesh.indices.Add(edge.Item2);
                            mesh.indices.Add(thirdVertex);
                        }
                    }
                }
            }

            private static void CollapseShortEdges(MeshData mesh, float minLength)
            {
                var edges = GetEdges(mesh);
                var minLengthSq = minLength * minLength;
                var deletedTris = new bool[mesh.indices.Count / 3];
                var vertexRemap = new int[mesh.vertexCount];
                for (int i = 0; i < mesh.vertexCount; i++) vertexRemap[i] = i;

                foreach (var edge in edges)
                {
                    int u_orig = edge.Item1;
                    int v_orig = edge.Item2;

                    int u = vertexRemap[u_orig];
                    int v = vertexRemap[v_orig];

                    if (u == v) continue;

                    if ((mesh.vertices[v] - mesh.vertices[u]).sqrMagnitude < minLengthSq)
                    {
                        // Check if collapse is valid
                        if (!IsCollapseValid(mesh, u, v)) continue;

                        // Collapse v into u
                        var trianglesToRemove = FindTrianglesWithEdge(mesh, u, v);
                        foreach(var triIdx in trianglesToRemove)
                        {
                            deletedTris[triIdx / 3] = true;
                        }

                        // Remap all triangles using v to use u instead
                        for(int i = 0; i < mesh.indices.Count; i++)
                        {
                            if (vertexRemap[mesh.indices[i]] == v)
                            {
                                mesh.indices[i] = u;
                            }
                        }
                        vertexRemap[v] = u;
                    }
                }

                // Rebuild the index buffer
                var newIndices = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    if (deletedTris[i / 3]) continue;

                    int i0 = mesh.indices[i];
                    int i1 = mesh.indices[i+1];
                    int i2 = mesh.indices[i+2];

                    if (i0 != i1 && i1 != i2 && i0 != i2) // Remove degenerate triangles
                    {
                        newIndices.Add(i0);
                        newIndices.Add(i1);
                        newIndices.Add(i2);
                    }
                }
                mesh.indices = newIndices;
                mesh.Optimize(); // Clean up unused vertices
            }

            private static bool IsCollapseValid(MeshData mesh, int u, int v)
            {
                // Find one-ring neighbors of u and v
                var neighborsU = GetOneRingNeighbors(mesh, u);
                var neighborsV = GetOneRingNeighbors(mesh, v);

                // Find common neighbors
                var commonNeighbors = neighborsU.Intersect(neighborsV).ToList();
                if (commonNeighbors.Count != 2)
                {
                    // This collapse would create a non-manifold topology (e.g., edge is not part of exactly two triangles)
                    return false;
                }

                // Check for normal flipping on adjacent faces
                var trisU = FindTrianglesWithVertex(mesh, u);
                foreach(var triIdx in trisU)
                {
                    if (FindTrianglesWithVertex(mesh, v).Contains(triIdx)) continue; // Skip common triangles

                    var v0_idx = mesh.indices[triIdx];
                    var v1_idx = mesh.indices[triIdx + 1];
                    var v2_idx = mesh.indices[triIdx + 2];

                    var n_before = Vector3.Cross(mesh.vertices[v1_idx] - mesh.vertices[v0_idx], mesh.vertices[v2_idx] - mesh.vertices[v0_idx]);

                    if (v0_idx == u) v0_idx = v;
                    if (v1_idx == u) v1_idx = v;
                    if (v2_idx == u) v2_idx = v;

                    var n_after = Vector3.Cross(mesh.vertices[v1_idx] - mesh.vertices[v0_idx], mesh.vertices[v2_idx] - mesh.vertices[v0_idx]);

                    if (Vector3.Dot(n_before, n_after) < 0.5f) // Heuristic threshold for normal flip
                    {
                        return false;
                    }
                }
                return true;
            }

            private static List<int> GetOneRingNeighbors(MeshData mesh, int vertexIndex)
            {
                var neighbors = new List<int>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    if(i0 == vertexIndex) { neighbors.Add(i1); neighbors.Add(i2); }
                    if(i1 == vertexIndex) { neighbors.Add(i0); neighbors.Add(i2); }
                    if(i2 == vertexIndex) { neighbors.Add(i0); neighbors.Add(i1); }
                }
                return neighbors.Distinct().ToList();
            }

             private static List<int> FindTrianglesWithVertex(MeshData mesh, int v)
            {
                var tris = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    if (mesh.indices[i] == v || mesh.indices[i+1] == v || mesh.indices[i+2] == v)
                    {
                        tris.Add(i);
                    }
                }
                return tris;
            }

            private static void FlipEdges(MeshData mesh)
            {
                var edges = GetEdges(mesh);
                var edgeToTriangles = GetEdgeToTriangleMap(mesh);

                for (int i = 0; i < edges.Count; i++)
                {
                    var edge = edges[i];
                    if (!edgeToTriangles.ContainsKey(edge) || edgeToTriangles[edge].Count != 2)
                    {
                        continue; // Boundary edge, cannot flip
                    }

                    var t1_idx = edgeToTriangles[edge][0];
                    var t2_idx = edgeToTriangles[edge][1];

                    var t1 = new int[] { mesh.indices[t1_idx], mesh.indices[t1_idx + 1], mesh.indices[t1_idx + 2] };
                    var t2 = new int[] { mesh.indices[t2_idx], mesh.indices[t2_idx + 1], mesh.indices[t2_idx + 2] };

                    int v0 = edge.Item1;
                    int v1 = edge.Item2;
                    int v2 = -1, v3 = -1;

                    // Find the other two vertices of the quadrilateral
                    foreach(int v_idx in t1) if (v_idx != v0 && v_idx != v1) v2 = v_idx;
                    foreach(int v_idx in t2) if (v_idx != v0 && v_idx != v1) v3 = v_idx;

                    if (v2 == -1 || v3 == -1) continue;

                    // Check if the new edge (v2, v3) already exists
                    if (edgeToTriangles.ContainsKey(v2 < v3 ? (v2, v3) : (v3, v2))) continue;

                    // Lawson's criterion: flip if it improves the minimum angle
                    float minAngleBefore = Mathf.Min(CalculateMinAngle(mesh, t1), CalculateMinAngle(mesh, t2));

                    var new_t1 = new int[] { v0, v2, v3 };
                    var new_t2 = new int[] { v1, v3, v2 };

                    float minAngleAfter = Mathf.Min(CalculateMinAngle(mesh, new_t1), CalculateMinAngle(mesh, new_t2));

                    if (minAngleAfter > minAngleBefore)
                    {
                        // Flip the edge
                        mesh.indices[t1_idx] = new_t1[0];
                        mesh.indices[t1_idx + 1] = new_t1[1];
                        mesh.indices[t1_idx + 2] = new_t1[2];

                        mesh.indices[t2_idx] = new_t2[0];
                        mesh.indices[t2_idx + 1] = new_t2[1];
                        mesh.indices[t2_idx + 2] = new_t2[2];
                    }
                }
            }

            private static float CalculateMinAngle(MeshData mesh, int[] tri)
            {
                Vector3 p0 = mesh.vertices[tri[0]];
                Vector3 p1 = mesh.vertices[tri[1]];
                Vector3 p2 = mesh.vertices[tri[2]];

                float a = (p1-p0).magnitude;
                float b = (p2-p1).magnitude;
                float c = (p0-p2).magnitude;

                float angle1 = Mathf.Acos((b*b + c*c - a*a) / (2*b*c));
                float angle2 = Mathf.Acos((a*a + c*c - b*b) / (2*a*c));
                float angle3 = Mathf.Acos((a*a + b*b - c*c) / (2*a*b));

                return Mathf.Min(angle1, angle2, angle3) * Mathf.Rad2Deg;
            }

            private static Dictionary<(int, int), List<int>> GetEdgeToTriangleMap(MeshData mesh)
            {
                var map = new Dictionary<(int, int), List<int>>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        int v1 = mesh.indices[i + j];
                        int v2 = mesh.indices[i + ((j + 1) % 3)];
                        var edge = v1 < v2 ? (v1, v2) : (v2, v1);
                        if (!map.ContainsKey(edge)) map[edge] = new List<int>();
                        map[edge].Add(i);
                    }
                }
                return map;
            }

            private static void TangentialRelaxation(MeshData mesh, MeshData originalMesh)
            {
                var newPositions = new List<Vector3>(mesh.vertices);
                var adj = BuildAdjacency(mesh);

                for (int i = 0; i < mesh.vertices.Count; i++)
                {
                    var neighbors = adj[i];
                    if (neighbors.Count == 0) continue;

                    var centroid = Vector3.zero;
                    foreach(var nIdx in neighbors)
                    {
                        centroid += mesh.vertices[nIdx];
                    }
                    centroid /= neighbors.Count;

                    var newPos = ProjectToSurface(centroid, originalMesh);
                    newPositions[i] = newPos;
                }
                mesh.vertices = newPositions;
            }

            private static Vector3 ProjectToSurface(Vector3 point, MeshData targetMesh)
            {
                float closestDistSq = float.MaxValue;
                Vector3 closestPoint = point;

                // This is a slow projection. A BVH on the original mesh is required for performance.
                for(int i=0; i<targetMesh.indices.Count; i+=3)
                {
                    var a = targetMesh.vertices[targetMesh.indices[i]];
                    var b = targetMesh.vertices[targetMesh.indices[i+1]];
                    var c = targetMesh.vertices[targetMesh.indices[i+2]];
                    var p = ClosestPointOnTriangle(point, a, b, c);
                    float distSq = (point - p).sqrMagnitude;
                    if(distSq < closestDistSq)
                    {
                        closestDistSq = distSq;
                        closestPoint = p;
                    }
                }
                return closestPoint;
            }
             private static Vector3 ClosestPointOnTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c)
            {
                var ab = b - a; var ac = c - a; var ap = p - a;
                float d1 = Vector3.Dot(ab, ap), d2 = Vector3.Dot(ac, ap);
                if (d1 <= 0 && d2 <= 0) return a;

                var bp = p - b; float d3 = Vector3.Dot(ab, bp), d4 = Vector3.Dot(ac, bp);
                if (d3 >= 0 && d4 <= d3) return b;

                float vc = d1 * d4 - d3 * d2;
                if (vc <= 0 && d1 >= 0 && d3 <= 0) { float v = d1 / (d1 - d3); return a + v * ab; }

                var cp = p - c; float d5 = Vector3.Dot(ab, cp), d6 = Vector3.Dot(ac, cp);
                if (d6 >= 0 && d5 <= d6) return c;

                float vb = d5 * d2 - d1 * d6;
                if (vb <= 0 && d2 >= 0 && d6 <= 0) { float w = d2 / (d2 - d6); return a + w * ac; }

                float va = d3 * d6 - d5 * d4;
                if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) { float w = (d4 - d3) / ((d4 - d3) + (d5 - d6)); return b + w * (c-b); }

                float den = 1.0f / (va + vb + vc);
                float v_ = vb * den;
                float w_ = vc * den;
                return a + ab * v_ + ac * w_;
            }

            private static List<(int, int)> GetEdges(MeshData mesh)
            {
                var edges = new HashSet<(int, int)>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    for(int j=0; j<3; j++)
                    {
                        int v1 = mesh.indices[i+j];
                        int v2 = mesh.indices[i+((j+1)%3)];
                        edges.Add(v1 < v2 ? (v1,v2) : (v2,v1));
                    }
                }
                return edges.ToList();
            }

            private static List<int> FindTrianglesWithEdge(MeshData mesh, int v1, int v2)
            {
                var tris = new List<int>();
                for (int i = 0; i < mesh.indices.Count; i += 3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    if ((i0 == v1 && i1 == v2) || (i1 == v1 && i0 == v2) ||
                        (i1 == v1 && i2 == v2) || (i2 == v1 && i1 == v2) ||
                        (i2 == v1 && i0 == v2) || (i0 == v1 && i2 == v2))
                    {
                        tris.Add(i);
                    }
                }
                return tris;
            }

            private static Dictionary<int, List<int>> BuildAdjacency(MeshData mesh)
            {
                var adj = new Dictionary<int, List<int>>();
                for(int i=0; i<mesh.vertexCount; i++) adj[i] = new List<int>();
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    adj[i0].Add(i1); adj[i0].Add(i2);
                    adj[i1].Add(i0); adj[i1].Add(i2);
                    adj[i2].Add(i0); adj[i2].Add(i1);
                }
                for(int i=0; i<mesh.vertexCount; i++) adj[i] = adj[i].Distinct().ToList();
                return adj;
            }
        }

        /// <summary>
        /// Split plane evaluator for finding optimal split planes
        /// </summary>
        public static class JumpFlooding
        {
            [BurstCompile]
            private struct SeedJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<Vector3> Vertices;
                [ReadOnly] public NativeArray<int> Indices;
                public NativeArray<int3> SeedLocations; // Stores the xyz of the closest seed
                public int3 Dimensions;
                public Bounds VoxelBounds;
                public float3 VoxelSize;

                public void Execute(int index)
                {
                    // Initialize with a marker for empty voxels
                    SeedLocations[index] = new int3(-1, -1, -1);
                }
            }

            [BurstCompile]
            private struct JumpPassJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<int3> ReadSeedLocations;
                public NativeArray<int3> WriteSeedLocations;
                public int3 Dimensions;
                public int Step;

                public void Execute(int index)
                {
                    int3 p = new int3(index % Dimensions.x, (index / Dimensions.x) % Dimensions.y, index / (Dimensions.x * Dimensions.y));
                    int3 bestSeed = ReadSeedLocations[index];
                    float minDistSq = float.MaxValue;

                    if(bestSeed.x != -1)
                    {
                        minDistSq = math.lengthsq(p - bestSeed);
                    }

                    for (int z = -1; z <= 1; z++)
                    for (int y = -1; y <= 1; y++)
                    for (int x = -1; x <= 1; x++)
                    {
                        if (x == 0 && y == 0 && z == 0) continue;

                        int3 neighborP = p + new int3(x * Step, y * Step, z * Step);
                        if (neighborP.x < 0 || neighborP.x >= Dimensions.x ||
                            neighborP.y < 0 || neighborP.y >= Dimensions.y ||
                            neighborP.z < 0 || neighborP.z >= Dimensions.z) continue;

                        int neighborIdx = neighborP.x + Dimensions.x * (neighborP.y + Dimensions.y * neighborP.z);
                        int3 neighborSeed = ReadSeedLocations[neighborIdx];

                        if (neighborSeed.x != -1)
                        {
                            float distSq = math.lengthsq(p - neighborSeed);
                            if (distSq < minDistSq)
                            {
                                minDistSq = distSq;
                                bestSeed = neighborSeed;
                            }
                        }
                    }
                    WriteSeedLocations[index] = bestSeed;
                }
            }

            [BurstCompile]
            private struct FinalSDFJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<int3> SeedLocations;
                public NativeArray<float> SDF;
                public int3 Dimensions;
                public float3 VoxelSize;

                public void Execute(int index)
                {
                    int3 p = new int3(index % Dimensions.x, (index / Dimensions.x) % Dimensions.y, index / (Dimensions.x * Dimensions.y));
                    int3 seed = SeedLocations[index];
                    if (seed.x == -1)
                    {
                        SDF[index] = float.MaxValue;
                    }
                    else
                    {
                        float3 p_world = p * VoxelSize;
                        float3 seed_world = seed * VoxelSize;
                        SDF[index] = math.length(p_world - seed_world);
                    }
                }
            }

            [BurstCompile]
            private struct SignPassJob : IJobParallelFor
            {
                [ReadOnly] public NativeArray<Vector3> Vertices;
                [ReadOnly] public NativeArray<int> Indices;
                public NativeArray<float> SDF;
                public int3 Dimensions;
                public Bounds VoxelBounds;
                public float3 VoxelSize;

                public void Execute(int index)
                {
                    float3 voxelCenter = VoxelBounds.min + new float3(index % Dimensions.x, (index / Dimensions.x) % Dimensions.y, index / (Dimensions.x * Dimensions.y)) * VoxelSize;

                    int crossings = 0;
                    float3 rayDir = new float3(1, 0.1f, 0.05f); // Jittered ray to avoid hitting edges/verts

                    for(int i=0; i < Indices.Length; i+=3)
                    {
                        float3 v0 = Vertices[Indices[i]];
                        float3 v1 = Vertices[Indices[i+1]];
                        float3 v2 = Vertices[Indices[i+2]];

                        if(RayTriangleIntersect(voxelCenter, rayDir, v0, v1, v2))
                        {
                            crossings++;
                        }
                    }

                    if(crossings % 2 == 1) // Odd number of crossings means we are inside
                    {
                        SDF[index] *= -1.0f;
                    }
                }

                // Moller-Trumbore intersection algorithm
                private bool RayTriangleIntersect(float3 ro, float3 rd, float3 v0, float3 v1, float3 v2)
                {
                    float3 edge1 = v1 - v0;
                    float3 edge2 = v2 - v0;
                    float3 h = math.cross(rd, edge2);
                    float a = math.dot(edge1, h);
                    if (a > -1e-6 && a < 1e-6) return false; // Parallel

                    float f = 1.0f / a;
                    float3 s = ro - v0;
                    float u = f * math.dot(s, h);
                    if (u < 0.0 || u > 1.0) return false;

                    float3 q = math.cross(s, edge1);
                    float v = f * math.dot(rd, q);
                    if (v < 0.0 || u + v > 1.0) return false;

                    float t = f * math.dot(edge2, q);
                    return t > 1e-6; // Epsilon check
                }
            }

            public static void GenerateSDF(MeshData mesh)
            {
                int voxelCount = mesh.voxelDimensions.x * mesh.voxelDimensions.y * mesh.voxelDimensions.z;
                var seedLocations = new NativeArray<int3>(voxelCount, Allocator.TempJob);
                var tempSeedLocations = new NativeArray<int3>(voxelCount, Allocator.TempJob);

                var vertices = new NativeArray<Vector3>(mesh.vertices.ToArray(), Allocator.TempJob);
                var indices = new NativeArray<int>(mesh.indices.ToArray(), Allocator.TempJob);

                // 1. Seeding Pass
                var seedJob = new SeedJob
                {
                    Vertices = vertices,
                    Indices = indices,
                    SeedLocations = seedLocations,
                    Dimensions = mesh.voxelDimensions,
                    VoxelBounds = mesh.voxelBounds,
                    VoxelSize = mesh.voxelBounds.size / new float3(mesh.voxelDimensions)
                };
                seedJob.Schedule(voxelCount, 64).Complete();

                // This part is slow. A better approach would be to rasterize the triangles.
                for(int i=0; i<mesh.indices.Count; i+=3)
                {
                    var v0 = mesh.vertices[mesh.indices[i]];
                    var v1 = mesh.vertices[mesh.indices[i+1]];
                    var v2 = mesh.vertices[mesh.indices[i+2]];
                    var c0 = mesh.WorldToVoxel(v0);
                    var c1 = mesh.WorldToVoxel(v1);
                    var c2 = mesh.WorldToVoxel(v2);
                    // Simple rasterization - mark voxels containing vertices
                     if(mesh.IsVoxelInBounds(c0)) seedLocations[c0.x + c0.y * mesh.voxelDimensions.x + c0.z * mesh.voxelDimensions.x * mesh.voxelDimensions.y] = c0;
                     if(mesh.IsVoxelInBounds(c1)) seedLocations[c1.x + c1.y * mesh.voxelDimensions.x + c1.z * mesh.voxelDimensions.x * mesh.voxelDimensions.y] = c1;
                     if(mesh.IsVoxelInBounds(c2)) seedLocations[c2.x + c2.y * mesh.voxelDimensions.x + c2.z * mesh.voxelDimensions.x * mesh.voxelDimensions.y] = c2;
                }

                // 2. Jump Flooding Passes
                int maxDim = math.max(mesh.voxelDimensions.x, math.max(mesh.voxelDimensions.y, mesh.voxelDimensions.z));
                int step = (int)math.pow(2, math.floor(math.log2(maxDim)));

                var read = seedLocations;
                var write = tempSeedLocations;

                while(step >= 1)
                {
                    var jumpJob = new JumpPassJob
                    {
                        ReadSeedLocations = read,
                        WriteSeedLocations = write,
                        Dimensions = mesh.voxelDimensions,
                        Step = step
                    };
                    jumpJob.Schedule(voxelCount, 64).Complete();

                    // Swap buffers
                    var tmp = read;
                    read = write;
                    write = tmp;

                    step /= 2;
                }

                // 3. Final Distance Calculation
                var finalSDFJob = new FinalSDFJob
                {
                    SeedLocations = read,
                    SDF = mesh.sdfValues,
                    Dimensions = mesh.voxelDimensions,
                    VoxelSize = mesh.voxelBounds.size / new float3(mesh.voxelDimensions)
                };
                finalSDFJob.Schedule(voxelCount, 64).Complete();

                // 4. Sign Pass
                var signPassJob = new SignPassJob
                {
                    Vertices = vertices,
                    Indices = indices,
                    SDF = mesh.sdfValues,
                    Dimensions = mesh.voxelDimensions,
                    VoxelBounds = mesh.voxelBounds,
                    VoxelSize = mesh.voxelBounds.size / new float3(mesh.voxelDimensions)
                };
                signPassJob.Schedule(voxelCount, 64).Complete();

                seedLocations.Dispose();
                tempSeedLocations.Dispose();
                vertices.Dispose();
                indices.Dispose();
            }
        }
        public static class SplitPlaneEvaluator
        {
            public static (Vector3 normal, Vector3 point) FindBestSplitPlane(MeshData mesh, ConvexHull hull, float concavity)
            {
                // Find the deepest point of concavity (witness point)
                Vector3 witnessPoint = Vector3.zero;
                float maxDist = -1f;
                foreach (var vert in mesh.vertices)
                {
                    float dist = hull.DistanceToPoint(vert);
                    if (dist > maxDist)
                    {
                        maxDist = dist;
                        witnessPoint = vert;
                    }
                }
                var candidates = GenerateSplitPlaneCandidates(mesh, hull, witnessPoint);
                if (candidates.Count == 0) return (Vector3.up, mesh.bounds.center);
                var bestPlane = (Vector3.zero, Vector3.zero);
                float bestScore = float.MaxValue; // We want to minimize the score
                foreach (var candidate in candidates)
                {
                    float score = EvaluateSplitPlane(mesh, candidate.normal, candidate.point);
                    if (score < bestScore)
                    {
                        bestScore = score;
                        bestPlane = candidate;
                    }
                }
                return bestPlane;
            }
            private static List<(Vector3 normal, Vector3 point)> GenerateSplitPlaneCandidates(MeshData mesh, ConvexHull hull, Vector3 witnessPoint)
            {
                var candidates = new List<(Vector3 normal, Vector3 point)>();
                if (mesh.vertices.Count < 10) return candidates;
                // Candidate 1: Plane aligned with axis-aligned bounding box
                candidates.Add((Vector3.right, mesh.bounds.center));
                candidates.Add((Vector3.up, mesh.bounds.center));
                candidates.Add((Vector3.forward, mesh.bounds.center));
                // Candidate 2: Plane through witness point
                Vector3 closestPointOnHull = hull.bounds.ClosestPoint(witnessPoint);
                Vector3 witnessNormal = (witnessPoint - closestPointOnHull).normalized;
                if (witnessNormal.sqrMagnitude > 0.1f)
                {
                    candidates.Add((witnessNormal, witnessPoint));
                }
                // Candidate 3: PCA-aligned plane
                CalculatePCA(mesh.vertices, out Vector3 pca1, out Vector3 pca2, out Vector3 pca3);
                candidates.Add((pca1, mesh.bounds.center));
                candidates.Add((pca2, mesh.bounds.center));
                candidates.Add((pca3, mesh.bounds.center));
                // Additional candidates: Based on features
                if (mesh.featureVertices != null)
                {
                    if (mesh.featureVertices.Count >= 3)
                    {
                        var fv1 = mesh.vertices[mesh.featureVertices[0]];
                        var fv2 = mesh.vertices[mesh.featureVertices[1]];
                        var fv3 = mesh.vertices[mesh.featureVertices[2]];
                        var featureNormal = Vector3.Cross(fv2 - fv1, fv3 - fv1).normalized;
                        candidates.Add((featureNormal, (fv1 + fv2 + fv3) / 3f));
                    }
                }
                // Additional: Voxel-based candidates
                var voxelCandidate = GenerateVoxelBasedCandidate(mesh);
                if (voxelCandidate.normal != Vector3.zero)
                    candidates.Add(voxelCandidate);
                return candidates;
            }
            private static (Vector3 normal, Vector3 point) GenerateVoxelBasedCandidate(MeshData mesh)
            {
                // Use voxel data to find high concavity plane
                // ... (add logic)
                return (Vector3.up, mesh.bounds.center); // Placeholder
            }
            private static float EvaluateSplitPlane(MeshData mesh, Vector3 normal, Vector3 point)
            {
                // Use a cost function based on the Surface Area Heuristic (SAH)
                // This tries to create balanced splits.
                Bounds leftBounds = new Bounds();
                Bounds rightBounds = new Bounds();
                int leftCount = 0, rightCount = 0;
                bool firstLeft = true, firstRight = true;
                foreach (var v in mesh.vertices)
                {
                    float side = Vector3.Dot(v - point, normal);
                    if (side <= 0)
                    {
                        if (firstLeft) { leftBounds = new Bounds(v, Vector3.zero); firstLeft = false; }
                        else { leftBounds.Encapsulate(v); }
                        leftCount++;
                    }
                    else
                    {
                        if (firstRight) { rightBounds = new Bounds(v, Vector3.zero); firstRight = false; }
                        else { rightBounds.Encapsulate(v); }
                        rightCount++;
                    }
                }
                if (leftCount == 0 || rightCount == 0) return float.MaxValue; // Invalid split
                float surfaceAreaLeft = 2 * (leftBounds.size.x * leftBounds.size.y + leftBounds.size.x * leftBounds.size.z + leftBounds.size.y * leftBounds.size.z);
                float surfaceAreaRight = 2 * (rightBounds.size.x * rightBounds.size.y + rightBounds.size.x * rightBounds.size.z + rightBounds.size.y * rightBounds.size.z);
                float cost = surfaceAreaLeft * leftCount + surfaceAreaRight * rightCount;
                // Additional: Penalize unbalanced splits
                float balance = Mathf.Abs(leftCount - rightCount) / (float)(leftCount + rightCount);
                cost *= 1 + balance;
                return cost;
            }
            private static void CalculatePCA(List<Vector3> points, out Vector3 axis1, out Vector3 axis2, out Vector3 axis3)
            {
                if (points.Count < 3)
                {
                    axis1 = Vector3.right;
                    axis2 = Vector3.up;
                    axis3 = Vector3.forward;
                    return;
                }
                Vector3 mean = Vector3.zero;
                foreach (var p in points) mean += p;
                mean /= points.Count;
                float xx = 0, xy = 0, xz = 0, yy = 0, yz = 0, zz = 0;
                foreach (var p in points)
                {
                    Vector3 r = p - mean;
                    xx += r.x * r.x; xy += r.x * r.y; xz += r.x * r.z;
                    yy += r.y * r.y; yz += r.y * r.z; zz += r.z * r.z;
                }
                xx /= points.Count; xy /= points.Count; xz /= points.Count;
                yy /= points.Count; yz /= points.Count; zz /= points.Count;
                Matrix4x4 cov = new Matrix4x4();
                cov[0, 0] = xx; cov[0, 1] = xy; cov[0, 2] = xz;
                cov[1, 0] = xy; cov[1, 1] = yy; cov[1, 2] = yz;
                cov[2, 0] = xz; cov[2, 1] = yz; cov[2, 2] = zz;
                // Using Jacobi iterations for Eigendecomposition of the 3x3 covariance matrix
                const int maxIterations = 10;
                Matrix4x4 eigenVectors = Matrix4x4.identity;
                for (int i = 0; i < maxIterations; i++)
                {
                    float maxOffDiag = 0;
                    int p = 0, q = 1;
                    for (int j = 0; j < 3; j++)
                    {
                        for (int k = j + 1; k < 3; k++)
                        {
                            if (Mathf.Abs(cov[j, k]) > maxOffDiag)
                            {
                                maxOffDiag = Mathf.Abs(cov[j, k]);
                                p = j;
                                q = k;
                            }
                        }
                    }
                    if (maxOffDiag < 1e-6f) break;
                    float app = cov[p, p];
                    float aqq = cov[q, q];
                    float apq = cov[p, q];
                    float theta;
                    if (Mathf.Abs(app - aqq) < 1e-9f)
                    {
                        theta = Mathf.PI / 4.0f * (apq > 0 ? 1 : -1);
                    }
                    else
                    {
                        theta = 0.5f * Mathf.Atan(2 * apq / (app - aqq));
                    }
                    float c = Mathf.Cos(theta);
                    float s = Mathf.Sin(theta);
                    Matrix4x4 R = Matrix4x4.identity;
                    R[p, p] = c; R[p, q] = s;
                    R[q, p] = -s; R[q, q] = c;
                    cov = R.transpose * cov * R;
                    eigenVectors = eigenVectors * R;
                }
                axis1 = eigenVectors.GetColumn(0).normalized;
                axis2 = eigenVectors.GetColumn(1).normalized;
                axis3 = eigenVectors.GetColumn(2).normalized;
                // Additional: Sort by eigenvalue magnitude if needed
            }
            // New method for voxel-based plane scoring
            public static float ScorePlaneWithVoxels(MeshData mesh, Vector3 normal, Vector3 point, float concavityWeight, float sahWeight, float balanceWeight)
            {
                // Split voxels into left and right
                int leftVoxels = 0, rightVoxels = 0;
                float leftConcavity = 0, rightConcavity = 0;
                for (int idx = 0; idx < mesh.sdfValues.Length; idx++)
                {
                    int3 coord = new int3(idx % mesh.voxelDimensions.x, (idx / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, idx / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                    Vector3 voxelPos = mesh.VoxelToWorld(coord);
                    float side = Vector3.Dot(voxelPos - point, normal);
                    if (side <= 0)
                    {
                        leftVoxels++;
                        leftConcavity += mesh.sdfValues[idx] > 0 ? mesh.sdfValues[idx] : 0;
                    }
                    else
                    {
                        rightVoxels++;
                        rightConcavity += mesh.sdfValues[idx] > 0 ? mesh.sdfValues[idx] : 0;
                    }
                }
                float maxConcavity = Mathf.Max(leftConcavity / leftVoxels, rightConcavity / rightVoxels);
                float sahCost = EvaluateSplitPlane(mesh, normal, point);
                float balance = Mathf.Abs(leftVoxels - rightVoxels) / (float)(leftVoxels + rightVoxels);
                return concavityWeight * maxConcavity + sahWeight * sahCost + balanceWeight * balance;
            }
            // Additional: Feature-based plane generation
            public static (Vector3 normal, Vector3 point) GenerateFeaturePlane(MeshData mesh)
            {
                if (mesh.featureVertices.Count < 3) return (Vector3.up, mesh.bounds.center);
                var fv1 = mesh.vertices[mesh.featureVertices[0]];
                var fv2 = mesh.vertices[mesh.featureVertices[1]];
                var fv3 = mesh.vertices[mesh.featureVertices[2]];
                var normal = Vector3.Cross(fv2 - fv1, fv3 - fv1).normalized;
                var point = (fv1 + fv2 + fv3) / 3f;
                return (normal, point);
            }
        }
        /// <summary>
        /// Utility for splitting a MeshData object by a plane.
        /// </summary>
        public static class MeshSplitter
        {
            public static void Split(MeshData original, PlaneF plane, out MeshData positiveSide, out MeshData negativeSide)
            {
                positiveSide = new MeshData();
                negativeSide = new MeshData();
                var positiveVerts = new List<Vector3>();
                var negativeVerts = new List<Vector3>();
                int[] posRemap = new int[original.vertices.Count];
                int[] negRemap = new int[original.vertices.Count];
                float[] vertDistances = new float[original.vertices.Count];
                for (int i = 0; i < original.vertices.Count; i++)
                {
                    vertDistances[i] = plane.DistanceToPoint(original.vertices[i]);
                }
                for (int i = 0; i < original.indices.Count; i += 3)
                {
                    int i0 = original.indices[i];
                    int i1 = original.indices[i + 1];
                    int i2 = original.indices[i + 2];
                    float d0 = vertDistances[i0];
                    float d1 = vertDistances[i1];
                    float d2 = vertDistances[i2];
                    int posCount = (d0 > 0 ? 1 : 0) + (d1 > 0 ? 1 : 0) + (d2 > 0 ? 1 : 0);
                    if (posCount == 3)
                    {
                        AddTriangle(positiveSide, original, i0, i1, i2, posRemap);
                    }
                    else if (posCount == 0)
                    {
                        AddTriangle(negativeSide, original, i0, i1, i2, negRemap);
                    }
                    else // Triangle is clipped by the plane
                    {
                        ClipTriangle(original, plane, i0, i1, i2, d0, d1, d2, positiveSide, negativeSide, posRemap, negRemap);
                    }
                }
                positiveSide.Optimize();
                negativeSide.Optimize();
            }
            private static void AddTriangle(MeshData mesh, MeshData original, int i0, int i1, int i2, int[] remap)
            {
                int r0 = RemapVertex(mesh, original, i0, remap);
                int r1 = RemapVertex(mesh, original, i1, remap);
                int r2 = RemapVertex(mesh, original, i2, remap);
                mesh.indices.Add(r0); mesh.indices.Add(r1); mesh.indices.Add(r2);
            }
            private static int RemapVertex(MeshData mesh, MeshData original, int originalIndex, int[] remap)
            {
                if (remap[originalIndex] > 0) return remap[originalIndex] - 1;
                int newIndex = mesh.vertices.Count;
                mesh.vertices.Add(original.vertices[originalIndex]);
                if (original.normals.Count > originalIndex) mesh.normals.Add(original.normals[originalIndex]);
                remap[originalIndex] = newIndex + 1;
                return newIndex;
            }
            private static void ClipTriangle(MeshData original, PlaneF plane, int i0, int i1, int i2, float d0, float d1, float d2, MeshData posMesh, MeshData negMesh, int[] posRemap, int[] negRemap)
            {
                int[] indices = { i0, i1, i2 };
                float[] distances = { d0, d1, d2 };
                List<int> posIndices = new List<int>();
                List<int> negIndices = new List<int>();
                for (int i = 0; i < 3; i++)
                {
                    int current = indices[i];
                    int next = indices[(i + 1) % 3];
                    float dCurrent = distances[i];
                    float dNext = distances[(i + 1) % 3];
                    if (dCurrent >= 0)
                    {
                        posIndices.Add(RemapVertex(posMesh, original, current, posRemap));
                    }
                    else
                    {
                        negIndices.Add(RemapVertex(negMesh, original, current, negRemap));
                    }
                    // If edge crosses plane, create new vertex
                    if (dCurrent * dNext < 0)
                    {
                        float t = dCurrent / (dCurrent - dNext);
                        Vector3 intersectPoint = Vector3.Lerp(original.vertices[current], original.vertices[next], t);
                        int newPosVert = posMesh.vertices.Count;
                        posMesh.vertices.Add(intersectPoint);
                        posIndices.Add(newPosVert);
                        int newNegVert = negMesh.vertices.Count;
                        negMesh.vertices.Add(intersectPoint);
                        negIndices.Add(newNegVert);
                    }
                }
                // Triangulate resulting polygons
                if (posIndices.Count >= 3)
                {
                    for (int i = 1; i < posIndices.Count - 1; i++)
                    {
                        posMesh.indices.Add(posIndices[0]);
                        posMesh.indices.Add(posIndices[i]);
                        posMesh.indices.Add(posIndices[i + 1]);
                    }
                }
                if (negIndices.Count >= 3)
                {
                    for (int i = 1; i < negIndices.Count - 1; i++)
                    {
                        negMesh.indices.Add(negIndices[0]);
                        negMesh.indices.Add(negIndices[i]);
                        negMesh.indices.Add(negIndices[i + 1]);
                    }
                }
            }
            // Additional: Multi-plane split
            public static List<MeshData> MultiSplit(MeshData original, List<PlaneF> planes)
            {
                var parts = new List<MeshData> { original };
                foreach (var plane in planes)
                {
                    var newParts = new List<MeshData>();
                    foreach (var part in parts)
                    {
                        Split(part, plane, out MeshData pos, out MeshData neg);
                        if (pos.vertices.Count > 3) newParts.Add(pos);
                        if (neg.vertices.Count > 3) newParts.Add(neg);
                    }
                    parts = newParts;
                }
                return parts;
            }
        }
        [Header("Settings")]
        public ConvexDecompositionSettings settings;
        [Header("Input")]
        public GameObject sourceObject;
        public List<RegionBox> regionBoxes = new List<RegionBox>();
        [Header("Output")]
        public List<GameObject> hullObjects = new List<GameObject>();
        public DecompositionMetrics metrics = new DecompositionMetrics();
        [Header("Debug")]
        public bool enableInteractiveMode = false;
        public bool showRegionBounds = true;
        private MeshData combinedMesh;
        private List<ConvexHull> hulls = new List<ConvexHull>();
        private bool isProcessing = false;
        private static bool enableDetailedLoggingStatic = false; // Static for class-wide logging
        private static bool enableProfilingStatic = false;
        float ToUnitsFromMm(float mm) => (mm * 0.001f) * settings.unitsPerMeter;
        void Start()
        {
            if (sourceObject == null)
            {
                sourceObject = gameObject;
            }
            if (settings == null)
            {
                Debug.LogError("No convex decomposition settings assigned!");
                return;
            }
        }
        private void LoadAndCombineMeshData()
        {
            if (sourceObject == null)
            {
                Debug.LogError("No source object assigned!");
                return;
            }
            var meshFilters = sourceObject.GetComponentsInChildren<MeshFilter>();
            if (meshFilters.Length == 0)
            {
                Debug.LogError("No MeshFilters found in source object or its children!");
                return;
            }
            combinedMesh = new MeshData();
            int vertexOffset = 0;
            foreach (var mf in meshFilters)
            {
                if (mf.sharedMesh == null) continue;
                var mesh = mf.sharedMesh;
                vertexOffset = combinedMesh.vertices.Count;
                Matrix4x4 toWorld = transform.worldToLocalMatrix * mf.transform.localToWorldMatrix;
                var transformedVerts = new Vector3[mesh.vertexCount];
                for (int i = 0; i < mesh.vertexCount; i++)
                {
                    transformedVerts[i] = toWorld.MultiplyPoint3x4(mesh.vertices[i]);
                }
                combinedMesh.vertices.AddRange(transformedVerts);
                if (mesh.normals.Length > 0)
                {
                    var transformedNormals = new Vector3[mesh.normals.Length];
                    for (int i = 0; i < mesh.normals.Length; i++)
                    {
                        transformedNormals[i] = toWorld.MultiplyVector(mesh.normals[i]).normalized;
                    }
                    combinedMesh.normals.AddRange(transformedNormals);
                }
                var triangles = mesh.triangles;
                for (int i = 0; i < triangles.Length; i++)
                {
                    triangles[i] += vertexOffset;
                }
                combinedMesh.indices.AddRange(triangles);
            }
            combinedMesh.Optimize();

            if (settings.enableIsotropicRemeshing)
            {
                IsotropicRemesher.Remesh(combinedMesh, settings.remeshTargetEdgeLength, settings.remeshIterations);
            }

            combinedMesh.CalculateProperties();

            if (settings.acdMethod == ACDSubroutineType.CoACD)
            {
                combinedMesh.CalculateSaliency(settings.saliencyMethod, settings.heatDiffusionIterations);
                combinedMesh.IdentifySharpEdges(settings.sharpEdgeAngle);
                combinedMesh.IdentifyFeatureVertices();
            }

            combinedMesh.BuildAccelerationStructure();
            metrics.originalMeshVolume = combinedMesh.volume;
            metrics.originalMeshSurfaceArea = combinedMesh.surfaceArea;
        }
        [ContextMenu("Decompose Mesh")]
        public void DecomposeMesh()
        {
            if (isProcessing)
            {
                Debug.LogWarning("Decomposition already in progress!");
                return;
            }
            LoadAndCombineMeshData();
            if (combinedMesh == null || combinedMesh.vertexCount == 0)
            {
                Debug.LogWarning("Combined mesh is empty. Aborting decomposition.");
                return;
            }
            StartCoroutine(DecomposeMeshAsync());
        }
        private IEnumerator DecomposeMeshAsync()
        {
            isProcessing = true;
            float startTime = Time.realtimeSinceStartup;
            ClearResults();
            var regionHulls = new List<List<ConvexHull>>();
            // Process regions
            foreach (var regionBox in regionBoxes)
            {
                if (!regionBox.IsValid()) continue;
                var regionMesh = MeshBooleanOperations.BooleanIntersect(combinedMesh, regionBox.AABB);
                if (regionMesh.vertices.Count < 4) continue;
                regionMesh.Voxelize(settings.voxelSize, settings.voxelizationStrategy, settings.voxelAdaptivity);
                regionMesh.ComputeSDF(settings.sdfMethod, settings.sdfIterationCount, settings.sdfSmoothingFactor);
                var newHulls = DecomposeRegion(regionMesh, regionBox.partBudgetMax, ToUnitsFromMm(regionBox.epsilonMm));
                regionHulls.Add(newHulls);
                yield return null;
            }
            // Process remainder
            var remainderMesh = combinedMesh;
            foreach (var regionBox in regionBoxes)
            {
                remainderMesh = MeshBooleanOperations.BooleanDifference(remainderMesh, regionBox.AABB);
            }
            if (remainderMesh.vertices.Count >= 4)
            {
                remainderMesh.Voxelize(settings.voxelSize, settings.voxelizationStrategy, settings.voxelAdaptivity);
                remainderMesh.ComputeSDF(settings.sdfMethod, settings.sdfIterationCount, settings.sdfSmoothingFactor);
                regionHulls.Add(DecomposeRegion(remainderMesh, settings.maxHullCount, settings.errorTolerance));
            }
            // Flatten list
            foreach (var list in regionHulls) hulls.AddRange(list);
            MergeHulls();
            MergeHulls();
            ApplyPostProcessing();
            CreateHullObjects();
            CalculateMetrics();
            metrics.totalTime = Time.realtimeSinceStartup - startTime;
            isProcessing = false;
            Debug.Log($"Decomposition completed in {metrics.totalTime:F2}s with {hulls.Count} hulls");
        }

        private void ApplyPostProcessing()
        {
            if (!settings.enablePostProcessing) return;

            foreach (var hull in hulls)
            {
                switch (settings.postProcessingType)
                {
                    case PostProcessingType.Smoothing:
                        hull.SmoothHull(settings.smoothingIterations, settings.smoothingLambda, settings.enableBoundaryLocking);
                        break;
                    case PostProcessingType.Simplification:
                        // This is already handled by OptimizeHull, maybe call it again with a different threshold
                        hull.OptimizeHull(settings, settings.postProcessingThreshold, HullOptimizationStrategy.VertexReduction);
                        break;
                    case PostProcessingType.HoleFilling:
                        hull.FillHoles();
                        break;
                    case PostProcessingType.SymmetryEnforcement:
                        hull.EnforceSymmetry();
                        break;
                }
                hull.CalculateProperties(); // Recalculate after any modification
            }
        }
        private List<ConvexHull> DecomposeRegion(MeshData regionMesh, int budget, float tolerance)
        {
            var finalHulls = new List<ConvexHull>();
            var processQueue = new MaxPQ<(MeshData, float)>();
            if (regionMesh.vertices.Count < 4) return finalHulls;
            processQueue.Enqueue((regionMesh, CalculateConcavity(regionMesh, null)));
            while (processQueue.Count > 0 && finalHulls.Count < budget)
            {
                processQueue.TryDequeue(out var(currentMesh, currentConcavity), out _);
                if (currentMesh.vertices.Count < 4) continue;
                // 1. Generate convex hull for the current mesh part
                var hull = QuickHullImplementation.ComputeConvexHullFromPoints(currentMesh.vertices);
                if (hull.vertices.Count < 4) continue;
                hull.BuildPlanes();
                // 2. Calculate concavity using voxel/SDF
                float concavity = CalculateConcavity(currentMesh, hull);
                // 3. Check termination condition
                if (concavity < tolerance)
                {
                    finalHulls.Add(hull);
                    continue;
                }
                // 4. If concavity is too high, find best split plane
                var (splitNormal, splitPoint) = SplitPlaneEvaluator.FindBestSplitPlane(currentMesh, hull, concavity);
                var splitPlane = new PlaneF { n = splitNormal, d = -Vector3.Dot(splitNormal, splitPoint) };
                // 5. Split the mesh
                MeshSplitter.Split(currentMesh, splitPlane, out MeshData positiveSide, out MeshData negativeSide);
                // 6. Add new parts back to the queue with concavity priority
                if (positiveSide.vertices.Count > 3)
                {
                    positiveSide.Voxelize(settings.voxelSize, settings.voxelizationStrategy);
                    positiveSide.ComputeSDF();
                    float posConcavity = CalculateConcavity(positiveSide, null);
                    processQueue.Enqueue((positiveSide, posConcavity));
                }
                if (negativeSide.vertices.Count > 3)
                {
                    negativeSide.Voxelize(settings.voxelSize, settings.voxelizationStrategy);
                    negativeSide.ComputeSDF();
                    float negConcavity = CalculateConcavity(negativeSide, null);
                    processQueue.Enqueue((negativeSide, negConcavity));
                }
            }
            // Add any remaining parts from the queue as hulls if budget is exceeded
            while (processQueue.Count > 0)
            {
                processQueue.TryDequeue(out var(mesh, _), out _);
                if (mesh.vertices.Count > 3)
                {
                    finalHulls.Add(QuickHullImplementation.ComputeConvexHullFromPoints(mesh.vertices));
                }
            }
            return finalHulls;
        }
        private float CalculateConcavity(MeshData mesh, ConvexHull hull)
        {
            if (hull == null)
            {
                hull = QuickHullImplementation.ComputeConvexHullFromPoints(mesh.vertices);
            }
            // Use SDF/voxel-based concavity
            float maxConcavity = 0f;
            float averageConcavity = 0f;
            int outsideCount = 0;
            for (int idx = 0; idx < mesh.sdfValues.Length; idx++)
            {
                int3 coord = new int3(idx % mesh.voxelDimensions.x, (idx / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, idx / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                Vector3 voxelPos = mesh.VoxelToWorld(coord);
                if (!hull.ContainsPoint(voxelPos) && mesh.sdfValues[idx] < 0) // Outside hull but inside mesh
                {
                    float dist = hull.DistanceToPoint(voxelPos);
                    maxConcavity = Mathf.Max(maxConcavity, dist);
                    averageConcavity += dist;
                    outsideCount++;
                }
            }
            return outsideCount > 0 ? averageConcavity / outsideCount : 0f; // Weighted average
        }
        private void MergeHulls()
        {
            if (settings.mergingStrategy == MergingStrategy.Hierarchical)
            {
                HierarchicalMerge();
                return;
            }

            bool changed = true;
            int mergeIterations = 0;
            while (changed && mergeIterations < settings.maxOptimizationIterations)
            {
                changed = false;
                float bestCost = float.MaxValue;
                int best_i = -1, best_j = -1;

                for (int i = 0; i < hulls.Count; i++)
                {
                    for (int j = i + 1; j < hulls.Count; j++)
                    {
                        if (hulls[i].bounds.Intersects(hulls[j].bounds))
                        {
                            float cost = CalculateMergeCost(hulls[i], hulls[j], settings);
                            if (cost < bestCost)
                            {
                                bestCost = cost;
                                best_i = i;
                                best_j = j;
                            }
                        }
                    }
                }

                if (best_i != -1 && bestCost < settings.mergeThreshold)
                {
                    var merged = MeshBooleanOperations.BooleanUnion(hulls[best_i], hulls[best_j], settings);
                    hulls.RemoveAt(best_j);
                    hulls[best_i] = merged;
                    changed = true;
                    metrics.successfulMerges++;
                }
                mergeIterations++;
            }
            if (hulls.Count > 0) metrics.mergeEfficiency = (float)metrics.successfulMerges / hulls.Count;
        }

        private float CalculateMergeCost(ConvexHull h1, ConvexHull h2, ConvexDecompositionSettings settings)
        {
            var merged = MeshBooleanOperations.BooleanUnion(h1, h2);
            var hullMesh = new MeshData { vertices = merged.vertices, indices = merged.indices };
            hullMesh.Voxelize(settings.voxelSize, settings.voxelizationStrategy, settings.voxelAdaptivity);
            if (hullMesh.sdfValues.Length == 0) return float.MaxValue;
            hullMesh.ComputeSDF();

            float mergedConcavity = CalculateConcavity(hullMesh, merged);
            float volumeIncrease = merged.volume - (h1.volume + h2.volume);
            float surfaceAreaIncrease = merged.surfaceArea - (h1.surfaceArea + h2.surfaceArea);

            float concavityCost = mergedConcavity / settings.mergeConcavityThreshold;
            float volumeCost = Mathf.Max(0, volumeIncrease / (h1.volume + h2.volume));
            float surfaceAreaCost = Mathf.Max(0, surfaceAreaIncrease / (h1.surfaceArea + h2.surfaceArea));

            return concavityCost * 0.5f + volumeCost * 0.25f + surfaceAreaCost * 0.25f;
        }

        private void HierarchicalMerge()
        {
            if (hulls.Count <= 1) return;

            // Build a list of hull pairs and their merge costs
            var pairs = new List<(int, int, float)>();
            for (int i = 0; i < hulls.Count; i++)
            {
                for (int j = i + 1; j < hulls.Count; j++)
                {
                    float cost = CalculateMergeCost(hulls[i], hulls[j], settings);
                    if (cost < settings.mergeThreshold)
                    {
                        pairs.Add((i, j, cost));
                    }
                }
            }

            // Sort pairs by cost
            pairs.Sort((a, b) => a.Item3.CompareTo(b.Item3));

            var mergedIndices = new HashSet<int>();
            var newHulls = new List<ConvexHull>();

            foreach (var pair in pairs)
            {
                if (mergedIndices.Contains(pair.Item1) || mergedIndices.Contains(pair.Item2)) continue;

                var mergedHull = MeshBooleanOperations.BooleanUnion(hulls[pair.Item1], hulls[pair.Item2], settings);
                newHulls.Add(mergedHull);
                mergedIndices.Add(pair.Item1);
                mergedIndices.Add(pair.Item2);
                metrics.successfulMerges++;
            }

            // Add any unmerged hulls
            for (int i = 0; i < hulls.Count; i++)
            {
                if (!mergedIndices.Contains(i))
                {
                    newHulls.Add(hulls[i]);
                }
            }

            hulls = newHulls;
            if (hulls.Count > 0) metrics.mergeEfficiency = (float)metrics.successfulMerges / hulls.Count;
        }
        private void CreateHullObjects()
        {
            foreach (var hullObj in hullObjects) if (hullObj != null) Destroy(hullObj);
            hullObjects.Clear();
            var container = new GameObject("ConvexHulls");
            container.transform.SetParent(transform, false);
            for (int i = 0; i < hulls.Count; i++)
            {
                var hull = hulls[i];
                if (settings.enableHullOptimization && hull.vertices.Count > settings.maxVerticesPerHull)
                    hull.OptimizeHull(settings, settings.hullOptimizationThreshold);
                // Safety for convex collider:
                if ((hull.indices.Count / 3) > 255)
                    hull.OptimizeHull(settings, settings.hullOptimizationThreshold);
                var hullObj = new GameObject($"Hull_{i}");
                hullObj.transform.SetParent(container.transform, false);
                var mesh = new Mesh
                {
                    vertices = hull.vertices.ToArray(),
                    triangles = hull.indices.ToArray()
                };
                mesh.RecalculateNormals();
                mesh.RecalculateBounds();
                hullObj.AddComponent<MeshFilter>().sharedMesh = mesh;
                hullObj.AddComponent<MeshRenderer>().sharedMaterial = settings.hullMaterial ?? new Material(Shader.Find("Standard"));
                var col = hullObj.AddComponent<MeshCollider>();
                col.sharedMesh = mesh;
                col.convex = true;
                hullObjects.Add(hullObj);
            }
        }
        private void CalculateMetrics()
        {
            metrics = new DecompositionMetrics
            {
                vertexCount = combinedMesh.vertexCount,
                triangleCount = combinedMesh.triangleCount,
                hullCount = hulls.Count,
                originalMeshVolume = combinedMesh.volume,
                originalMeshSurfaceArea = combinedMesh.surfaceArea
            };
            metrics.errorDistribution = ErrorCalculator.CalculateErrorDistribution(combinedMesh, hulls, 1000);
            metrics.hullMetrics.Clear();
            for (int i = 0; i < hulls.Count; i++)
            {
                var hull = hulls[i];
                var hullMetric = new HullMetrics
                {
                    hullId = i,
                    vertexCount = hull.vertices.Count,
                    triangleCount = hull.indices.Count / 3,
                    volume = hull.volume,
                    surfaceArea = hull.surfaceArea,
                    bounds = hull.bounds,
                    centroid = hull.centroid,
                    compactness = hull.compactness,
                    aspectRatio = hull.aspectRatio
                };
                metrics.hullMetrics.Add(hullMetric);
            }
            metrics.CalculateDerivedMetrics();
            // Additional: Export if profiling
            if (settings.enableProfiling)
                metrics.ExportToCSV("decomposition_metrics.csv");
        }
        private void ClearResults()
        {
            foreach (var hullObj in hullObjects)
            {
                if (hullObj != null)
                {
#if UNITY_EDITOR
                    DestroyImmediate(hullObj);
#else
                    Destroy(hullObj);
#endif
                }
            }
            // Also destroy the container
            var container = transform.Find("ConvexHulls");
            if (container != null)
            {
#if UNITY_EDITOR
                DestroyImmediate(container.gameObject);
#else
                Destroy(container.gameObject);
#endif
            }
            hullObjects.Clear();
            hulls.Clear();
            metrics = new DecompositionMetrics();
        }
        private void OnDrawGizmos()
        {
            if (!enableInteractiveMode || settings == null) return;

            Gizmos.matrix = transform.localToWorldMatrix;

            if (showRegionBounds)
            {
                Gizmos.color = Color.yellow;
                foreach (var region in regionBoxes)
                {
                    Gizmos.DrawWireCube(region.AABB.center, region.AABB.size);
                }
            }

            if (settings.drawBvh && combinedMesh?.accelerationStructure != null)
            {
                DecompositionDebug.DrawBvh(combinedMesh.accelerationStructure);
            }
            if (settings.drawVoxels && combinedMesh?.sdfValues.IsCreated == true)
            {
                DecompositionDebug.DrawVoxels(combinedMesh);
            }
            if (settings.drawWitnessPoints)
            {
                foreach(var hull in hulls)
                {
                    if(hull.witnessPoints != null) DecompositionDebug.DrawWitnessPoints(hull);
                }
            }
            if (settings.drawSaliencyHeatmap && combinedMesh?.vertexSaliency != null)
            {
                DecompositionDebug.DrawSaliencyHeatmap(combinedMesh);
            }
        }
    }

    public static class DecompositionDebug
    {
        public static void DrawBvh(EmpartDecomposer.BVH bvh)
        {
            if (bvh == null) return;
            bvh.DrawGizmos();
        }

        public static void DrawVoxels(EmpartDecomposer.MeshData mesh)
        {
            Gizmos.color = new Color(0, 1, 1, 0.1f);
            for (int i = 0; i < mesh.sdfValues.Length; i++)
            {
                if (mesh.sdfValues[i] < 0) // Inside
                {
                    var coord = new int3(i % mesh.voxelDimensions.x, (i / mesh.voxelDimensions.x) % mesh.voxelDimensions.y, i / (mesh.voxelDimensions.x * mesh.voxelDimensions.y));
                    var worldPos = mesh.VoxelToWorld(coord);
                    Gizmos.DrawCube(worldPos, mesh.voxelBounds.size / new Vector3(mesh.voxelDimensions.x, mesh.voxelDimensions.y, mesh.voxelDimensions.z));
                }
            }
        }

        public static void DrawWitnessPoints(EmpartDecomposer.ConvexHull hull)
        {
            Gizmos.color = Color.red;
            foreach (var p in hull.witnessPoints)
            {
                Gizmos.DrawSphere(p, 0.01f);
            }
        }

        public static void DrawSaliencyHeatmap(EmpartDecomposer.MeshData mesh)
        {
            if(mesh.vertexSaliency == null || mesh.vertexSaliency.Count == 0) return;
            for(int i=0; i<mesh.indices.Count; i+=3)
            {
                var i0 = mesh.indices[i];
                var i1 = mesh.indices[i+1];
                var i2 = mesh.indices[i+2];

                var v0 = mesh.vertices[i0];
                var v1 = mesh.vertices[i1];
                var v2 = mesh.vertices[i2];

                var s0 = mesh.vertexSaliency[i0];
                var s1 = mesh.vertexSaliency[i1];
                var s2 = mesh.vertexSaliency[i2];

                var avgSaliency = (s0 + s1 + s2) / 3.0f;
                var color = Color.Lerp(Color.blue, Color.red, avgSaliency);

                Gizmos.color = color;
                Gizmos.DrawLine(v0, v1);
                Gizmos.DrawLine(v1, v2);
                Gizmos.DrawLine(v2, v0);
            }
        }
    }
}